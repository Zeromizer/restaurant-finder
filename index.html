<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Restaurant Matcher</title>
    <style>
        /* --- Base Styles --- */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Roboto, Arial, sans-serif; }
        body { 
            background-color: #f8f9fa; 
            color: #333; 
            line-height: 1.6;
            font-size: 15px;
            -webkit-text-size-adjust: 100%; /* Prevent text scaling in Safari */
            width: 100%;
            overflow-x: hidden;
        }
        :root {
            --primary: #FF5864;
            --primary-dark: #e1404d;
            --secondary: #007bff;
            --accent: #00d174;
            --light-gray: #f5f5f5;
            --mid-gray: #ddd;
            --dark-gray: #555;
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --shadow-sm: 0 2px 5px rgba(0,0,0,0.08);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.1);
            --transition: all 0.2s ease;
        }
        .container { 
            max-width: 100%; 
            width: 100%; 
            max-width: 500px; 
            margin: 0 auto; 
            padding: 15px;
            padding-left: max(15px, env(safe-area-inset-left));
            padding-right: max(15px, env(safe-area-inset-right));
            overflow: visible;
            box-sizing: border-box;
        }
        .hidden { display: none !important; }

        /* --- Typography --- */
        h1, h2, h3 { line-height: 1.3; }
        h1 { font-size: 22px; font-weight: 600; }
        h2 { font-size: 18px; font-weight: 600; }
        h3 { font-size: 16px; font-weight: 600; }
        p { margin-bottom: 0.5rem; }

        /* --- Layout Components --- */
        .card {
            background: white;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            margin-bottom: 15px;
            overflow: hidden;
        }
        .card-header {
            padding: 12px 15px;
            border-bottom: 1px solid var(--light-gray);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .card-body {
            padding: 15px;
        }
        .card-footer {
            padding: 12px 15px;
            border-top: 1px solid var(--light-gray);
        }

        /* --- View Transitions --- */
        .view { width: 100%; opacity: 1; transition: opacity 0.3s ease-in-out; display: block; }
        .view.transition-hidden { opacity: 0; height: 0; overflow: hidden; pointer-events: none; }

        /* --- Header --- */
        .header { 
            text-align: center; 
            margin-bottom: 15px; 
        }
        .header h1 { 
            color: var(--primary); 
            margin-bottom: 4px; 
        }
        .header p { 
            font-size: 14px; 
            color: var(--dark-gray);
        }

        /* --- Forms & Inputs --- */
        .search-form { 
            background-color: white; 
            border-radius: var(--radius-md); 
            padding: 15px; 
            box-shadow: var(--shadow-sm); 
            margin-bottom: 15px; 
        }
        .form-group { 
            margin-bottom: 12px; 
            position: relative;
        }
        .form-group:last-child {
            margin-bottom: 0;
        }
        label { 
            font-size: 13px;
            font-weight: 500; 
            color: var(--dark-gray); 
            display: block;
            margin-bottom: 4px;
        }
        .input-with-icon {
            position: relative;
        }
        .input-icon {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #777;
            font-size: 16px;
        }
        .button .input-icon {
            position: static;
            transform: none;
            margin-right: 6px;
            display: inline;
        }
        input, select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--mid-gray);
            border-radius: var(--radius-sm);
            font-size: 14px;
            background-color: #fff;
            height: 38px;
            transition: var(--transition);
        }
        .input-with-icon input,
        .input-with-icon select {
            padding-left: 35px;
        }
        input:focus, select:focus { 
            border-color: var(--primary); 
            outline: none; 
            box-shadow: 0 0 0 2px rgba(255, 88, 100, 0.15); 
        }
        .checkbox-group {
            display: flex;
            align-items: center;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
            height: auto;
            margin-right: 8px;
        }
        .checkbox-group label {
            margin: 0;
            display: inline;
            font-size: 13px;
        }

        /* --- Buttons --- */
        .button {
            display: inline-block;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 30px;
            padding: 9px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            text-align: center;
            width: 100%;
            transition: var(--transition);
            line-height: 1.3;
        }
        .button:hover:not(:disabled) { 
            background-color: var(--primary-dark); 
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        .button:active:not(:disabled) { 
            transform: translateY(0);
        }
        .button:disabled { 
            background-color: #ccc; 
            cursor: not-allowed; 
        }
        .button.secondary { 
            background-color: var(--secondary); 
        }
        .button.tertiary { 
            background-color: #6c757d; 
        }
        .button.outline {
            background: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }
        .button.outline:hover {
            background-color: rgba(255,88,100,0.05);
        }
        .button.small {
            font-size: 13px;
            padding: 6px 12px;
        }
        .button.icon-button {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .button.icon-button i {
            margin-right: 6px;
        }
        .button.icon-button .input-icon {
            flex-shrink: 0;
        }
        .location-button { 
            margin-top: 8px;
        }
        .action-button {
            width: 90px;
            height: 46px;
            border-radius: 23px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            box-shadow: var(--shadow-sm);
            cursor: pointer;
            transition: var(--transition);
            font-size: 18px;
            border: none;
            gap: 6px;
            margin: 0 5px;
        }
        .action-button:hover { 
            transform: scale(1.05); 
            box-shadow: var(--shadow-md);
        }
        .action-button:active { 
            transform: scale(1.02);
        }
        .like-button { 
            color: var(--accent);
        }
        .like-button::after {
            content: "Like";
            font-size: 14px;
            font-weight: 500;
        }
        .dislike-button { 
            color: var(--primary);
        }
        .dislike-button::after {
            content: "Pass";
            font-size: 14px;
            font-weight: 500;
        }
        .skip-button {
            color: var(--secondary);
            font-size: 16px;
        }
        .skip-button::after {
            content: "Results";
            font-size: 12px;
            font-weight: 500;
        }

        /* --- Restaurant Cards --- */
        .restaurant-card {
            border-radius: var(--radius-md);
            overflow: hidden;
            background: white;
            box-shadow: var(--shadow-md);
            display: flex;
            flex-direction: column;
            height: calc(100vh - 140px);
            max-height: 700px;
            position: relative;
            transition: transform 0.3s ease;
            touch-action: pan-y; /* Allow vertical scrolling but capture horizontal */
        }
        .restaurant-card.swiping-left {
            transform: translateX(-15px) rotate(-2deg);
        }
        .restaurant-card.swiping-right {
            transform: translateX(15px) rotate(2deg);
        }
        .swipe-like-overlay,
        .swipe-dislike-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            font-weight: bold;
            color: white;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .swipe-like-overlay {
            background-color: rgba(0, 209, 116, 0.7); /* Green with transparency */
        }
        .swipe-dislike-overlay {
            background-color: rgba(255, 88, 100, 0.7); /* Red with transparency */
        }
        .photo-container { 
            position: relative;
            width: 100%;
            height: 40%;
            min-height: 200px;
            overflow: hidden;
            background-color: #f0f0f0;
        }
        .card-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        .map-icon-link {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 5;
            text-decoration: none;
            color: var(--secondary);
            font-size: 20px;
        }
        .map-icon-link:hover {
            background: white;
            transform: scale(1.05);
        }
        .photo-nav { 
            position: absolute;
            left: 0;
            right: 0;
            bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1;
        }
        .photo-nav-btn { 
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 5px;
            transition: var(--transition);
        }
        .photo-nav-btn:hover { 
            background-color: rgba(0, 0, 0, 0.8);
        }
        #photo-indicators { 
            display: flex;
            justify-content: center;
            margin: 0 10px;
        }
        .photo-dot { 
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
            margin: 0 3px;
            display: inline-block;
            transition: var(--transition);
        }
        .photo-dot.active { 
            background-color: #fff;
        }
        .restaurant-info {
            padding: 15px 15px 5px 15px;
            display: flex;
            flex-direction: column;
            flex: 0 0 auto;
        }
        .restaurant-info-header {
            margin-bottom: 5px;
        }
        .restaurant-info-header h2 {
            margin-bottom: 4px;
            font-size: 18px;
            line-height: 1.3;
        }
        .restaurant-meta {
            display: flex;
            flex-wrap: wrap;
            font-size: 13px;
            color: var(--dark-gray);
            margin-bottom: 5px;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }
        .meta-item {
            margin-right: 12px;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
        }
        #restaurant-address {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }
        .travel-time-meta {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            font-weight: 500;
            margin-left: auto;
        }
        .travel-time-badge {
            background: var(--light-gray);
            padding: 2px 6px;
            border-radius: 12px;
            white-space: nowrap;
            display: flex;
            align-items: center;
        }
        .restaurant-info-reviews {
            flex: 1;
            overflow-y: auto;
            padding: 10px 15px;
            margin: 0;
            border-top: 1px solid var(--light-gray);
            border-bottom: 1px solid var(--light-gray);
            max-height: 40%;
        }
        .reviews-title {
            font-size: 15px;
            margin: 6px 0;
            display: flex;
            align-items: center;
            color: var(--dark-gray);
        }
        .review-item {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--light-gray);
        }
        .review-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .review-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        .review-author {
            font-weight: 600;
            font-size: 13px;
        }
        .review-meta {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
        }
        .review-star {
            color: #FFA534;
        }
        .review-date {
            color: #888;
            font-size: 11px;
        }
        .review-text {
            font-size: 13px;
            line-height: 1.4;
            color: var(--dark-gray);
            margin-top: 4px;
        }
        .review-text.truncated {
            cursor: pointer;
        }
        .review-text.truncated::after {
            content: "⋯ Read more";
            color: var(--secondary);
            white-space: nowrap;
            margin-left: 4px;
        }
        .review-text.expanded {
            white-space: pre-line;
        }
        
        .restaurant-info-footer {
            padding: 10px 15px;
            background: none;
            z-index: 2;
            flex-shrink: 0;
        }
        .card-actions {
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            margin-bottom: 5px;
        }

        /* --- Loading & Error --- */
        .loading {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            padding: 20px;
            text-align: center;
            color: var(--dark-gray);
        }
        .spinner {
            border: 3px solid rgba(0, 0, 0, 0.1);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border-left-color: var(--primary);
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error-message {
            color: #c0392b;
            text-align: center;
            padding: 12px;
            background-color: #fbecea;
            border: 1px solid #e74c3c;
            border-radius: var(--radius-sm);
            margin: 15px 0;
            font-size: 14px;
        }

        /* --- New Restaurant Sticker --- */
        .new-sticker {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #FF3B30;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            transform: rotate(5deg);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 10;
            animation: pulse-bounce 2s infinite;
        }
        @keyframes pulse-bounce {
            0% { transform: rotate(5deg) scale(1); }
            20% { transform: rotate(5deg) scale(1.05); }
            30% { transform: rotate(5deg) scale(1); }
            40% { transform: rotate(5deg) scale(1.05); }
            50% { transform: rotate(5deg) scale(1); }
            100% { transform: rotate(5deg) scale(1); }
        }

        /* --- Results/Matching UI --- */
        .session-code {
            font-size: 20px;
            background-color: var(--light-gray);
            padding: 5px 10px;
            border-radius: var(--radius-sm);
            user-select: all;
            cursor: pointer;
            font-family: monospace;
        }
        .copy-button {
            background: none;
            border: none;
            color: var(--dark-gray);
            font-size: 16px;
            cursor: pointer;
            padding: 3px 5px;
            vertical-align: middle;
        }
        .share-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--light-gray);
        }

        /* --- Responsive design --- */
        @media (max-width: 580px) {
            .container {
                padding: 10px;
                padding-left: max(10px, env(safe-area-inset-left));
                padding-right: max(10px, env(safe-area-inset-right));
                width: 100%;
            }
            .restaurant-card {
                height: calc(100vh - 120px);
                width: 100%;
                max-width: 100%;
            }
            .restaurant-item {
                width: 100%;
                box-sizing: border-box;
            }
            .restaurant-item-image {
                width: 70px;
                height: 70px;
            }
            /* Adjust font sizes for better mobile legibility */
            .restaurant-item h3 {
                font-size: 14px;
            }
            .restaurant-item p,
            .restaurant-item .meta-item,
            .travel-times-compact {
                font-size: 11px;
            }
        }

        /* Fix for iOS Safari notch support */
        @supports (padding: max(0px)) {
            body {
                padding-left: min(0px, env(safe-area-inset-left));
                padding-right: min(0px, env(safe-area-inset-right));
            }
            .container {
                padding-left: max(15px, env(safe-area-inset-left));
                padding-right: max(15px, env(safe-area-inset-right));
            }
        }

        /* --- Restaurant List --- */
        .restaurant-list {
            margin-top: 15px;
        }
        .restaurant-item {
            display: flex;
            background: white;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            margin-bottom: 15px;
            padding: 12px;
            width: 100%;
            box-sizing: border-box;
        }
        .restaurant-item-image {
            width: 80px;
            height: 80px;
            border-radius: var(--radius-sm);
            object-fit: cover;
            margin-right: 12px;
            flex-shrink: 0;
        }
        .restaurant-item-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0; /* Prevents flex items from overflowing */
        }
        .restaurant-item h3 {
            font-size: 15px;
            margin: 0 0 4px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .restaurant-item p {
            font-size: 12px;
            color: var(--dark-gray);
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .restaurant-item .meta-row {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 3px;
        }
        .restaurant-item .meta-item {
            font-size: 12px;
            margin-right: 12px;
            margin-bottom: 3px;
            color: var(--dark-gray);
        }
    </style>
</head>
<body>
    <div class="container">
         <div id="error-container" class="error-message hidden"></div>

        <!-- Search View -->
        <div id="search-view" class="view">
            <div class="header"> <h1>Restaurant Matcher</h1> <p>Find food places to enjoy with friends</p> </div>
            <form id="search-form" class="search-form">
                 <div class="form-group">
                    <label for="location">Location</label>
                    <div class="input-with-icon">
                        <span class="input-icon">📍</span>
                        <input id="location" type="text" placeholder="Enter city, neighborhood, or address" required />
                </div>
                    <button type="button" id="use-location-button" class="button icon-button location-button">
                        <span class="input-icon">📍</span> Use My Location
                    </button>
                </div>
                 <div class="form-group">
                    <label for="radius">Search radius</label>
                    <div class="input-with-icon">
                        <span class="input-icon">🔍</span>
                        <select id="radius" name="radius">
                            <option value="1000">1 km</option>
                            <option value="2000" selected>2 km</option>
                            <option value="5000">5 km</option>
                            <option value="10000">10 km</option>
                            <option value="20000">20 km</option>
                        </select>
                 </div>
                </div>
                <div class="form-group">
                    <label for="price-level">Price range</label>
                    <div class="input-with-icon">
                        <span class="input-icon">💰</span>
                        <select id="price-level" name="price-level">
                            <option value="">Any price</option>
                            <option value="1">$ (Inexpensive)</option>
                            <option value="2">$$ (Moderate)</option>
                            <option value="3">$$$ (Expensive)</option>
                            <option value="4">$$$$ (Very Expensive)</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <label for="cuisine-keyword">Cuisine or place type</label>
                    <div class="input-with-icon">
                        <span class="input-icon">🍽️</span>
                        <input type="text" id="cuisine-keyword" name="cuisine-keyword" placeholder="e.g., Italian, Pizza, Cafe, Hawker">
                    </div>
                </div>
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="high-rating-filter" name="high-rating-filter">
                        <label for="high-rating-filter">Only highly-rated places (4.5+ stars)</label>
                    </div>
                </div>
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="popular-places-filter" name="popular-places-filter">
                        <label for="popular-places-filter">Only popular places (4.2+ stars, 100+ reviews)</label>
                    </div>
                </div>
                <button type="submit" class="button icon-button" id="search-button">
                    <span class="input-icon">🔍</span> Find Food Places
                </button>
            </form>
        </div>

        <!-- Loading View -->
        <div id="loading-view" class="view transition-hidden"> <div class="loading"><div class="spinner"></div><p id="loading-text">Finding food places...</p></div> </div>

        <!-- Swipe View -->
        <div id="swipe-view" class="view transition-hidden">
            <div class="header">
                <h1>Find Your Match</h1>
                <p>Food Place <span id="current-index">1</span> of <span id="total-restaurants">?</span></p>
            </div>
            <div class="restaurant-card">
                <div class="photo-container">
                    <img class="card-img" id="restaurant-image" src="..." alt="Restaurant">
                    <a href="#" class="map-icon-link" id="map-link" target="_blank" rel="noopener">🗺️</a>
                    <div class="photo-nav">
                        <button id="prev-photo" class="photo-nav-btn">❮</button>
                        <div id="photo-indicators"></div>
                        <button id="next-photo" class="photo-nav-btn">❯</button>
                    </div>
                </div>
                <!-- Add swipe overlays -->
                <div class="swipe-like-overlay">❤️ LIKE</div>
                <div class="swipe-dislike-overlay">❌ PASS</div>
                <div class="restaurant-info">
                    <div class="restaurant-info-header">
                        <h2 id="restaurant-name">...</h2>
                        <div class="restaurant-meta">
                            <div style="display: flex; align-items: center;">
                                <div class="meta-item" id="restaurant-rating"><span class="meta-icon">⭐</span> ...</div>
                                <div class="meta-item" id="restaurant-price"><span class="meta-icon">💰</span> ...</div>
                            </div>
                            <div class="travel-time-meta" id="travel-times"></div>
                        </div>
                        <div class="meta-item" id="restaurant-address"><span class="meta-icon">📍</span> ...</div>
                    </div>
                </div>
                
                <div class="restaurant-info-reviews" id="restaurant-reviews">
                    <div class="reviews-title">Reviews</div>
                    <!-- Reviews will be dynamically added here -->
                </div>
                
                <div class="restaurant-info-footer">
                    <div class="card-actions">
                        <button class="action-button dislike-button" id="dislike-button">❌</button>
                        <button class="action-button skip-button" id="skip-to-results-button">⏩</button>
                        <button class="action-button like-button" id="like-button">❤️</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Results View -->
        <div id="results-view" class="view transition-hidden">
            <div class="header">
                <h1>Your Results</h1>
                <p>You liked <span id="liked-count">0</span> food place(s)</p>
            </div>
            <div class="card">
                <div class="card-header">
                    <h3>Share & Match</h3>
                </div>
                <div class="card-body">
                    <!-- Session Code -->
                    <div class="form-group">
                        <label>Your session code</label>
                        <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 15px;">
                            <span id="session-id" class="session-code">CODE</span>
                            <button id="copy-code-button" title="Copy Code" class="copy-button">📋</button>
                        </div>
                    </div>

                    <!-- Find Matches -->
                    <div class="form-group">
                        <label for="friend-code">Enter friend's code</label>
                        <input id="friend-code" type="text" placeholder="Paste friend's code"/>
                    </div>
                    <button class="button" id="find-matches-button">Find Matches</button>

                    <!-- Share Link Section -->
                    <div id="share-link-section" class="share-section">
                        <label for="share-link-input">Share your liked list</label>
                        <div style="display: flex; align-items: center;">
                            <input type="text" id="share-link-input" readonly placeholder="Generating share link...">
                            <button id="copy-link-button" title="Copy Link" class="copy-button">📋</button>
                        </div>
                    </div>
                </div>
                <div class="card-footer">
                    <!-- View Liked / Start Over -->
                    <button type="button" class="button secondary" id="view-liked-button" style="margin-bottom: 10px;">View My Liked Food Places</button>
                    <button class="button tertiary" id="start-over-button">Start Over</button>
                </div>
            </div>

            <div id="liked-restaurants-list" class="restaurant-list hidden">
                <!-- Liked restaurants populated here -->
            </div>
        </div>

        <!-- Matches View -->
        <div id="matches-view" class="view transition-hidden">
            <div class="header"> <h1>Your Matches!</h1> <p>Food places you both liked</p> </div>
            <div id="matches-list" class="restaurant-list"> <!-- Content will be generated --> </div>
            <button class="button" id="matches-start-over-button" style="margin-top:20px;">Start Over</button>
        </div>

        <!-- Shared View -->
        <div id="shared-view" class="view transition-hidden">
             <div class="header"> <h1>Shared Food Places</h1> <p id="shared-list-source">List from a friend</p> </div>
             <div id="shared-restaurants-list" class="restaurant-list">
                 <p style="text-align:center; padding: 20px;">Loading shared list...</p>
                 <!-- Shared restaurants will be populated here -->
             </div>
             <button class="button" id="shared-start-over-button" style="margin-top:20px;">Start Your Own Search</button>
        </div>

    </div>

    <script>
        // --- JS Code ---
        const views = { search: document.getElementById('search-view'), loading: document.getElementById('loading-view'), swipe: document.getElementById('swipe-view'), results: document.getElementById('results-view'), matches: document.getElementById('matches-view'),
                      shared: document.getElementById('shared-view') };
        const searchForm = document.getElementById('search-form');
        const locationInput = document.getElementById('location');
        const useLocationButton = document.getElementById('use-location-button');
        const radiusSelect = document.getElementById('radius');
        const priceLevelSelect = document.getElementById('price-level');
        const cuisineKeywordInput = document.getElementById('cuisine-keyword');
        const highRatingFilter = document.getElementById('high-rating-filter');
        const popularPlacesFilter = document.getElementById('popular-places-filter');
        const searchButton = document.getElementById('search-button');
        const loadingText = document.getElementById('loading-text');
        const swipeUI = { 
            currentIndex: document.getElementById('current-index'), 
            totalRestaurants: document.getElementById('total-restaurants'), 
            image: document.getElementById('restaurant-image'), 
            name: document.getElementById('restaurant-name'), 
            cuisine: document.getElementById('restaurant-cuisine'), 
            rating: document.getElementById('restaurant-rating'), 
            price: document.getElementById('restaurant-price'), 
            address: document.getElementById('restaurant-address'), 
            prevPhotoBtn: document.getElementById('prev-photo'), 
            nextPhotoBtn: document.getElementById('next-photo'), 
            photoIndicators: document.getElementById('photo-indicators'), 
            dislikeButton: document.getElementById('dislike-button'), 
            likeButton: document.getElementById('like-button'),
            reviews: document.getElementById('restaurant-reviews'),
            travelTimes: document.getElementById('travel-times'),
            mapLink: document.getElementById('map-link')
        };
        const resultsUI = { likedCount: document.getElementById('liked-count'), sessionId: document.getElementById('session-id'), friendCodeInput: document.getElementById('friend-code'), findMatchesButton: document.getElementById('find-matches-button'), startOverButton: document.getElementById('start-over-button'), copyCodeButton: document.getElementById('copy-code-button'),
                         viewLikedButton: document.getElementById('view-liked-button'), likedListContainer: document.getElementById('liked-restaurants-list'),
                         shareLinkSection: document.getElementById('share-link-section'),
                         shareLinkInput: document.getElementById('share-link-input'),
                         copyLinkButton: document.getElementById('copy-link-button') };
        const matchesUI = { list: document.getElementById('matches-list'), startOverButton: document.getElementById('matches-start-over-button') };
        const sharedUI = { list: document.getElementById('shared-restaurants-list'), startOverButton: document.getElementById('shared-start-over-button'), sourceText: document.getElementById('shared-list-source') };
        const errorContainer = document.getElementById('error-container');

        let restaurants = [];
        let currentIndex = 0;
        let likedRestaurants = {};
        let sessionId = '';
        let userCoordinates = null;
        let autocomplete = null;
        let currentVisibleView = views.search;

        // --- Helper Functions ---
        function showView(viewToShow) { Object.values(views).forEach(view => { if (view !== viewToShow) view.classList.add('transition-hidden'); }); viewToShow.classList.remove('transition-hidden'); currentVisibleView = viewToShow; window.scrollTo(0, 0); }
        function showError(message) { errorContainer.textContent = message; errorContainer.classList.remove('hidden'); }
        function hideError() { errorContainer.classList.add('hidden'); errorContainer.textContent = ''; }
        function setLoadingText(text) { loadingText.textContent = text; }

        // --- Google Maps & Places API Functions ---
        function loadGoogleMapsScript() {
            if (document.getElementById('google-maps-script')) return;
            const script = document.createElement('script'); script.id = 'google-maps-script';
            const apiKey = "AIzaSyCHBWV_-CcYHftllY2aZ22SfSySw9PjqFo"; // Your key
            if (!apiKey || apiKey === "YOUR_GOOGLE_MAPS_API_KEY" || apiKey.length < 20) { console.error("Google Maps API Key missing/invalid!"); showError("Map services not configured."); locationInput.disabled = true; useLocationButton.disabled = true; searchButton.disabled = true; return; }
            script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places,geometry&callback=initMapServices`;
            script.async = true; script.defer = true;
            script.onerror = () => { console.error("Failed to load Google Maps script."); showError("Failed to load location services."); };
            document.head.appendChild(script);
        }
        window.initMapServices = function() { console.log("Google Maps API loaded."); initAutocomplete(); };
        function initAutocomplete() {
            if (typeof google === 'undefined' || !google.maps?.places?.Autocomplete) { console.error("Autocomplete library not ready."); showError("Location search failed."); return; }
            try {
                // Set up autocomplete with Singapore bias
                autocomplete = new google.maps.places.Autocomplete(locationInput, { 
                    types: ['geocode', 'establishment'], 
                    fields: ['geometry', 'name', 'formatted_address', 'place_id'], 
                    componentRestrictions: { country: ['sg'] } // Restrict to Singapore
                });
                
                // Append "Singapore" to the search query if not already present
                locationInput.addEventListener('input', function() {
                    const value = this.value.trim();
                    if (value && !value.toLowerCase().includes('singapore') && 
                        !value.startsWith("Current Location") && value.length > 3) {
                        // Only append when typing has paused for 1 second
                        if (this.searchTimer) clearTimeout(this.searchTimer);
                        this.searchTimer = setTimeout(() => {
                            const cursorPosition = this.selectionStart;
                            if (!this.value.toLowerCase().includes('singapore')) {
                                this.value = value + ', Singapore';
                                // Restore cursor position to where it was before appending
                                this.setSelectionRange(cursorPosition, cursorPosition);
                            }
                        }, 1000);
                    }
                });
                
                autocomplete.addListener('place_changed', () => {
                    const place = autocomplete.getPlace(); hideError();
                    if (!place.geometry?.location) { userCoordinates = null; return; }
                    userCoordinates = { lat: place.geometry.location.lat(), lng: place.geometry.location.lng() };
                    console.log("Place selected:", place.name); locationInput.value = place.formatted_address || place.name;
                }); console.log("Autocomplete initialized.");
            } catch (error) { console.error("Error initializing Autocomplete:", error); showError("Failed to init location search."); }
        }
        function getUserLocation() {
             if (!navigator.geolocation) { showError("Geolocation not supported."); return; }
             const btn = useLocationButton; btn.textContent = "Finding..."; btn.disabled = true; hideError();
             navigator.geolocation.getCurrentPosition( (pos) => {
                 userCoordinates = { lat: pos.coords.latitude, lng: pos.coords.longitude };
                 console.log("Geolocation:", userCoordinates); locationInput.value = `Current Location (${userCoordinates.lat.toFixed(4)}, ${userCoordinates.lng.toFixed(4)})`;
                 btn.textContent = "📍 My Location"; btn.disabled = false;
             }, (err) => {
                 console.error("Geolocation error:", err); let msg = "Could not get location."; switch(err.code){case 1:msg="Permission denied.";break; case 2:msg="Position unavailable.";break; case 3:msg="Timeout.";break;} showError(msg); userCoordinates = null; locationInput.value = ''; btn.textContent = "📍 My Location"; btn.disabled = false;
             }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
         }
        function fetchRestaurants() {
            let loadingMessage = "Finding food places...";
            if (highRatingFilter.checked && popularPlacesFilter.checked) {
                loadingMessage = "Finding highly-rated popular food places...";
            } else if (highRatingFilter.checked) {
                loadingMessage = "Finding highly-rated food places...";
            } else if (popularPlacesFilter.checked) {
                loadingMessage = "Finding popular food places...";
            }
            setLoadingText(loadingMessage);
            showView(views.loading); hideError();
            const locationText = locationInput.value.trim(), radius = parseInt(radiusSelect.value), priceLevel = priceLevelSelect.value, keyword = cuisineKeywordInput.value.trim();
            if (typeof google === 'undefined' || !google.maps?.places) { showError("Location services not ready."); showView(views.search); return; }
            if (userCoordinates) { performNearbySearch(userCoordinates, radius, keyword, priceLevel); }
            else if (locationText && !locationText.startsWith("Current Location")) {
                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ address: locationText }, (results, status) => {
                    if (status === 'OK' && results?.[0]?.geometry?.location) {
                        userCoordinates = { lat: results[0].geometry.location.lat(), lng: results[0].geometry.location.lng() };
                        performNearbySearch(userCoordinates, radius, keyword, priceLevel);
                    } else { showError(`Could not find "${locationText}".`); showView(views.search); }
                });
            } else { showError("Please provide a location."); showView(views.search); }
        }
        function performNearbySearch(coords, radius, keyword, priceLevel) {
            const placesService = new google.maps.places.PlacesService(document.createElement('div'));
            
            // Create an array of types to search for - restaurant, cafe, food, etc.
            const establishmentTypes = ['restaurant', 'cafe', 'meal_takeaway', 'meal_delivery', 'bakery', 'food'];
            
            // Create an array of promises to hold all the different search requests
            const searchPromises = establishmentTypes.map(type => {
                return new Promise(resolve => {
                    let request = {
                        location: new google.maps.LatLng(coords.lat, coords.lng),
                        radius: radius,
                        type: type
                    };
            if (keyword) request.keyword = keyword;
                    if (priceLevel) {
                        const price = parseInt(priceLevel);
                        request.minPriceLevel = price;
                        request.maxPriceLevel = price;
                    }
                    
                    console.log(`Places Request for ${type}:`, request);
                    
            placesService.nearbySearch(request, (results, status) => {
                        console.log(`Places Status for ${type}:`, status);
                if (status === google.maps.places.PlacesServiceStatus.OK && results?.length > 0) {
                            resolve(results);
                        } else {
                            resolve([]); // Return empty array if no results or error
                        }
                    });
                });
            });
            
            // Additional keyword search for hawker centers, food courts, etc.
            const keywordPromise = new Promise(resolve => {
                if (!keyword || keyword.toLowerCase().includes('hawker') || keyword.toLowerCase().includes('food court')) {
                    // Only add this search if no specific keyword is provided or if looking for hawkers
                    const hawkerRequest = {
                        location: new google.maps.LatLng(coords.lat, coords.lng),
                        radius: radius,
                        keyword: keyword || 'hawker center food court'
                    };
                    
                    if (priceLevel) {
                        const price = parseInt(priceLevel);
                        hawkerRequest.minPriceLevel = price;
                        hawkerRequest.maxPriceLevel = price;
                    }
                    
                    console.log("Hawker Center Request:", hawkerRequest);
                    
                    placesService.nearbySearch(hawkerRequest, (results, status) => {
                        console.log("Hawker Center Status:", status);
                if (status === google.maps.places.PlacesServiceStatus.OK && results?.length > 0) {
                            resolve(results);
                        } else {
                            resolve([]);
                        }
                    });
                } else {
                    resolve([]); // Skip this search if specific keyword provided
                }
            });
            
            // Combine all search promises
            const allPromises = [...searchPromises, keywordPromise];
            
            // Wait for all searches to complete, then combine and deduplicate results
            Promise.all(allPromises).then(resultsArrays => {
                // Flatten array of arrays and remove duplicates based on place_id
                const allPlaces = [];
                const placeIds = new Set();
                
                resultsArrays.flat().forEach(place => {
                    if (!placeIds.has(place.place_id)) {
                        placeIds.add(place.place_id);
                        allPlaces.push(place);
                    }
                });
                
                console.log("Total unique places found:", allPlaces.length);
                
                if (allPlaces.length > 0) {
                    const operational = allPlaces.filter(p => p.business_status === 'OPERATIONAL').slice(0, 20);
                    if (operational.length === 0) {
                        showError(`No operational food establishments found.`);
                        showView(views.search);
                        return;
                    }
                    console.log("Found", operational.length, "operational food establishments.");
                    processRestaurantResults(operational, keyword);
                } else {
                    showError(`No food establishments found${keyword ? ` for "${keyword}"` : ''}.`);
                    showView(views.search);
                }
            }).catch(error => {
                console.error("Error in searches:", error);
                showError("Error searching for food establishments.");
                showView(views.search);
            });
        }
        function getPlaceDetails(placeIds) {
            const placesService = new google.maps.places.PlacesService(document.createElement('div'));
            const promises = placeIds.map(id => new Promise(res => placesService.getDetails({ 
                placeId: id, 
                fields: [
                    'photos', 'name', 'reviews', 'opening_hours', 
                    'utc_offset_minutes', 'business_status', 
                    'user_ratings_total', 'website', 'formatted_phone_number'
                ],
                reviews_sort: 'relevance' // Request reviews sorted by relevance first
            }, (d, s) => {
                // Process reviews if available
                let reviews = [];
                if (s === google.maps.places.PlacesServiceStatus.OK && d?.reviews && d.reviews.length > 0) {
                    // First review is already most relevant (by Google's ranking)
                    const mostRelevant = d.reviews[0];
                    
                    // Sort the rest by date (most recent first)
                    const otherReviews = d.reviews.slice(1).sort((a, b) => 
                        new Date(b.time * 1000) - new Date(a.time * 1000)
                    );
                    
                    // Combine: most relevant first, then two most recent
                    reviews = [mostRelevant, ...otherReviews.slice(0, 2)];
                }
                
                // Check if the place is new (3 months or less)
                // We need to analyze all reviews and additional signals to determine if the place is truly new
                let isNew = false;
                
                if (s === google.maps.places.PlacesServiceStatus.OK) {
                    // Multiple signals to check if a restaurant is new
                    
                    // 1. Review count - new places typically have few reviews
                    const fewReviews = d.user_ratings_total && d.user_ratings_total < 15;
                    
                    // 2. Review dates - check if all reviews are recent
                    let allReviewsRecent = false;
                    let hasReviews = false;
                    
                    if (d.reviews && d.reviews.length > 0) {
                        hasReviews = true;
                        // Sort all reviews by date (oldest first)
                        const sortedReviews = [...d.reviews].sort((a, b) => 
                            new Date(a.time * 1000) - new Date(b.time * 1000)
                        );
                        
                        // Get the oldest review date
                        const oldestReviewDate = new Date(sortedReviews[0].time * 1000);
                        const threeMonthsAgo = new Date();
                        threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
                        
                        // Check if oldest review is less than 3 months old
                        allReviewsRecent = oldestReviewDate > threeMonthsAgo;
                        
                        // 3. Review text analysis - look for clues
                        const reviewText = d.reviews.map(r => r.text || '').join(' ').toLowerCase();
                        
                        // Phrases that suggest the place is NOT new
                        const notNewPhrases = [
                            'been here for years', 'been open for years', 'old favorite', 
                            'long time', 'year ago', 'years ago', 'was here last year', 
                            'returned after', 'used to be', 'always been', 'regular',
                            'again', 'back to', 'still good', 'still great', 'still the best',
                            'as usual', 'as always', 'reopened', 're-opened'
                        ];
                        
                        // Phrases that suggest the place IS new
                        const newPhrases = [
                            'just opened', 'newly opened', 'new place', 'new restaurant', 
                            'new opening', 'recent opening', 'grand opening', 'soft opening',
                            'opening week', 'first week', 'first day', 'first customers',
                            'recent addition', 'recently opened', 'brand new', 'newly established',
                            'only been open', 'month since opening', 'weeks since opening'
                        ];
                        
                        const hasNotNewPhrase = notNewPhrases.some(phrase => reviewText.includes(phrase));
                        const hasNewPhrase = newPhrases.some(phrase => reviewText.includes(phrase));
                        
                        // If we have strong signals in the review text, override other factors
                        if (hasNotNewPhrase) {
                            isNew = false;
                        } else if (hasNewPhrase) {
                            isNew = true;
                        } else {
                            // 4. Combine signals - only mark as new if both conditions are met
                            isNew = fewReviews && allReviewsRecent;
                        }
                    } else {
                        // No reviews might mean it's very new, but allow other signals to override
                        isNew = true;
                    }
                    
                    // Additional signal: Very low review count is a strong indicator of newness
                    // Override previous determination if review count is extremely low (3 or fewer)
                    if (d.user_ratings_total !== undefined && d.user_ratings_total <= 3) {
                        isNew = true;
                    } else if (d.user_ratings_total > 30) {
                        // Many reviews usually means established business
                        isNew = false;
                    }
                    
                    // Business status check - OPERATIONAL doesn't tell us much about age
                    // Most places don't have their opening date in the API
                }
                
                res({ 
                    placeId: id, 
                    photos: (s === google.maps.places.PlacesServiceStatus.OK && d?.photos) ? d.photos : [],
                    reviews: reviews,
                    isNew: isNew
                });
            })));
            return Promise.all(promises);
        }
        async function processRestaurantResults(results, searchKeyword) {
             try {
                 const placeIds = results.map(r => r.place_id); const details = await getPlaceDetails(placeIds);
                 const detailsMap = details.reduce((map, d) => { 
                     map[d.placeId] = {
                         photos: d.photos || [],
                         reviews: d.reviews || [],
                         isNew: d.isNew
                     }; 
                     return map; 
                 }, {});
                 restaurants = results.map(place => {
                     const placeDetails = detailsMap[place.place_id] || { photos: [], reviews: [], isNew: false };
                     const placePhotos = placeDetails.photos;
                     const photoUrls = placePhotos.slice(0, 5).map(p => p.getUrl ? p.getUrl({ maxWidth: 800, maxHeight: 600 }) : null).filter(url => url);
                     if (photoUrls.length === 0) { photoUrls.push("https://placehold.co/800x600/FF5864/white?text=No+Image"); }
                     let displayCuisine = searchKeyword ? searchKeyword.trim().toLowerCase().replace(/\b\w/g, l => l.toUpperCase()) : getCuisineFromTypes(place.types || []);
                     return { 
                         id: place.place_id, 
                         name: place.name || "Unnamed", 
                         address: place.vicinity || "Address unavailable", 
                         cuisine: displayCuisine, 
                         rating: place.rating ? `${place.rating}★ (${place.user_ratings_total || 0})` : "Not rated", 
                         ratingValue: place.rating || 0, // Add actual numeric rating for filtering
                         user_ratings_total: place.user_ratings_total || 0, // Store total rating count for filtering
                         priceLevel: place.price_level ?? 0, 
                         photoUrls, 
                         currentPhotoIndex: 0,
                         reviews: placeDetails.reviews || [],
                         isNew: placeDetails.isNew || false,
                         // Store coordinates for travel time calculation
                         coordinates: place.geometry && place.geometry.location ? {
                             lat: place.geometry.location.lat(),
                             lng: place.geometry.location.lng()
                         } : null,
                         // Initialize travel times property
                         travelTimes: null
                     };
                 });
                 
                 // Apply filters
                 // Filter by high rating if the option is checked
                 if (highRatingFilter.checked) {
                     restaurants = restaurants.filter(place => place.ratingValue >= 4.5);
                 }
                 
                 // Filter by popular places if the option is checked
                 if (popularPlacesFilter.checked) {
                     restaurants = restaurants.filter(place => place.ratingValue >= 4.2 && place.user_ratings_total >= 100);
                 }
                 
                 if (restaurants.length === 0) { showError('No food places found matching your criteria.'); showView(views.search); return; }
                 sessionId = generateSessionId(); saveSessionToFirebase();
                 currentIndex = 0; likedRestaurants = {};
                 updateRestaurantDisplay(); showView(views.swipe);
             } catch (error) { console.error("Error processing results:", error); showError("Error loading details."); showView(views.search); }
         }
        function getCuisineFromTypes(types) { 
            const typeMap = {
                'cafe': 'Cafe',
                'bar': 'Bar',
                'bakery': 'Bakery',
                'food': 'Food Stall',
                'meal_takeaway': 'Takeaway',
                'meal_delivery': 'Delivery'
            }; 
            const knownCuisines = ["Italian", "Chinese", "Japanese", "Mexican", "Indian", "Thai", "American", "French", "Vietnamese", "Korean", "Mediterranean", "Pizza", "Sushi", "Seafood", "Steakhouse"]; 
            for(const type of types){ 
                const fmt = type.replace(/_/g,' ').replace(/\b\w/g,l=>l.toUpperCase()); 
                if(knownCuisines.includes(fmt)) return fmt; 
                if(typeMap[type]) return typeMap[type]; 
            } 
            return types.includes('restaurant') ? 'Restaurant' : (types.includes('cafe') ? 'Cafe' : 'Food Place'); 
        }
        function createGoogleMapsLink(restaurant) { 
            if (!restaurant) return null; 
            let url; 
            if (restaurant.id) { 
                url = `https://www.google.com/maps/search/?api=1&query=Google&query_place_id=${restaurant.id}`; 
            } else if (restaurant.name && restaurant.address) { 
                const query = encodeURIComponent(`${restaurant.name}, ${restaurant.address}`); 
                url = `https://www.google.com/maps/search/?api=1&query=${query}`; 
            } else { 
                return null; 
            } 
            const link = document.createElement('a'); 
            link.href = url; 
            link.textContent = "View on Google Maps ↗"; 
            link.className = "google-maps-link"; 
            link.target = "_blank"; 
            link.rel = "noopener noreferrer"; 
            return link; 
        }

        // Updated function for creating a combined maps link + travel times row
        function createMapsAndTravelRow(restaurant) {
            // Create container
            const container = document.createElement('div');
            container.className = 'maps-travel-container';
            
            // Create link
            const mapsLink = createGoogleMapsLink(restaurant);
            if (mapsLink) {
                container.appendChild(mapsLink);
            }
            
            // If we have coordinates, add travel times
            if (userCoordinates && restaurant.coordinates) {
                // Create travel times container
                const timesContainer = document.createElement('div');
                timesContainer.className = 'travel-times-inline';
                
                // Add travel times if available
                if (restaurant.travelTimes) {
                    if (restaurant.travelTimes.driving) {
                        const drivingItem = document.createElement('span');
                        drivingItem.className = 'travel-time-inline';
                        drivingItem.innerHTML = `<span class="travel-time-icon">🚗</span>${restaurant.travelTimes.driving}`;
                        timesContainer.appendChild(drivingItem);
                    }
                    
                    if (restaurant.travelTimes.transit) {
                        const transitItem = document.createElement('span');
                        transitItem.className = 'travel-time-inline';
                        transitItem.innerHTML = `<span class="travel-time-icon">🚇</span>${restaurant.travelTimes.transit}`;
                        timesContainer.appendChild(transitItem);
                    }
                } else {
                    // Calculate travel times
                    const origin = new google.maps.LatLng(userCoordinates.lat, userCoordinates.lng);
                    const destination = new google.maps.LatLng(
                        restaurant.coordinates.lat, restaurant.coordinates.lng
                    );
                    
                    const calcItem = document.createElement('span');
                    calcItem.className = 'travel-time-inline calculating';
                    calcItem.textContent = 'Calculating...';
                    timesContainer.appendChild(calcItem);
                    
                    // Get travel times asynchronously
                    getTravelTimes(origin, destination).then(times => {
                        // Store for future use
                        restaurant.travelTimes = times;
                        
                        // Clear and rebuild
                        timesContainer.innerHTML = '';
                        
                        if (times.driving) {
                            const drivingItem = document.createElement('span');
                            drivingItem.className = 'travel-time-inline';
                            drivingItem.innerHTML = `<span class="travel-time-icon">🚗</span>${times.driving}`;
                            timesContainer.appendChild(drivingItem);
                        }
                        
                        if (times.transit) {
                            const transitItem = document.createElement('span');
                            transitItem.className = 'travel-time-inline';
                            transitItem.innerHTML = `<span class="travel-time-icon">🚇</span>${times.transit}`;
                            timesContainer.appendChild(transitItem);
                        }
                        
                        if (!times.driving && !times.transit) {
                            const noDataItem = document.createElement('span');
                            noDataItem.className = 'travel-time-inline';
                            noDataItem.textContent = 'N/A';
                            timesContainer.appendChild(noDataItem);
                        }
                    });
                }
                
                container.appendChild(timesContainer);
            }
            
            return container;
        }

        // --- Travel Time Functions ---
        async function getTravelTimes(origin, destination) {
            if (!origin || !destination || typeof google === 'undefined' || !google.maps?.DistanceMatrixService) {
                return { driving: null, transit: null };
            }
            
            const service = new google.maps.DistanceMatrixService();
            
            try {
                // First get driving time
                const drivingResult = await new Promise((resolve, reject) => {
                    service.getDistanceMatrix({
                        origins: [origin],
                        destinations: [destination],
                        travelMode: google.maps.TravelMode.DRIVING,
                        unitSystem: google.maps.UnitSystem.METRIC
                    }, (response, status) => {
                        if (status === 'OK') {
                            resolve(response);
                        } else {
                            console.error("Driving time calculation failed:", status);
                            resolve(null);
                        }
                    });
                });
                
                // Then get transit time
                const transitResult = await new Promise((resolve, reject) => {
                    service.getDistanceMatrix({
                        origins: [origin],
                        destinations: [destination],
                        travelMode: google.maps.TravelMode.TRANSIT,
                        unitSystem: google.maps.UnitSystem.METRIC
                    }, (response, status) => {
                        if (status === 'OK') {
                            resolve(response);
                        } else {
                            console.error("Transit time calculation failed:", status);
                            resolve(null);
                        }
                    });
                });
                
                // Process results
                const drivingTime = drivingResult && 
                                    drivingResult.rows[0]?.elements[0]?.status === "OK" ? 
                                    drivingResult.rows[0].elements[0].duration.text : null;
                                    
                const transitTime = transitResult && 
                                    transitResult.rows[0]?.elements[0]?.status === "OK" ? 
                                    transitResult.rows[0].elements[0].duration.text : null;
                
                return { driving: drivingTime, transit: transitTime };
            } catch (error) {
                console.error("Error calculating travel times:", error);
                return { driving: null, transit: null };
            }
        }
        
        // Creates travel time elements for a restaurant
        function createTravelTimeElements(restaurant) {
            const container = document.createElement('div');
            container.className = 'travel-times';
            
            // Check if we've already calculated travel times for this restaurant
            if (restaurant.travelTimes) {
                console.log(`Using cached travel times for ${restaurant.name}`);
                // Use cached travel times
                displayTravelTimes(restaurant.travelTimes, container);
                return container;
            }
            
            if (!userCoordinates || !restaurant.coordinates) {
                return container; // Return empty container if no coordinates
            }
            
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'travel-time-loading';
            loadingDiv.textContent = 'Calculating travel times...';
            container.appendChild(loadingDiv);
            
            console.log(`Calculating new travel times for ${restaurant.name}`);
            
            // Start async calculation of travel times
            const origin = new google.maps.LatLng(userCoordinates.lat, userCoordinates.lng);
            const destination = new google.maps.LatLng(
                restaurant.coordinates.lat, 
                restaurant.coordinates.lng
            );
            
            getTravelTimes(origin, destination).then(times => {
                // Store the calculated times with the restaurant
                restaurant.travelTimes = times;
                console.log(`Travel times calculated and stored for ${restaurant.name}`);
                
                // Remove loading message
                container.removeChild(loadingDiv);
                
                // Display the travel times
                displayTravelTimes(times, container);
            }).catch(error => {
                console.error(`Travel time display error for ${restaurant.name}:`, error);
                loadingDiv.textContent = 'Unable to calculate travel times';
            });
            
            return container;
        }
        
        // Helper function to display travel times in a container
        function displayTravelTimes(times, container) {
            // Add driving time if available
            if (times.driving) {
                const drivingItem = document.createElement('div');
                drivingItem.className = 'travel-time-item';
                drivingItem.innerHTML = `<span class="travel-time-icon">🚗</span> ${times.driving}`;
                container.appendChild(drivingItem);
            }
            
            // Add transit time if available
            if (times.transit) {
                const transitItem = document.createElement('div');
                transitItem.className = 'travel-time-item';
                transitItem.innerHTML = `<span class="travel-time-icon">🚇</span> ${times.transit}`;
                container.appendChild(transitItem);
            }
            
            // If no times available, show message
            if (!times.driving && !times.transit) {
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'travel-time-item';
                noDataDiv.textContent = 'Travel time information unavailable';
                container.appendChild(noDataDiv);
            }
        }

        // --- Swipe UI Functions ---
        function updateRestaurantDisplay() {
            if (!restaurants || restaurants.length === 0 || currentIndex >= restaurants.length) {
                console.warn("No restaurants to display");
                return;
            }
            
            const restaurant = restaurants[currentIndex];
            
            // Update indexes
            swipeUI.currentIndex.textContent = currentIndex + 1;
            swipeUI.totalRestaurants.textContent = restaurants.length;
            
            // Update image
            swipeUI.image.src = restaurant.photoUrls[restaurant.currentPhotoIndex || 0];
            
            // Update photo indicators
            updatePhotoIndicators(restaurant);
            
            // Update restaurant information
            swipeUI.name.textContent = restaurant.name;
            swipeUI.rating.innerHTML = `<span class="meta-icon">⭐</span> ${restaurant.rating}`;
            swipeUI.price.innerHTML = `<span class="meta-icon">💰</span> ${restaurant.priceLevel > 0 ? '$'.repeat(restaurant.priceLevel) : 'N/A'}`;
            swipeUI.address.innerHTML = `<span class="meta-icon">📍</span> ${restaurant.address}`;
            
            // Update Google Maps link
            const mapLink = document.getElementById('map-link');
            if (mapLink && restaurant.id) {
                mapLink.href = `https://www.google.com/maps/search/?api=1&query=Google&query_place_id=${restaurant.id}`;
            } else if (mapLink) {
                mapLink.href = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(restaurant.name + ' ' + restaurant.address)}`;
            }
            
            // Add travel times to meta row
            const travelTimesContainer = document.getElementById('travel-times');
            if (travelTimesContainer) {
                travelTimesContainer.innerHTML = '';
                
                if (userCoordinates && restaurant.coordinates) {
                    // Add travel times if available
                    if (restaurant.travelTimes) {
                        if (restaurant.travelTimes.driving) {
                            const drivingBadge = document.createElement('span');
                            drivingBadge.className = 'travel-time-badge';
                            drivingBadge.innerHTML = `🚗 ${restaurant.travelTimes.driving}`;
                            travelTimesContainer.appendChild(drivingBadge);
                        }
                        
                        if (restaurant.travelTimes.transit) {
                            const transitBadge = document.createElement('span');
                            transitBadge.className = 'travel-time-badge';
                            transitBadge.innerHTML = `🚇 ${restaurant.travelTimes.transit}`;
                            travelTimesContainer.appendChild(transitBadge);
                        }
                    } else {
                        // Calculate travel times
                        const loadingBadge = document.createElement('span');
                        loadingBadge.className = 'travel-time-badge';
                        loadingBadge.textContent = 'Calculating...';
                        travelTimesContainer.appendChild(loadingBadge);
                        
                        // Get travel times asynchronously
                        const origin = new google.maps.LatLng(userCoordinates.lat, userCoordinates.lng);
                        const destination = new google.maps.LatLng(
                            restaurant.coordinates.lat, 
                            restaurant.coordinates.lng
                        );
                        
                        getTravelTimes(origin, destination).then(times => {
                            // Store for future use
                            restaurant.travelTimes = times;
                            
                            // Clear and update
                            if (travelTimesContainer) {
                                travelTimesContainer.innerHTML = '';
                                
                                if (times.driving) {
                                    const drivingBadge = document.createElement('span');
                                    drivingBadge.className = 'travel-time-badge';
                                    drivingBadge.innerHTML = `🚗 ${times.driving}`;
                                    travelTimesContainer.appendChild(drivingBadge);
                                }
                                
                                if (times.transit) {
                                    const transitBadge = document.createElement('span');
                                    transitBadge.className = 'travel-time-badge';
                                    transitBadge.innerHTML = `🚇 ${times.transit}`;
                                    travelTimesContainer.appendChild(transitBadge);
                                }
                            }
                        }).catch(err => {
                            console.error("Error getting travel times:", err);
                            if (travelTimesContainer) {
                                travelTimesContainer.innerHTML = '';
                            }
                        });
                    }
                }
            }
            
            // Update reviews section
            const reviewsContainer = document.getElementById('restaurant-reviews');
            if (reviewsContainer) {
                reviewsContainer.innerHTML = '<div class="reviews-title">Reviews</div>';
                
                // Add "NEW" badge if applicable
                if (restaurant.isNew) {
                    const newBadge = document.createElement('span');
                    newBadge.className = 'new-sticker';
                    newBadge.textContent = 'NEW';
                    reviewsContainer.querySelector('.reviews-title').appendChild(newBadge);
                }
                
                // Add reviews if available
                if (restaurant.reviews && restaurant.reviews.length > 0) {
                    // Sort reviews by relevance (if available) or date
                    const sortedReviews = [...restaurant.reviews].sort((a, b) => {
                        // First by relevance if available
                        if (a.relevance && b.relevance) {
                            return b.relevance - a.relevance;
                        }
                        // Then by date (newest first)
                        return (b.time || 0) - (a.time || 0);
                    });
                    
                    // Add each review
                    sortedReviews.forEach(review => {
                        const reviewItem = document.createElement('div');
                        reviewItem.className = 'review-item';
                        
                        // Format date
                        let dateText = '';
                        if (review.time) {
                            const reviewDate = new Date(review.time * 1000);
                            dateText = reviewDate.toLocaleDateString();
                        }
                        
                        // Create review header
                        const reviewHeader = document.createElement('div');
                        reviewHeader.className = 'review-header';
                        
                        const authorElement = document.createElement('div');
                        authorElement.className = 'review-author';
                        authorElement.textContent = review.author_name || 'Anonymous';
                        
                        const reviewMeta = document.createElement('div');
                        reviewMeta.className = 'review-meta';
                        
                        // Add star rating
                        const starElement = document.createElement('span');
                        starElement.className = 'review-star';
                        starElement.textContent = `${review.rating}★`;
                        reviewMeta.appendChild(starElement);
                        
                        // Add date if available
                        if (dateText) {
                            const dateElement = document.createElement('span');
                            dateElement.className = 'review-date';
                            dateElement.textContent = dateText;
                            reviewMeta.appendChild(dateElement);
                        }
                        
                        reviewHeader.appendChild(authorElement);
                        reviewHeader.appendChild(reviewMeta);
                        reviewItem.appendChild(reviewHeader);
                        
                        // Create review text
                        const reviewText = document.createElement('div');
                        reviewText.className = 'review-text';
                        
                        // Handle long reviews
                        const fullText = review.text || 'No review text';
                        
                        if (fullText.length > 150) {
                            reviewText.className = 'review-text truncated';
                            reviewText.setAttribute('data-full-text', fullText);
                            reviewText.textContent = fullText.substring(0, 150);
                            
                            reviewText.addEventListener('click', function() {
                                if (this.classList.contains('truncated')) {
                                    this.textContent = this.getAttribute('data-full-text');
                                    this.classList.remove('truncated');
                                    this.classList.add('expanded');
                                } else {
                                    this.textContent = this.getAttribute('data-full-text').substring(0, 150);
                                    this.classList.remove('expanded');
                                    this.classList.add('truncated');
                                }
                            });
                        } else {
                            reviewText.textContent = fullText;
                        }
                        
                        reviewItem.appendChild(reviewText);
                        
                        reviewsContainer.appendChild(reviewItem);
                    });
                } else {
                    const noReviewsElement = document.createElement('p');
                    noReviewsElement.textContent = 'No reviews available for this restaurant.';
                    noReviewsElement.style.color = '#888';
                    noReviewsElement.style.fontSize = '13px';
                    reviewsContainer.appendChild(noReviewsElement);
                }
            }
        }
        function changePhoto(direction) { if (currentIndex >= restaurants.length) return; const r=restaurants[currentIndex]; const num=r.photoUrls.length; if(num<=1)return; r.currentPhotoIndex=(r.currentPhotoIndex+direction+num)%num; updateRestaurantDisplay(); }
        function handleSwipe(liked) {
            if (currentIndex >= restaurants.length) return;
            const restaurantId = restaurants[currentIndex].id;
            if (liked) { likedRestaurants[restaurantId] = true; console.log("Liked:", restaurants[currentIndex].name); }
             else { console.log("Disliked:", restaurants[currentIndex].name); }
            saveLikesToFirebase();
            currentIndex++;
            if (currentIndex < restaurants.length) { updateRestaurantDisplay(); }
             else { showResultsView(); }
        }

        // --- Results & Matching Functions ---
        function showResultsView() {
            const likedCount = Object.keys(likedRestaurants).length;
            resultsUI.likedCount.textContent = likedCount;
            resultsUI.sessionId.textContent = sessionId;
            resultsUI.friendCodeInput.value = '';
            populateLikedRestaurantsList();
            resultsUI.likedListContainer.classList.add('hidden');
            resultsUI.viewLikedButton.textContent = 'View My Liked Food Places';
            resultsUI.viewLikedButton.style.display = likedCount > 0 ? 'block' : 'none';
            generateShareLink();
            resultsUI.shareLinkSection.style.display = likedCount > 0 ? 'block' : 'none';
            showView(views.results);
        }
        function populateLikedRestaurantsList() {
            const likedListContainer = resultsUI.likedListContainer;
            likedListContainer.innerHTML = '';
            const myLikedIds = Object.keys(likedRestaurants);
            const likedRestaurantDetails = restaurants.filter(r => myLikedIds.includes(r.id));
            
            if (likedRestaurantDetails.length > 0) {
                // Add a header for the liked list
                const listHeader = document.createElement('div');
                listHeader.className = 'card';
                listHeader.style.marginBottom = '15px';
                
                const listHeaderContent = document.createElement('div');
                listHeaderContent.className = 'card-header';
                listHeaderContent.innerHTML = `<h3>Your Liked Food Places</h3>`;
                
                listHeader.appendChild(listHeaderContent);
                likedListContainer.appendChild(listHeader);
                
                // Add each restaurant item
                likedRestaurantDetails.forEach(r => { 
                    createRestaurantItemElement(r, likedListContainer); 
                });
            } else { 
                const emptyCard = document.createElement('div');
                emptyCard.className = 'card';
                emptyCard.innerHTML = '<div class="card-body"><p style="text-align:center; padding:20px;">You haven\'t liked any food places yet.</p></div>';
                likedListContainer.appendChild(emptyCard);
            }
        }
        function findMatches() {
            const friendCode = resultsUI.friendCodeInput.value.trim().toUpperCase();
            if (!friendCode) { showError('Please enter your friend\'s code.'); return; }
            if (friendCode === sessionId) { showError('You cannot match with your own code!'); return; }
            setLoadingText("Finding matches..."); // Update loading text
            showView(views.loading); hideError();
            if (typeof firebase === 'undefined' || !firebase.apps.length) { console.warn("Firebase not init."); showError("Matching unavailable."); setTimeout(() => { displayMatches([]); showView(views.matches); }, 1500); return; }
            firebase.database().ref('sessions/' + friendCode).once('value').then(snap => {
                const friendData = snap.val();
                if (!friendData) { showError(`Friend code "${friendCode}" not found.`); showView(views.results); return; }
                const friendLikes=friendData.likes||{}; const friendLikedIds=Object.keys(friendLikes); const myLikedIds=Object.keys(likedRestaurants);
                const matchedIds=myLikedIds.filter(id=>friendLikedIds.includes(id));
                const friendRestaurantsData=friendData.restaurants||[]; const friendMap=friendRestaurantsData.reduce((map,r)=>{map[r.id]=r;return map;},{});
                const myMap=restaurants.reduce((map,r)=>{map[r.id]=r;return map;},{}); // Use current session data as fallback
                const matchedRestaurants=matchedIds.map(id=>friendMap[id]||myMap[id]).filter(r=>r); // Get details, ensuring photos are available from friendMap
                console.log("Matches found:", matchedRestaurants); displayMatches(matchedRestaurants);
            }).catch(err => { console.error("Match error:", err); showError('Could not get friend data.'); showView(views.results); });
        }
        function displayMatches(matchedRestaurants) {
            const matchesListContainer = matchesUI.list;
            matchesListContainer.innerHTML = '';
            if (matchedRestaurants.length > 0) {
                matchedRestaurants.forEach(r => { createRestaurantItemElement(r, matchesListContainer); });
            } else { matchesListContainer.innerHTML = '<p style="text-align:center; padding:20px;">No common matches found!</p>'; }
            showView(views.matches);
        }
        function createRestaurantItemElement(r, container) {
            const item = document.createElement('div');
            item.className = 'restaurant-item';
            
            // Get image URL
            const imageUrl = (r.photoUrls && r.photoUrls.length > 0) ? 
                r.photoUrls[0] : "https://placehold.co/160x160/f0f0f0/999?text=No+Image";
                
            // Create price display
            const priceDisplay = r.priceLevel > 0 ? '$'.repeat(r.priceLevel) : 'N/A';
            
            // Create item structure
            const itemImage = document.createElement('img');
            itemImage.src = imageUrl;
            itemImage.alt = r.name;
            itemImage.className = 'restaurant-item-image';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'restaurant-item-content';
            
            // Create title and basic info
            const nameElement = document.createElement('h3');
            nameElement.textContent = r.name;
            
            const metaRow = document.createElement('div');
            metaRow.className = 'meta-row';
            
            // Add rating and price
            metaRow.innerHTML = `
                <div class="meta-item"><span class="meta-icon">⭐</span> ${r.rating}</div>
                <div class="meta-item price-level"><span class="meta-icon">💰</span> ${priceDisplay}</div>
            `;
            
            // Create address
            const addressElement = document.createElement('p');
            addressElement.innerHTML = `<span class="meta-icon">📍</span> ${r.address}`;
            
            // Add elements to content div
            contentDiv.appendChild(nameElement);
            contentDiv.appendChild(metaRow);
            contentDiv.appendChild(addressElement);
            
            // Add the maps link and travel times in a single row
            contentDiv.appendChild(createMapsAndTravelRow(r));
            
            // Add a review if available - now full width
            if (r.reviews && r.reviews.length > 0) {
                const review = r.reviews[0]; // Use most relevant review
                
                const reviewDiv = document.createElement('div');
                reviewDiv.className = 'review-item';
                reviewDiv.style.marginTop = '8px';
                
                // Format date
                let dateText = 'Unknown date';
                if (review.time) {
                    const reviewDate = new Date(review.time * 1000);
                    dateText = reviewDate.toLocaleDateString();
                }
                
                // Create review header
                const reviewHeader = document.createElement('div');
                reviewHeader.className = 'review-author';
                reviewHeader.innerHTML = `
                    <div><strong>${review.author_name || 'Anonymous'}</strong></div>
                    <div><span class="review-star">${review.rating}★</span> <span class="review-date">${dateText}</span></div>
                `;
                
                // Create review text
                const reviewText = document.createElement('div');
                reviewText.className = 'review-text';
                
                // Handle long reviews
                const fullText = review.text || 'No review text';
                const isTruncated = fullText.length > 150;
                
                if (isTruncated) {
                    reviewText.className = 'review-text truncated';
                    reviewText.setAttribute('data-full-text', fullText);
                    reviewText.textContent = fullText.substring(0, 150);
                    
                    reviewText.addEventListener('click', function() {
                        if (this.classList.contains('truncated')) {
                            this.textContent = this.getAttribute('data-full-text');
                            this.classList.remove('truncated');
                            this.classList.add('expanded');
                        } else {
                            this.textContent = this.getAttribute('data-full-text').substring(0, 150);
                            this.classList.remove('expanded');
                            this.classList.add('truncated');
                        }
                    });
                } else {
                    reviewText.textContent = fullText;
                }
                
                reviewDiv.appendChild(reviewHeader);
                reviewDiv.appendChild(reviewText);
                contentDiv.appendChild(reviewDiv);
            }
            
            // Create NEW badge if applicable
            if (r.isNew) {
                const imageWrapper = document.createElement('div');
                imageWrapper.style.position = 'relative';
                
                const newSticker = document.createElement('div');
                newSticker.className = 'new-sticker';
                newSticker.textContent = 'NEW';
                newSticker.style.top = '0';
                newSticker.style.right = '0';
                newSticker.style.fontSize = '10px';
                newSticker.style.padding = '3px 6px';
                
                imageWrapper.appendChild(itemImage);
                imageWrapper.appendChild(newSticker);
                
                // Add elements to container
                item.appendChild(imageWrapper);
            } else {
                item.appendChild(itemImage);
            }
            
            item.appendChild(contentDiv);
            container.appendChild(item);
        }

        // --- Sharing Functions ---
        function generateShareLink() {
            if (!sessionId) { resultsUI.shareLinkInput.value = 'Error: No session ID.'; resultsUI.copyLinkButton.disabled = true; return; }
            const baseUrl = window.location.origin + window.location.pathname; const shareUrl = `${baseUrl}?share=${sessionId}`;
            resultsUI.shareLinkInput.value = shareUrl; resultsUI.copyLinkButton.disabled = false;
        }
        function copyShareLink() {
            const link = resultsUI.shareLinkInput.value; if (!link || !navigator.clipboard) { showError("Cannot copy link. Try selecting manually."); return; }
            navigator.clipboard.writeText(link).then(() => { const originalText = resultsUI.copyLinkButton.textContent; resultsUI.copyLinkButton.textContent = '✅'; setTimeout(() => { resultsUI.copyLinkButton.textContent = '📋'; }, 1500); }).catch(err => { console.error('Failed to copy share link:', err); showError("Failed to copy link automatically."); });
        }
        async function handleSharedLink(sharedSessionId) {
             console.log("Handling shared link for session:", sharedSessionId); setLoadingText("Loading shared list..."); showView(views.loading); hideError();
             if (typeof firebase === 'undefined' || !firebase.apps.length) { showError("Cannot load shared list: Connection error."); sharedUI.list.innerHTML = '<p class="error-message">Cannot load shared list: Connection error.</p>'; showView(views.shared); return; }
             try {
                 const sessionData = await fetchSharedSessionData(sharedSessionId);
                 if (!sessionData) { showError(`Shared list "${sharedSessionId}" not found or has expired.`); sharedUI.list.innerHTML = `<p class="error-message">Shared list "${sharedSessionId}" not found or has expired.</p>`; showView(views.shared); return; }
                 const sharedLikes = sessionData.likes || {}; const sharedLikedIds = Object.keys(sharedLikes); const sharedRestaurants = sessionData.restaurants || [];
                 if (sharedLikedIds.length === 0 || sharedRestaurants.length === 0) { sharedUI.list.innerHTML = '<p style="text-align:center; padding:20px;">This shared list is empty.</p>'; showView(views.shared); return; }
                 const likedRestaurantDetails = sharedRestaurants.filter(r => sharedLikedIds.includes(r.id));
                 displaySharedRestaurants(likedRestaurantDetails);
             } catch (error) { console.error("Error fetching shared session:", error); showError("Could not load the shared list."); sharedUI.list.innerHTML = `<p class="error-message">Could not load the shared list.</p>`; showView(views.shared); }
         }
         function fetchSharedSessionData(sessionIdToFetch) { if (!sessionIdToFetch) return Promise.resolve(null); return firebase.database().ref('sessions/' + sessionIdToFetch).once('value').then(snapshot => snapshot.val()); }
         function displaySharedRestaurants(sharedRestaurantList) {
            const container = sharedUI.list; container.innerHTML = '';
            if (sharedRestaurantList.length > 0) { sharedRestaurantList.forEach(r => { createRestaurantItemElement(r, container); }); }
            else { container.innerHTML = '<p style="text-align:center; padding:20px;">This shared list is empty or could not be loaded.</p>'; }
            sharedUI.sourceText.textContent = `Viewing a shared list`; showView(views.shared);
         }

        // --- Firebase Integration ---
        function generateSessionId() { return Math.random().toString(36).substring(2, 10).toUpperCase(); }
        function saveSessionToFirebase() {
            if(typeof firebase==='undefined'||!firebase.apps.length||!sessionId)return;
            const restaurantsToSave = restaurants.map(r => ({ 
                id: r.id, 
                name: r.name, 
                address: r.address, 
                cuisine: r.cuisine, 
                rating: r.rating, 
                priceLevel: r.priceLevel, 
                photoUrls: (r.photoUrls && r.photoUrls.length > 0) ? [r.photoUrls[0]] : [],
                reviews: r.reviews || [],
                isNew: r.isNew || false,
                coordinates: r.coordinates || null,
                travelTimes: r.travelTimes || null
            }));
            const sessionData = { restaurants: restaurantsToSave, timestamp: firebase.database.ServerValue.TIMESTAMP, likes: {} };
            firebase.database().ref('sessions/'+sessionId).set(sessionData).then(() => console.log("Session saved:", sessionId)).catch(e=>console.error("Session save error:",e));
        }
        function saveLikesToFirebase() {
            if(typeof firebase==='undefined'||!firebase.apps.length||!sessionId)return;
            firebase.database().ref('sessions/'+sessionId+'/likes').set(likedRestaurants).then(() => console.log("Likes updated for:", sessionId)).catch(e=>console.error("Likes update error:",e));
        }
        function initializeFirebase() {
            if(typeof firebase==='undefined'||typeof firebase.initializeApp==='undefined'){console.warn("Firebase SDK not ready.");return;}
            try{
                 const cfg={apiKey:"AIzaSyDauSN6vXVeflYHYdx54hIsXWeTxp-CarM",authDomain:"restaurant-finder-36e61.firebaseapp.com",databaseURL:"https://restaurant-finder-36e61-default-rtdb.asia-southeast1.firebasedatabase.app",projectId:"restaurant-finder-36e61",storageBucket:"restaurant-finder-36e61.appspot.com",messagingSenderId:"266887715200",appId:"1:266887715200:web:6c68d924d7596cdfb44965",measurementId:"G-TD5GNXZZMN"};
                 if (!firebase.apps.length) {firebase.initializeApp(cfg);console.log("Firebase initialized.");}
                 else {console.log("Firebase already initialized.");}
            }catch(e){console.error("Firebase init error:",e);showError("Sharing unavailable."); resultsUI.findMatchesButton.disabled = true; resultsUI.copyCodeButton.disabled = true; resultsUI.copyLinkButton.disabled = true;}
        }

        // --- Utility & Event Listeners ---
        function resetApp() {
            locationInput.value=''; radiusSelect.value='2000'; priceLevelSelect.value=''; cuisineKeywordInput.value=''; resultsUI.friendCodeInput.value='';
            highRatingFilter.checked = false; // Reset the high-rating filter
            popularPlacesFilter.checked = false; // Reset the popular places filter
            restaurants=[]; currentIndex=0; likedRestaurants={}; sessionId=''; userCoordinates=null;
            resultsUI.likedListContainer.innerHTML = ''; resultsUI.likedListContainer.classList.add('hidden');
            resultsUI.viewLikedButton.textContent = 'View My Liked Food Places';
            resultsUI.shareLinkInput.value = ''; resultsUI.copyLinkButton.disabled = true;
            matchesUI.list.innerHTML = ''; sharedUI.list.innerHTML = '';
            hideError();
            // Ensure URL is cleaned up if resetting from a shared link view
            if (window.location.search.includes('share=')) {
                window.history.replaceState({}, document.title, window.location.pathname); // Remove query param
            }
            showView(views.search); console.log("App reset.");
        }
        function copySessionId() {
             const code=resultsUI.sessionId.textContent; if(!code||code==='CODE'||!navigator.clipboard){showError("Copy failed.");return;}
             navigator.clipboard.writeText(code).then(()=>{const t=resultsUI.copyCodeButton.textContent;resultsUI.copyCodeButton.textContent='✅';setTimeout(()=>{resultsUI.copyCodeButton.textContent='📋';},1500);}).catch(err=>{console.error('Copy failed:',err);showError("Copy failed.");});
        }

        // --- Swipe Gesture Handling ---
        let touchStartX = 0;
        let touchStartY = 0;
        let touchDeltaX = 0;
        let touchDeltaY = 0;
        let isSwiping = false;
        let isScrolling = false;
        const SWIPE_THRESHOLD = 100;
        const SCROLL_THRESHOLD = 15;
        
        function initSwipeGestures() {
            const card = document.querySelector('.restaurant-card');
            if (!card) return;
            
            const likeOverlay = document.querySelector('.swipe-like-overlay');
            const dislikeOverlay = document.querySelector('.swipe-dislike-overlay');
            
            if (!likeOverlay || !dislikeOverlay) return;
            
            // Remove existing listeners if any (to prevent duplicates)
            card.removeEventListener('touchstart', handleTouchStart);
            card.removeEventListener('touchmove', handleTouchMove);
            card.removeEventListener('touchend', handleTouchEnd);
            card.removeEventListener('touchcancel', handleTouchCancel);
            
            // Add touch event listeners
            card.addEventListener('touchstart', handleTouchStart, { passive: true });
            card.addEventListener('touchmove', handleTouchMove, { passive: false });
            card.addEventListener('touchend', handleTouchEnd, { passive: true });
            card.addEventListener('touchcancel', handleTouchCancel, { passive: true });
            
            function handleTouchStart(e) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchDeltaX = 0;
                touchDeltaY = 0;
                isSwiping = false;
                isScrolling = false;
            }
            
            function handleTouchMove(e) {
                if (e.touches.length === 0) return;
                
                touchDeltaX = e.touches[0].clientX - touchStartX;
                touchDeltaY = e.touches[0].clientY - touchStartY;
                
                // Check if vertical scrolling
                if (Math.abs(touchDeltaY) > SCROLL_THRESHOLD && Math.abs(touchDeltaY) > Math.abs(touchDeltaX) && !isSwiping) {
                    isScrolling = true;
                    return;
                }
                
                // If we're scrolling vertically, don't swipe
                if (isScrolling) return;
                
                // Once we've determined it's a horizontal swipe
                if (Math.abs(touchDeltaX) > 20 && !isScrolling) {
                    isSwiping = true;
                    e.preventDefault(); // Prevent scrolling while swiping
                    
                    if (touchDeltaX > 0) {
                        // Swiping right (like)
                        card.classList.add('swiping-right');
                        card.classList.remove('swiping-left');
                        likeOverlay.style.opacity = Math.min(touchDeltaX / (SWIPE_THRESHOLD * 1.5), 0.8);
                        dislikeOverlay.style.opacity = 0;
                    } else {
                        // Swiping left (dislike)
                        card.classList.add('swiping-left');
                        card.classList.remove('swiping-right');
                        dislikeOverlay.style.opacity = Math.min(Math.abs(touchDeltaX) / (SWIPE_THRESHOLD * 1.5), 0.8);
                        likeOverlay.style.opacity = 0;
                    }
                }
            }
            
            function handleTouchEnd() {
                if (isSwiping && !isScrolling) {
                    if (touchDeltaX > SWIPE_THRESHOLD) {
                        // Swipe right completed - Like
                        handleSwipe(true);
                    } else if (touchDeltaX < -SWIPE_THRESHOLD) {
                        // Swipe left completed - Dislike
                        handleSwipe(false);
                    }
                }
                resetSwipeState();
            }
            
            function handleTouchCancel() {
                resetSwipeState();
            }
        }
        
        function resetSwipeState() {
            const card = document.querySelector('.restaurant-card');
            const likeOverlay = document.querySelector('.swipe-like-overlay');
            const dislikeOverlay = document.querySelector('.swipe-dislike-overlay');
            
            if (!card || !likeOverlay || !dislikeOverlay) return;
            
            isSwiping = false;
            isScrolling = false;
            
            card.classList.remove('swiping-left', 'swiping-right');
            likeOverlay.style.opacity = 0;
            dislikeOverlay.style.opacity = 0;
        }
        
        function skipToResults() {
            // Save session to Firebase before transitioning
            saveSessionToFirebase();
            
            // Update liked count display
            const likedCount = Object.keys(likedRestaurants).length;
            resultsUI.likedCount.textContent = likedCount;
            
            // Generate share link
            generateShareLink();
            
            // Transition to results view
            showView(views.results);
            
            // Populate liked restaurants list
            populateLikedRestaurantsList();
        }

        window.swipeUI = swipeUI; window.resultsUI = resultsUI; window.matchesUI = matchesUI; window.sharedUI = sharedUI;

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', function(){
            // Page setup
            setTimeout(initializeFirebase, 500);
            loadGoogleMapsScript();
            
            // Search view events
            searchForm.addEventListener('submit', function(e) { e.preventDefault(); fetchRestaurants(); });
            useLocationButton.addEventListener('click', getUserLocation);
            
            // Swipe view events
            swipeUI.prevPhotoBtn.addEventListener('click', showPreviousPhoto);
            swipeUI.nextPhotoBtn.addEventListener('click', showNextPhoto);
            swipeUI.dislikeButton.addEventListener('click', () => handleSwipe(false));
            swipeUI.likeButton.addEventListener('click', () => handleSwipe(true));
            document.getElementById('skip-to-results-button').addEventListener('click', skipToResults);
            
            // Initialize swipe gestures when entering swipe view
            // We need to re-initialize after each view change to capture the current card
            views.swipe.addEventListener('transitionend', function(e) {
                if (e.target === views.swipe && !views.swipe.classList.contains('transition-hidden')) {
                    // Only initialize when swipe view becomes visible
                    setTimeout(initSwipeGestures, 100); // Short delay to ensure DOM is ready
                }
            });
            
            // Initialize immediately if swipe view is already visible
            if (!views.swipe.classList.contains('transition-hidden')) {
                setTimeout(initSwipeGestures, 100);
            }
            
            // Results view events
            resultsUI.findMatchesButton.addEventListener('click', findMatches);
            resultsUI.startOverButton.addEventListener('click', resetApp);
            resultsUI.copyCodeButton.addEventListener('click', copySessionId);
            resultsUI.sessionId.addEventListener('click', () => { 
                if (resultsUI.sessionId.textContent !== 'CODE') { 
                    window.getSelection().selectAllChildren(resultsUI.sessionId); 
                }
            });
            resultsUI.viewLikedButton.addEventListener('click', () => { 
                console.log("View liked button clicked");
                const isHidden = resultsUI.likedListContainer.classList.toggle('hidden'); 
                console.log("Liked list is now:", isHidden ? "hidden" : "visible");
                
                // Update button text
                resultsUI.viewLikedButton.textContent = isHidden ? 'View My Liked Food Places' : 'Hide My Liked Food Places'; 
                
                // If showing the list, make sure it's populated
                if (!isHidden) {
                    console.log("Populating liked restaurants list");
                    populateLikedRestaurantsList();
                }
            });
            resultsUI.copyLinkButton.addEventListener('click', copyShareLink);
            
            // Other view events
            matchesUI.startOverButton.addEventListener('click', resetApp);
            sharedUI.startOverButton.addEventListener('click', resetApp);
            
            // Check for shared link params
            const urlParams = new URLSearchParams(window.location.search);
            const shareId = urlParams.get('share');
            
            if (shareId) {
                // If share ID exists, prepare to handle it after Firebase is ready
                setLoadingText("Loading shared list...");
                showView(views.loading); // Show loading early
                
                const firebaseInitInterval = setInterval(() => {
                    // Check if Firebase is initialized
                    if (typeof firebase !== 'undefined' && firebase.apps.length > 0 && firebase.database()) {
                        clearInterval(firebaseInitInterval);
                        console.log("Firebase ready, handling shared link...");
                        handleSharedLink(shareId); // Handle the link AFTER Firebase is ready
                    }
                }, 150); // Check slightly less frequently
                
                // Timeout safeguard in case Firebase never loads/initializes
                setTimeout(() => {
                    // Check if we are still stuck on loading or haven't transitioned to shared view
                    if(currentVisibleView === views.loading || currentVisibleView !== views.shared){
                        clearInterval(firebaseInitInterval);
                        console.error("Timeout waiting for Firebase initialization for shared link.");
                        showError("Failed to initialize services to load shared list in time.");
                        // Decide on a fallback view - Resetting is usually safest
                        resetApp(); // Reset state and show search view
                    }
                }, 10000); // 10 second timeout
            } else {
                // Normal startup sequence: Just show the search view
                showView(views.search);
            }
        });

        function showPreviousPhoto() {
            if (!restaurants[currentIndex]) return;
            const r = restaurants[currentIndex];
            if (!r.photoUrls || r.photoUrls.length <= 1) return;
            r.currentPhotoIndex = (r.currentPhotoIndex - 1 + r.photoUrls.length) % r.photoUrls.length;
            swipeUI.image.src = r.photoUrls[r.currentPhotoIndex];
            
            // Only update photo indicators, don't recreate travel times
            updatePhotoIndicators(r);
        }
        
        function showNextPhoto() {
            if (!restaurants[currentIndex]) return;
            const r = restaurants[currentIndex];
            if (!r.photoUrls || r.photoUrls.length <= 1) return;
            r.currentPhotoIndex = (r.currentPhotoIndex + 1) % r.photoUrls.length;
            swipeUI.image.src = r.photoUrls[r.currentPhotoIndex];
            
            // Only update photo indicators, don't recreate travel times
            updatePhotoIndicators(r);
        }
        
        // New function to update only photo indicators, separate from full display update
        function updatePhotoIndicators(restaurant) {
            if (!swipeUI.photoIndicators) return;
            
            swipeUI.photoIndicators.innerHTML = '';
            if (!restaurant || !restaurant.photoUrls) return;
            
            restaurant.photoUrls.forEach((_, index) => {
                const dot = document.createElement('span');
                dot.className = 'photo-dot' + (index === restaurant.currentPhotoIndex ? ' active' : '');
                swipeUI.photoIndicators.appendChild(dot);
            });
        }

        function navigatePhoto(direction) {
            const r = restaurants[currentIndex];
            if (!r || !r.photoUrls || r.photoUrls.length <= 1) return;
            
            const num = r.photoUrls.length;
            r.currentPhotoIndex = ((r.currentPhotoIndex || 0) + direction + num) % num;
            
            // Only update photo indicators, don't recreate travel times
            if (swipeUI.image) {
                swipeUI.image.src = r.photoUrls[r.currentPhotoIndex];
            }
            updatePhotoIndicators(r);
        }
    </script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js" defer></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js" defer></script>

</body>
</html>
