<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Restaurant Matcher</title>
    <style>
        /* --- Base Styles --- */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Roboto, Arial, sans-serif; }
        body { 
            background-color: #f8f9fa; 
            color: #333; 
            line-height: 1.6;
            font-size: 15px;
            -webkit-text-size-adjust: 100%; /* Prevent text scaling in Safari */
            width: 100%;
            overflow-x: hidden;
        }
        :root {
            --primary: #FF5864;
            --primary-dark: #e1404d;
            --secondary: #007bff;
            --accent: #00d174;
            --light-gray: #f5f5f5;
            --mid-gray: #ddd;
            --dark-gray: #555;
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --shadow-sm: 0 2px 5px rgba(0,0,0,0.08);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.1);
            --transition: all 0.2s ease;
        }
        .container { 
            max-width: 100%; 
            width: 100%; 
            max-width: 500px; 
            margin: 0 auto; 
            padding: 15px;
            padding-left: max(15px, env(safe-area-inset-left));
            padding-right: max(15px, env(safe-area-inset-right));
            overflow: visible;
            box-sizing: border-box;
        }
        .hidden { display: none !important; }

        /* --- Typography --- */
        h1, h2, h3 { line-height: 1.3; }
        h1 { font-size: 22px; font-weight: 600; }
        h2 { font-size: 18px; font-weight: 600; }
        h3 { font-size: 16px; font-weight: 600; }
        p { margin-bottom: 0.5rem; }

        /* --- Layout Components --- */
        .card {
            background: white;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            margin-bottom: 15px;
            overflow: hidden;
        }
        .card-header {
            padding: 12px 15px;
            border-bottom: 1px solid var(--light-gray);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .card-body {
            padding: 15px;
        }
        .card-footer {
            padding: 12px 15px;
            border-top: 1px solid var(--light-gray);
        }

        /* --- View Transitions --- */
        .view { width: 100%; opacity: 1; transition: opacity 0.3s ease-in-out; display: block; }
        .view.transition-hidden { opacity: 0; height: 0; overflow: hidden; pointer-events: none; }

        /* --- Header --- */
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        .header h1 {
            margin: 0 0 5px 0;
            color: var(--primary);
            font-size: 24px;
            font-weight: 600;
        }
        .header p {
            margin: 10px 0;
            color: var(--dark-gray);
            font-size: 16px;
            font-weight: 500;
        }
        
        /* Specific header styles for swipe view */
        #swipe-view .header {
            margin-bottom: 10px;
        }
        #swipe-view .header p {
            margin: 5px 0;
            font-size: 18px;
            font-weight: 500;
            color: var(--primary);
        }

        /* --- Forms & Inputs --- */
        .search-form { 
            background-color: white; 
            border-radius: var(--radius-md); 
            padding: 15px; 
            box-shadow: var(--shadow-sm); 
            margin-bottom: 15px;
            position: relative;
            overflow: hidden; /* Prevent icons from leaking outside */
        }
        .form-group { 
            margin-bottom: 12px; 
            position: relative;
            width: 100%;
            overflow: visible;
        }
        .form-group:last-child {
            margin-bottom: 0;
        }
        label { 
            font-size: 13px;
            font-weight: 500; 
            color: var(--dark-gray); 
            display: block;
            margin-bottom: 4px;
        }
        .input-with-icon {
            position: relative;
            display: flex;
            align-items: center;
            width: 100%;
            overflow: hidden; /* Ensure icons don't leak out */
        }
        .input-icon {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #777;
            font-size: 16px;
            z-index: 1;
            pointer-events: none; /* Makes sure the icon doesn't interfere with clicks */
            user-select: none; /* Prevent selection */
            display: inline-block; /* Ensure proper containment */
            height: 16px; /* Fix height */
            width: 16px; /* Fix width */
            text-align: center; /* Center the icon */
        }
        .button .input-icon {
            position: static;
            transform: none;
            margin-right: 6px;
            display: inline;
            height: auto;
            width: auto;
        }
        input, select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--mid-gray);
            border-radius: var(--radius-sm);
            font-size: 14px;
            background-color: #fff;
            height: 38px;
            transition: var(--transition);
        }
        .input-with-icon input,
        .input-with-icon select {
            padding-left: 35px;
        }
        input:focus, select:focus { 
            border-color: var(--primary); 
            outline: none; 
            box-shadow: 0 0 0 2px rgba(255, 88, 100, 0.15); 
        }
        .checkbox-group {
            display: flex;
            align-items: center;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
            height: auto;
            margin-right: 8px;
        }
        .checkbox-group label {
            margin: 0;
            display: inline;
            font-size: 13px;
        }

        /* --- Buttons --- */
        .button {
            display: inline-block;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 30px;
            padding: 9px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            text-align: center;
            width: 100%;
            transition: var(--transition);
            line-height: 1.3;
        }
        .button:hover:not(:disabled) { 
            background-color: var(--primary-dark); 
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        .button:active:not(:disabled) { 
            transform: translateY(0);
        }
        .button:disabled { 
            background-color: #ccc; 
            cursor: not-allowed; 
        }
        .button.secondary { 
            background-color: var(--secondary); 
        }
        .button.tertiary { 
            background-color: #6c757d; 
        }
        .button.outline {
            background: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }
        .button.outline:hover {
            background-color: rgba(255,88,100,0.05);
        }
        .button.small {
            font-size: 13px;
            padding: 6px 12px;
        }
        .button.icon-button {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .button.icon-button i {
            margin-right: 6px;
        }
        .button.icon-button .input-icon {
            flex-shrink: 0;
        }
        .location-button { 
            margin-top: 8px;
        }
        .action-button {
            width: 90px;
            height: 46px;
            border-radius: 23px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            box-shadow: var(--shadow-sm);
            cursor: pointer;
            transition: var(--transition);
            font-size: 18px;
            border: none;
            gap: 6px;
            margin: 0 5px;
        }
        .action-button:hover { 
            transform: scale(1.05); 
            box-shadow: var(--shadow-md);
        }
        .action-button:active { 
            transform: scale(1.02);
        }
        .like-button { 
            color: var(--accent);
        }
        .like-button::after {
            content: "Like";
            font-size: 14px;
            font-weight: 500;
        }
        .dislike-button { 
            color: var(--primary);
        }
        .dislike-button::after {
            content: "Pass";
            font-size: 14px;
            font-weight: 500;
        }
        .skip-button {
            color: var(--secondary);
            font-size: 16px;
        }
        .skip-button::after {
            content: "Results";
            font-size: 12px;
            font-weight: 500;
        }

        /* --- Restaurant Cards --- */
        .restaurant-card {
            border-radius: var(--radius-md);
            overflow: hidden;
            background: white;
            box-shadow: var(--shadow-md);
            display: flex;
            flex-direction: column;
            height: calc(100vh - 140px);
            max-height: 700px;
            position: relative;
            transition: transform 0.3s ease;
            touch-action: pan-y; /* Allow vertical scrolling but capture horizontal */
        }
        .restaurant-card.swiping-left {
            transform: translateX(-15px) rotate(-2deg);
        }
        .restaurant-card.swiping-right {
            transform: translateX(15px) rotate(2deg);
        }
        .swipe-like-overlay,
        .swipe-dislike-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            font-weight: bold;
            color: white;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .swipe-like-overlay {
            background-color: rgba(0, 209, 116, 0.7); /* Green with transparency */
        }
        .swipe-dislike-overlay {
            background-color: rgba(255, 88, 100, 0.7); /* Red with transparency */
        }
        .photo-container { 
            position: relative;
            width: 100%;
            height: 40%;
            min-height: 200px;
            overflow: hidden;
            background-color: #f0f0f0;
        }
        .card-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        .photo-nav { 
            position: absolute;
            left: 0;
            right: 0;
            bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1;
        }
        .photo-nav-btn { 
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 5px;
            transition: var(--transition);
        }
        .photo-nav-btn:hover { 
            background-color: rgba(0, 0, 0, 0.8);
        }
        #photo-indicators { 
            display: flex;
            justify-content: center;
            margin: 0 10px;
        }
        .photo-dot { 
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
            margin: 0 3px;
            display: inline-block;
            transition: var(--transition);
        }
        .photo-dot.active { 
            background-color: #fff;
        }
        .restaurant-info {
            padding: 15px 15px 5px 15px;
            display: flex;
            flex-direction: column;
            flex: 0 0 auto;
        }
        .restaurant-info-header {
            margin-bottom: 5px;
        }
        .restaurant-info-header h2 {
            margin-bottom: 4px;
            font-size: 18px;
            line-height: 1.3;
        }
        .restaurant-meta {
            display: flex;
            flex-wrap: wrap;
            font-size: 13px;
            color: var(--dark-gray);
            margin-bottom: 5px;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }
        .meta-item {
            margin-right: 12px;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
        }
        #restaurant-address {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }
        .travel-time-meta {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            font-weight: 500;
            margin-left: auto;
        }
        .travel-time-badge {
            background: var(--light-gray);
            padding: 2px 6px;
            border-radius: 12px;
            white-space: nowrap;
            display: flex;
            align-items: center;
        }
        .restaurant-info-reviews {
            flex: 1;
            overflow-y: auto;
            padding: 10px 15px;
            margin: 0;
            border-top: 1px solid var(--light-gray);
            border-bottom: 1px solid var(--light-gray);
            max-height: 40%;
        }
        .reviews-title {
            font-size: 15px;
            margin: 6px 0;
            display: flex;
            align-items: center;
            color: var(--dark-gray);
        }
        .review-item {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--light-gray);
        }
        .review-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .review-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        .review-author {
            font-weight: 600;
            font-size: 13px;
        }
        .review-meta {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
        }
        .review-star {
            color: #FFA534;
        }
        .review-date {
            color: #888;
            font-size: 11px;
        }
        .review-text {
            font-size: 13px;
            line-height: 1.4;
            color: var(--dark-gray);
            margin-top: 4px;
        }
        .review-text.truncated {
            cursor: pointer;
        }
        .review-text.truncated::after {
            content: "‚ãØ Read more";
            color: var(--secondary);
            white-space: nowrap;
            margin-left: 4px;
        }
        .review-text.expanded {
            white-space: pre-line;
        }
        
        .restaurant-info-footer {
            padding: 10px 15px;
            background: none;
            z-index: 2;
            flex-shrink: 0;
        }
        .card-actions {
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            margin-bottom: 5px;
        }

        /* --- Loading & Error --- */
        .loading {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            padding: 20px;
            text-align: center;
            color: var(--dark-gray);
        }
        .spinner {
            border: 3px solid rgba(0, 0, 0, 0.1);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border-left-color: var(--primary);
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error-message {
            color: #c0392b;
            text-align: center;
            padding: 12px;
            background-color: #fbecea;
            border: 1px solid #e74c3c;
            border-radius: var(--radius-sm);
            margin: 15px 0;
            font-size: 14px;
        }

        /* --- New Restaurant Sticker --- */
        .new-sticker {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #FF3B30;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            transform: rotate(5deg);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 10;
            animation: pulse-bounce 2s infinite;
        }
        @keyframes pulse-bounce {
            0% { transform: rotate(5deg) scale(1); }
            20% { transform: rotate(5deg) scale(1.05); }
            30% { transform: rotate(5deg) scale(1); }
            40% { transform: rotate(5deg) scale(1.05); }
            50% { transform: rotate(5deg) scale(1); }
            100% { transform: rotate(5deg) scale(1); }
        }

        /* --- Results/Matching UI --- */
        .session-code {
            font-size: 20px;
            background-color: var(--light-gray);
            padding: 5px 10px;
            border-radius: var(--radius-sm);
            user-select: all;
            cursor: pointer;
            font-family: monospace;
        }
        .copy-button {
            background: none;
            border: none;
            color: var(--dark-gray);
            font-size: 16px;
            cursor: pointer;
            padding: 3px 5px;
            vertical-align: middle;
        }
        .share-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--light-gray);
        }

        /* --- Responsive design --- */
        @media (max-width: 580px) {
            .container {
             padding: 10px;
                padding-left: max(10px, env(safe-area-inset-left));
                padding-right: max(10px, env(safe-area-inset-right));
                width: 100%;
            }
            .restaurant-card {
                height: calc(100vh - 120px);
                width: 100%;
                max-width: 100%;
            }
            .restaurant-item {
                width: 100%;
                box-sizing: border-box;
            }
            .restaurant-item-image {
                width: 70px;
                height: 70px;
            }
            /* Adjust font sizes for better mobile legibility */
            .restaurant-item h3 {
                font-size: 14px;
            }
            .restaurant-item p,
            .restaurant-item .meta-item,
            .travel-times-compact {
                font-size: 11px;
            }
            .input-with-icon {
                width: 100%;
            }
            .input-with-icon input,
            .input-with-icon select {
                width: 100%;
                padding-left: 35px;
            }
            /* Ensure icons don't overflow outside their containers */
            .input-icon {
                font-size: 14px; /* Slightly smaller icons on mobile */
            }
        }

        /* Fix for iOS Safari notch support */
        @supports (padding: max(0px)) {
            body {
                padding-left: min(0px, env(safe-area-inset-left));
                padding-right: min(0px, env(safe-area-inset-right));
            }
            .container {
                padding-left: max(15px, env(safe-area-inset-left));
                padding-right: max(15px, env(safe-area-inset-right));
            }
        }

        /* --- Restaurant List --- */
        .restaurant-list {
            margin-top: 15px;
        }
        .restaurant-item {
            display: flex;
            background: white;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            margin-bottom: 15px;
            padding: 12px;
            width: 100%;
            box-sizing: border-box;
        }
        .restaurant-item-image-container {
            position: relative;
            width: 80px;
            flex-shrink: 0;
            margin-right: 12px;
            display: flex;
            flex-direction: column;
        }
        .restaurant-item-image {
            width: 80px;
            height: 80px;
            border-radius: var(--radius-sm);
            object-fit: cover;
        }
        .restaurant-item-actions {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 4px;
            gap: 5px;
        }
        .map-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background-color: #f0f0f0;
            border-radius: 4px;
            padding: 3px 5px;
            font-size: 14px;
            color: #555;
            text-decoration: none;
            width: 90%;
            text-align: center;
        }
        .map-icon:hover {
            background-color: #e0e0e0;
        }
        .travel-times-below {
            display: flex;
            flex-direction: column;
            gap: 3px;
            width: 90%;
        }
        .travel-time-badge {
            background-color: #f0f0f0;
            border-radius: 4px;
            padding: 2px 4px;
            font-size: 10px;
            color: #555;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }
        .restaurant-item-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0; /* Prevents flex items from overflowing */
        }
        .restaurant-item h3 {
            font-size: 15px;
            margin: 0 0 4px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .restaurant-item p {
            font-size: 12px;
            color: var(--dark-gray);
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .restaurant-item .meta-row {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 3px;
        }
        .restaurant-item .meta-item {
            font-size: 12px;
            margin-right: 12px;
            margin-bottom: 3px;
            color: var(--dark-gray);
        }

        /* Add styles for LLM insights */
        .llm-insights {
            margin-top: 10px;
            background-color: #f8f8ff; /* Lighter background */
            border-left: 2px solid #6c3fcc; /* Thinner accent line */
            padding: 8px 10px;
            border-radius: 4px;
            font-size: 13px;
        }

        .llm-insights-title {
            display: flex;
            align-items: center;
            font-weight: 600;
            margin-bottom: 6px;
            color: #6c3fcc;
            font-size: 12px;
        }

        .llm-insight-item {
            margin-bottom: 4px;
            padding-left: 4px;
            position: relative;
        }

        .llm-insight-item:before {
            content: "‚Ä¢";
            position: absolute;
            left: -8px;
            color: #6c3fcc;
        }

        .llm-insights-compact {
            margin-top: 6px;
            margin-bottom: 4px;
            padding: 6px 8px;
            background-color: #f8f8ff; /* Lighter background */
            border-left: 2px solid #6c3fcc; /* Thinner accent line */
            border-radius: 3px;
            font-size: 11px;
        }

        .llm-insights-compact p {
            margin: 0;
            color: #6c3fcc;
            display: flex;
            align-items: center;
        }

        .llm-insights-compact .ai-icon {
            margin-right: 4px;
            font-size: 12px;
        }

        .more-insights-badge {
            margin-left: 4px;
            background-color: #a67af4;
            color: white;
            border-radius: 10px;
            padding: 0 6px;
            font-size: 9px;
            line-height: 1.4;
        }

        /* --- API Key Container --- */
        .api-key-container {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        .api-key-note {
            font-size: 12px;
            color: #666;
        }

        .score-insight {
            font-weight: bold;
            background-color: #6c3fcc;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            margin-top: 5px;
            display: inline-block;
        }

        .score-badge {
            margin-left: 6px;
            background-color: #6c3fcc;
            color: white;
            border-radius: 10px;
            padding: 1px 6px;
            font-size: 9px;
            line-height: 1.4;
            font-weight: bold;
        }

        /* --- New Styles --- */
        .llm-insight-paragraph {
            margin: 5px 0;
            line-height: 1.4;
            color: #333;
            font-size: 13px;
        }

        .llm-insight-item {
            margin-bottom: 4px;
            padding-left: 0;
            position: relative;
        }

        .llm-insight-item:before {
            content: none;
        }

        /* --- Address Links --- */
        .address-link {
            color: #3B82F6;
            text-decoration: none;
        }

        .address-link:hover {
            text-decoration: underline;
        }
        
        /* API Usage Stats */
        .api-usage-stats {
            margin-top: 20px;
            padding: 10px;
            background-color: #f8f8ff;
            border-radius: 4px;
            border-left: 2px solid #6c3fcc;
            font-size: 12px;
            color: #6c3fcc;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
         <div id="error-container" class="error-message hidden"></div>

    </style>
</head>
<body>
    <div class="container">
         <div id="error-container" class="error-message hidden"></div>

        <!-- Search View -->
        <div id="search-view" class="view">
            <div class="header"> <h1>Restaurant Matcher</h1> <p>Find food places with our AI-powered ranking system</p> </div>
            <form id="search-form" class="search-form">
                 <div class="form-group">
                    <label for="location">Location</label>
                    <div class="input-with-icon">
                        <span class="input-icon">üìç</span>
                        <input id="location" type="text" placeholder="Enter city, neighborhood, or address" required />
                </div>
                    <button type="button" id="use-location-button" class="button icon-button location-button">
                        <span class="input-icon">üìç</span> Use My Location
                    </button>
                </div>
                 <div class="form-group">
                    <label for="radius">Search radius</label>
                    <div class="input-with-icon">
                        <span class="input-icon">üîç</span>
                        <select id="radius" name="radius">
                            <option value="1000">1 km</option>
                            <option value="2000" selected>2 km</option>
                            <option value="5000">5 km</option>
                            <option value="10000">10 km</option>
                            <option value="20000">20 km</option>
                        </select>
                 </div>
                </div>
                <div class="form-group">
                    <label for="price-level">Price range</label>
                    <div class="input-with-icon">
                        <span class="input-icon">üí∞</span>
                        <select id="price-level" name="price-level">
                            <option value="">Any price</option>
                            <option value="1">$ (Inexpensive)</option>
                            <option value="2">$$ (Moderate)</option>
                            <option value="3">$$$ (Expensive)</option>
                            <option value="4">$$$$ (Very Expensive)</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <label for="cuisine-keyword">Cuisine or place type</label>
                    <div class="input-with-icon">
                        <span class="input-icon">üçΩÔ∏è</span>
                        <input type="text" id="cuisine-keyword" name="cuisine-keyword" placeholder="e.g., Italian, Pizza, Cafe, Hawker">
                    </div>
                </div>
                <div id="api-key-container" class="api-key-container hidden">
                    <!-- This section is hidden and no longer used -->
                </div>
                <button type="submit" class="button icon-button" id="search-button">
                    <span class="input-icon">üîç</span> Find Food Places
                </button>
            </form>
            <div id="api-usage-stats" class="api-usage-stats">
                <p>API Usage Stats: <span id="api-usage-display">Loading...</span></p>
            </div>
        </div>

        <!-- Loading View -->
        <div id="loading-view" class="view transition-hidden"> <div class="loading"><div class="spinner"></div><p id="loading-text">Finding food places...</p></div> </div>

        <!-- Swipe View -->
        <div id="swipe-view" class="view transition-hidden">
            <div class="header">
                <p>Food Place <span id="current-index">1</span> of <span id="total-restaurants">?</span></p>
            </div>
            <div class="restaurant-card">
                <div class="photo-container">
                    <img class="card-img" id="restaurant-image" src="..." alt="Restaurant">
                    <div class="photo-nav">
                        <button id="prev-photo" class="photo-nav-btn">‚ùÆ</button>
                        <div id="photo-indicators"></div>
                        <button id="next-photo" class="photo-nav-btn">‚ùØ</button>
                    </div>
                </div>
                <!-- Add swipe overlays -->
                <div class="swipe-like-overlay">‚ù§Ô∏è LIKE</div>
                <div class="swipe-dislike-overlay">‚ùå PASS</div>
                <div class="restaurant-info">
                    <div class="restaurant-info-header">
                        <h2 id="restaurant-name">...</h2>
                        <div class="restaurant-meta">
                            <div style="display: flex; align-items: center;">
                                <div class="meta-item" id="restaurant-rating"><span class="meta-icon">‚≠ê</span> ...</div>
                                <div class="meta-item" id="restaurant-price"><span class="meta-icon">üí∞</span> ...</div>
                            </div>
                            <div class="travel-time-meta" id="travel-times"></div>
                        </div>
                        <div class="meta-item" id="restaurant-address"><span class="meta-icon">üìç</span> ...</div>
                    </div>
                </div>
                
                <div class="restaurant-info-reviews" id="restaurant-reviews">
                    <div class="reviews-title">Reviews</div>
                    <!-- Reviews will be dynamically added here -->
                </div>
                
                <div class="restaurant-info-footer">
                    <div class="card-actions">
                        <button class="action-button dislike-button" id="dislike-button">‚ùå</button>
                        <button class="action-button skip-button" id="skip-to-results-button">‚è©</button>
                        <button class="action-button like-button" id="like-button">‚ù§Ô∏è</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Results View -->
        <div id="results-view" class="view transition-hidden">
            <div class="header">
                <h1>Your Results</h1>
                <p>You liked <span id="liked-count">0</span> food place(s)</p>
            </div>
            <div class="card">
                <div class="card-header">
                    <h3>Share & Match</h3>
                </div>
                <div class="card-body">
                 <!-- Session Code -->
                    <div class="form-group">
                        <label>Your session code</label>
                        <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 15px;">
                            <span id="session-id" class="session-code">CODE</span>
                            <button id="copy-code-button" title="Copy Code" class="copy-button">üìã</button>
                        </div>
                    </div>

                 <!-- Find Matches -->
                    <div class="form-group">
                        <label for="friend-code">Enter friend's code</label>
                        <input id="friend-code" type="text" placeholder="Paste friend's code"/>
                    </div>
                 <button class="button" id="find-matches-button">Find Matches</button>

                 <!-- Share Link Section -->
                    <div id="share-link-section" class="share-section">
                        <label for="share-link-input">Share your liked list</label>
                     <div style="display: flex; align-items: center;">
                         <input type="text" id="share-link-input" readonly placeholder="Generating share link...">
                            <button id="copy-link-button" title="Copy Link" class="copy-button">üìã</button>
                    </div>
                 </div>
                </div>
                <div class="card-footer">
                 <!-- View Liked / Start Over -->
                    <button type="button" class="button secondary" id="view-liked-button" style="margin-bottom: 10px;">View My Liked Food Places</button>
                    <button class="button tertiary" id="start-over-button">Start Over</button>
                </div>
             </div>

             <div id="liked-restaurants-list" class="restaurant-list hidden">
                 <!-- Liked restaurants populated here -->
             </div>
        </div>

        <!-- Matches View -->
        <div id="matches-view" class="view transition-hidden">
            <div class="header"> <h1>Your Matches!</h1> <p>Food places you both liked</p> </div>
            <div id="matches-list" class="restaurant-list"> <!-- Content will be generated --> </div>
            <button class="button" id="matches-start-over-button" style="margin-top:20px;">Start Over</button>
        </div>

        <!-- Shared View -->
        <div id="shared-view" class="view transition-hidden">
             <div class="header"> <h1>Shared Food Places</h1> <p id="shared-list-source">List from a friend</p> </div>
             <div id="shared-restaurants-list" class="restaurant-list">
                 <p style="text-align:center; padding: 20px;">Loading shared list...</p>
                 <!-- Shared restaurants will be populated here -->
             </div>
             <button class="button" id="shared-start-over-button" style="margin-top:20px;">Start Your Own Search</button>
        </div>

    </div>

    <script>
        // --- JS Code ---
        const views = { search: document.getElementById('search-view'), loading: document.getElementById('loading-view'), swipe: document.getElementById('swipe-view'), results: document.getElementById('results-view'), matches: document.getElementById('matches-view'),
                      shared: document.getElementById('shared-view') };
        const searchForm = document.getElementById('search-form');
        const locationInput = document.getElementById('location');
        const useLocationButton = document.getElementById('use-location-button');
        const radiusSelect = document.getElementById('radius');
        const priceLevelSelect = document.getElementById('price-level');
        const cuisineKeywordInput = document.getElementById('cuisine-keyword');
        const searchButton = document.getElementById('search-button');
        const loadingText = document.getElementById('loading-text');
        const swipeUI = { 
            currentIndex: document.getElementById('current-index'), 
            totalRestaurants: document.getElementById('total-restaurants'), 
            image: document.getElementById('restaurant-image'), 
            name: document.getElementById('restaurant-name'), 
            cuisine: document.getElementById('restaurant-cuisine'), 
            rating: document.getElementById('restaurant-rating'), 
            price: document.getElementById('restaurant-price'), 
            address: document.getElementById('restaurant-address'), 
            prevPhotoBtn: document.getElementById('prev-photo'), 
            nextPhotoBtn: document.getElementById('next-photo'), 
            photoIndicators: document.getElementById('photo-indicators'), 
            dislikeButton: document.getElementById('dislike-button'), 
            likeButton: document.getElementById('like-button'),
            reviews: document.getElementById('restaurant-reviews'),
            travelTimes: document.getElementById('travel-times'),
            mapLink: document.getElementById('map-link')
        };
        const resultsUI = { likedCount: document.getElementById('liked-count'), sessionId: document.getElementById('session-id'), friendCodeInput: document.getElementById('friend-code'), findMatchesButton: document.getElementById('find-matches-button'), startOverButton: document.getElementById('start-over-button'), copyCodeButton: document.getElementById('copy-code-button'),
                         viewLikedButton: document.getElementById('view-liked-button'), likedListContainer: document.getElementById('liked-restaurants-list'),
                         shareLinkSection: document.getElementById('share-link-section'),
                         shareLinkInput: document.getElementById('share-link-input'),
                         copyLinkButton: document.getElementById('copy-link-button') };
        const matchesUI = { list: document.getElementById('matches-list'), startOverButton: document.getElementById('matches-start-over-button') };
        const sharedUI = { list: document.getElementById('shared-restaurants-list'), startOverButton: document.getElementById('shared-start-over-button'), sourceText: document.getElementById('shared-list-source') };
        const errorContainer = document.getElementById('error-container');

        let restaurants = [];
        let currentIndex = 0;
        let likedRestaurants = {};
        let sessionId = '';
        let userCoordinates = null;
        let autocomplete = null;
        let currentVisibleView = views.search;

        // --- Helper Functions ---
        function showView(viewToShow) { Object.values(views).forEach(view => { if (view !== viewToShow) view.classList.add('transition-hidden'); }); viewToShow.classList.remove('transition-hidden'); currentVisibleView = viewToShow; window.scrollTo(0, 0); }
        function showError(message) { errorContainer.textContent = message; errorContainer.classList.remove('hidden'); }
        function hideError() { errorContainer.classList.add('hidden'); errorContainer.textContent = ''; }
        function setLoadingText(text) { loadingText.textContent = text; }

        // --- Google Maps & Places API Functions ---
        function loadGoogleMapsScript() {
            if (document.getElementById('google-maps-script')) return;
            const script = document.createElement('script'); script.id = 'google-maps-script';
            const apiKey = "AIzaSyCHBWV_-CcYHftllY2aZ22SfSySw9PjqFo"; // Your key
            if (!apiKey || apiKey === "YOUR_GOOGLE_MAPS_API_KEY" || apiKey.length < 20) { console.error("Google Maps API Key missing/invalid!"); showError("Map services not configured."); locationInput.disabled = true; useLocationButton.disabled = true; searchButton.disabled = true; return; }
            script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places,geometry&callback=initMapServices`;
            script.async = true; script.defer = true;
            script.onerror = () => { console.error("Failed to load Google Maps script."); showError("Failed to load location services."); };
            document.head.appendChild(script);
        }
        window.initMapServices = function() { console.log("Google Maps API loaded."); initAutocomplete(); };
        function initAutocomplete() {
            if (typeof google === 'undefined' || !google.maps?.places?.Autocomplete) { console.error("Autocomplete library not ready."); showError("Location search failed."); return; }
            try {
                // Set up autocomplete with Singapore bias
                autocomplete = new google.maps.places.Autocomplete(locationInput, { 
                    types: ['geocode', 'establishment'], 
                    fields: ['geometry', 'name', 'formatted_address', 'place_id'], 
                    componentRestrictions: { country: ['sg'] } // Restrict to Singapore
                });
                
                // Append "Singapore" to the search query if not already present
                locationInput.addEventListener('input', function() {
                    const value = this.value.trim();
                    if (value && !value.toLowerCase().includes('singapore') && 
                        !value.startsWith("Current Location") && value.length > 3) {
                        // Only append when typing has paused for 1 second
                        if (this.searchTimer) clearTimeout(this.searchTimer);
                        this.searchTimer = setTimeout(() => {
                            const cursorPosition = this.selectionStart;
                            if (!this.value.toLowerCase().includes('singapore')) {
                                this.value = value + ', Singapore';
                                // Restore cursor position to where it was before appending
                                this.setSelectionRange(cursorPosition, cursorPosition);
                            }
                        }, 1000);
                    }
                });
                
                autocomplete.addListener('place_changed', () => {
                    const place = autocomplete.getPlace(); hideError();
                    if (!place.geometry?.location) { userCoordinates = null; return; }
                    userCoordinates = { lat: place.geometry.location.lat(), lng: place.geometry.location.lng() };
                    console.log("Place selected:", place.name); locationInput.value = place.formatted_address || place.name;
                }); console.log("Autocomplete initialized.");
            } catch (error) { console.error("Error initializing Autocomplete:", error); showError("Failed to init location search."); }
        }
        function getUserLocation() {
             if (!navigator.geolocation) { showError("Geolocation not supported."); return; }
             const btn = useLocationButton; btn.textContent = "Finding..."; btn.disabled = true; hideError();
             navigator.geolocation.getCurrentPosition( (pos) => {
                 userCoordinates = { lat: pos.coords.latitude, lng: pos.coords.longitude };
                 console.log("Geolocation:", userCoordinates); locationInput.value = `Current Location (${userCoordinates.lat.toFixed(4)}, ${userCoordinates.lng.toFixed(4)})`;
                 btn.textContent = "üìç My Location"; btn.disabled = false;
             }, (err) => {
                 console.error("Geolocation error:", err); let msg = "Could not get location."; switch(err.code){case 1:msg="Permission denied.";break; case 2:msg="Position unavailable.";break; case 3:msg="Timeout.";break;} showError(msg); userCoordinates = null; locationInput.value = ''; btn.textContent = "üìç My Location"; btn.disabled = false;
             }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
         }
        function fetchRestaurants() {
            let loadingMessage = "Finding food places...";
            
            setLoadingText(loadingMessage);
            showView(views.loading); hideError();
            const locationText = locationInput.value.trim(), radius = parseInt(radiusSelect.value), priceLevel = priceLevelSelect.value, keyword = cuisineKeywordInput.value.trim();
            if (typeof google === 'undefined' || !google.maps?.places) { showError("Location services not ready."); showView(views.search); return; }
            if (userCoordinates) { performNearbySearch(userCoordinates, radius, keyword, priceLevel); }
            else if (locationText && !locationText.startsWith("Current Location")) {
                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ address: locationText }, (results, status) => {
                    if (status === 'OK' && results?.[0]?.geometry?.location) {
                        userCoordinates = { lat: results[0].geometry.location.lat(), lng: results[0].geometry.location.lng() };
                        performNearbySearch(userCoordinates, radius, keyword, priceLevel);
                    } else { showError(`Could not find "${locationText}".`); showView(views.search); }
                });
            } else { showError("Please provide a location."); showView(views.search); }
        }
        function performNearbySearch(coords, radius, keyword, priceLevel) {
            // Generate cache key based on search parameters
            const cacheKey = JSON.stringify({
                lat: coords.lat.toFixed(6),
                lng: coords.lng.toFixed(6),
                radius,
                keyword: keyword || '',
                priceLevel: priceLevel || ''
            });
            
            // First check server cache (preferred)
            getServerCachedNearbySearch(cacheKey)
                .then(serverCachedResults => {
                    if (serverCachedResults) {
                        console.log("Using server-cached nearby search results");
                        processCachedResults(serverCachedResults, keyword);
                        return true; // Indicate we used server cache
                    }
                    
                    // Then check local cache
                    const localCachedResults = window.placesCache?.getCachedNearbySearch(cacheKey);
                    if (localCachedResults) {
                        console.log("Using locally cached nearby search results");
                        
                        // Also save to server cache for future use
                        saveServerNearbySearch(cacheKey, localCachedResults).catch(console.error);
                        
                        processCachedResults(localCachedResults, keyword);
                        return true; // Indicate we used local cache
                    }
                    
                    return false; // Indicate we need to do an API search
                })
                .then(cacheHit => {
                    if (cacheHit) return; // Skip API search if we got results from cache
            
            // If not in cache, proceed with API call
            const placesService = new google.maps.places.PlacesService(document.createElement('div'));
            
            // Reduced to only search for restaurant and food to minimize API calls
            const establishmentTypes = ['restaurant', 'food', 'cafe'];
            
            // Create an array of promises to hold all the different search requests
            const searchPromises = establishmentTypes.map(type => {
                return new Promise(resolve => {
                    let request = {
                        location: new google.maps.LatLng(coords.lat, coords.lng),
                        radius: radius,
                        type: type
                    };
            if (keyword) request.keyword = keyword;
                    if (priceLevel) {
                        const price = parseInt(priceLevel);
                        request.minPriceLevel = price;
                        request.maxPriceLevel = price;
                    }
                    
                    console.log(`Places Request for ${type}:`, request);
                    
            placesService.nearbySearch(request, (results, status) => {
                        console.log(`Places Status for ${type}:`, status);
                if (status === google.maps.places.PlacesServiceStatus.OK && results?.length > 0) {
                            resolve(results);
                        } else {
                            resolve([]); // Return empty array if no results or error
                        }
                    });
                });
            });
            
            // Wait for all searches to complete, then combine and deduplicate results
            Promise.all(searchPromises).then(resultsArrays => {
                // Flatten array of arrays and remove duplicates based on place_id
                const allPlaces = [];
                const placeIds = new Set();
                
                resultsArrays.flat().forEach(place => {
                    if (!placeIds.has(place.place_id)) {
                        placeIds.add(place.place_id);
                        allPlaces.push(place);
                    }
                });
                
                console.log("Total unique places found:", allPlaces.length);
                
                        // Cache the results in both local and server cache
                if (allPlaces.length > 0) {
                    window.placesCache?.cacheNearbySearch(cacheKey, allPlaces);
                            saveServerNearbySearch(cacheKey, allPlaces).catch(console.error);
                }
                
                if (allPlaces.length > 0) {
                    const operational = allPlaces.filter(p => p.business_status === 'OPERATIONAL').slice(0, 30);
                    if (operational.length === 0) {
                        showError(`No operational food establishments found.`);
                        showView(views.search);
                        return;
                    }
                    console.log("Found", operational.length, "operational food establishments.");
                    processRestaurantResults(operational, keyword);
                } else {
                    showError(`No food establishments found${keyword ? ` for "${keyword}"` : ''}.`);
                    showView(views.search);
                }
            }).catch(error => {
                console.error("Error in searches:", error);
                        showError("Error searching for food establishments.");
                        showView(views.search);
                    });
                })
                .catch(error => {
                    console.error("Error checking caches:", error);
                showError("Error searching for food establishments.");
                showView(views.search);
            });
        }
        
        // Helper function to process cached results
        function processCachedResults(cachedResults, keyword) {
            if (cachedResults.length > 0) {
                // Ensure the cached results have the necessary structure for further processing
                const operational = cachedResults.filter(p => p.business_status === 'OPERATIONAL').slice(0, 30);
                if (operational.length === 0) {
                    showError(`No operational food establishments found.`);
                    showView(views.search);
                    return;
                }
                console.log("Found", operational.length, "cached operational food establishments.");
                
                // Fix for geometry.location to ensure it has lat() and lng() methods
                // if they were stored as plain properties
                operational.forEach(place => {
                    if (place.geometry && place.geometry.location) {
                        // Create proper lat and lng methods if they don't exist
                        if (typeof place.geometry.location.lat !== 'function') {
                            const originalLat = place.geometry.location.lat;
                            place.geometry.location.lat = function() { return originalLat; };
                        }
                        if (typeof place.geometry.location.lng !== 'function') {
                            const originalLng = place.geometry.location.lng;
                            place.geometry.location.lng = function() { return originalLng; };
                        }
                    }
                });
                
                processRestaurantResults(operational, keyword);
            } else {
                showError(`No food establishments found${keyword ? ` for "${keyword}"` : ''}.`);
                showView(views.search);
            }
        }
        function getPlaceDetails(placeIds) {
            const placesService = new google.maps.places.PlacesService(document.createElement('div'));
            
            // First check server cache for all IDs
            return Promise.all(placeIds.map(id => getServerCachedPlaceDetails(id)))
                .then(serverCachedDetails => {
                    const cachedDetails = {};  // Will hold all cached details from either source
                    const uncachedPlaceIds = []; // Will hold IDs we need to fetch
                    
                    // Process server-cached results first
                    serverCachedDetails.forEach((detail, index) => {
                        const id = placeIds[index];
                        if (detail) {
                            cachedDetails[id] = detail;
                        } else {
                            // If not in server cache, check local cache
                            const localCachedDetail = window.placesCache?.getCachedPlaceDetails(id);
                            if (localCachedDetail) {
                                cachedDetails[id] = localCachedDetail;
                                // Save to server cache for future use
                                saveServerPlaceDetails(id, localCachedDetail).catch(console.error);
                } else {
                    uncachedPlaceIds.push(id);
                            }
                }
            });
            
                    console.log(`Using ${Object.keys(cachedDetails).length} cached place details (${serverCachedDetails.filter(Boolean).length} from server) and fetching ${uncachedPlaceIds.length} new ones`);
            
            // If all details are in cache, return immediately
            if (uncachedPlaceIds.length === 0) {
                        // Convert cached details to the expected format
                        return placeIds.map(id => {
                    const cachedDetail = cachedDetails[id];
                            
                    // Process cached photos to ensure compatibility
                            if (cachedDetail && cachedDetail.photos && Array.isArray(cachedDetail.photos)) {
                        // Convert the serialized photo objects to match the structure
                        // expected by the rest of the application
                        cachedDetail.photos = cachedDetail.photos.map(photo => {
                            if (photo.url) {
                                // Create a photo-like object with a getUrl method that works with any params
                                return {
                                    getUrl: (options) => photo.url,
                                    width: photo.width || 1000,
                                    height: photo.height || 800,
                                    html_attributions: photo.html_attributions || []
                                };
                            }
                            return photo;
                        });
                    } else if (cachedDetail) {
                        // Ensure photos is an array even if empty
                        cachedDetail.photos = [];
                    }
                    return cachedDetail;
                        });
            }
            
            // Otherwise fetch only the uncached place details
                    const promises = uncachedPlaceIds.map(id => new Promise(res => {
                        placesService.getDetails({ 
                placeId: id, 
                fields: [
                    'photos', 'name', 'reviews', 'opening_hours', 
                    'utc_offset_minutes', 'business_status', 
                    'user_ratings_total', 'website', 'formatted_phone_number'
                ],
                reviews_sort: 'relevance' // Request reviews sorted by relevance first
            }, (d, s) => {
                // Process reviews if available
                let reviews = [];
                let isNew = false;
                
                            if (s === google.maps.places.PlacesServiceStatus.OK && d?.reviews) {
                                reviews = d.reviews.map(review => ({
                                    author_name: review.author_name || 'Anonymous',
                                    profile_photo_url: review.profile_photo_url || '',
                                    rating: review.rating || 0,
                                    relative_time_description: review.relative_time_description || '',
                                    text: review.text || '',
                                    time: review.time || 0
                                }));
                                
                                // Determine if place is new based on reviews
                                if (reviews.length) {
                                    // Logic for determining if a place is new based on reviews
                                    const now = Date.now() / 1000;
                                    const reviewTimes = reviews.map(r => r.time).filter(Boolean);
                                    const fewReviews = reviewTimes.length <= 3;
                                    const avgReviewTime = reviewTimes.reduce((a, b) => a + b, 0) / reviewTimes.length;
                                    const avgReviewAgeInDays = (now - avgReviewTime) / (24 * 60 * 60);
                                    const allReviewsRecent = avgReviewAgeInDays < 90;
                                    
                                    // Phrases that might indicate newness in review text
                                    const allReviewText = reviews.map(r => r.text || '').join(' ').toLowerCase();
                                    const newPhrases = ['just opened', 'newly opened', 'new restaurant', 'new place', 'grand opening', 'soft opening', 'recently opened'];
                                    const notNewPhrases = ['been coming here for years', 'old favorite', 'always come here', 'many years', 'come back', 'came back', 'regular'];
                                    
                                    // Check for these phrases
                                    const hasNewPhrase = newPhrases.some(phrase => allReviewText.includes(phrase));
                                    const hasNotNewPhrase = notNewPhrases.some(phrase => allReviewText.includes(phrase));
                                    
                        if (hasNotNewPhrase) {
                            isNew = false;
                        } else if (hasNewPhrase) {
                            isNew = true;
                        } else {
                            isNew = fewReviews && allReviewsRecent;
                        }
                    } else {
                                    isNew = true; // No reviews might indicate it's new
                                }
                                
                                // Additional review count check
                                if (d.user_ratings_total !== undefined) {
                                    if (d.user_ratings_total <= 3) {
                        isNew = true;
                    } else if (d.user_ratings_total > 30) {
                        isNew = false;
                    }
                                }
                }
                
                            // Create the detail result
                const detailResult = { 
                    placeId: id, 
                    photos: (s === google.maps.places.PlacesServiceStatus.OK && d?.photos) ? d.photos : [],
                    reviews: reviews,
                    isNew: isNew
                };
                
                            // Cache the result in both local and server caches
                window.placesCache?.cachePlaceDetails(id, detailResult);
                            saveServerPlaceDetails(id, detailResult).catch(console.error);
                
                res(detailResult);
                        });
                    }));
            
            // Combine cached and newly fetched details
            return Promise.all(promises).then(newDetails => {
                        // Create a result array with details in the same order as placeIds
                        return placeIds.map(id => {
                            // First check if we have this ID in our newly fetched details
                            const newDetail = newDetails.find(d => d.placeId === id);
                            if (newDetail) return newDetail;
                            
                            // Otherwise use cached detail
                            const cachedDetail = cachedDetails[id];
                            
                            // Process cached photos as before
                            if (cachedDetail && cachedDetail.photos && Array.isArray(cachedDetail.photos)) {
                                cachedDetail.photos = cachedDetail.photos.map(photo => {
                                    if (photo.url) {
                                        return {
                                            getUrl: (options) => photo.url,
                                            width: photo.width || 1000,
                                            height: photo.height || 800,
                                            html_attributions: photo.html_attributions || []
                                        };
                                    }
                                    return photo;
                                });
                            } else if (cachedDetail) {
                                cachedDetail.photos = [];
                            }
                            
                            return cachedDetail || {
                                placeId: id,
                                photos: [],
                                reviews: [],
                                isNew: false
                            };
                        });
                    });
                })
                .catch(error => {
                    console.error("Error fetching place details:", error);
                    // Fallback to a basic implementation if there's an error
                    return placeIds.map(id => ({
                        placeId: id,
                        photos: [],
                        reviews: [],
                        isNew: false
                    }));
            });
        }
        async function processRestaurantResults(results, searchKeyword) {
             try {
                 const placeIds = results.map(r => r.place_id); const details = await getPlaceDetails(placeIds);
                 const detailsMap = details.reduce((map, d) => { 
                     map[d.placeId] = {
                         photos: d.photos || [],
                         reviews: d.reviews || [],
                         isNew: d.isNew
                     }; 
                     return map; 
                 }, {});
                 restaurants = results.map(place => {
                     const placeDetails = detailsMap[place.place_id] || { photos: [], reviews: [], isNew: false };
                     const placePhotos = placeDetails.photos;
                     
                     // Improved photo URL extraction that handles both Google Maps photo objects and cached photo data
                     const photoUrls = [];
                     
                     // First try to get photos from placeDetails
                     if (placePhotos && placePhotos.length > 0) {
                         for (let i = 0; i < Math.min(5, placePhotos.length); i++) {
                             const photo = placePhotos[i];
                             if (photo.getUrl) {
                                 photoUrls.push(photo.getUrl({ maxWidth: 800, maxHeight: 600 }));
                             } else if (photo.url) {
                                 // Use the direct URL from cached photo
                                 photoUrls.push(photo.url);
                             }
                         }
                     }
                     
                     // If no photos from details, try to get photo from the place object directly (from nearby search cache)
                     if (photoUrls.length === 0 && place.photos && place.photos.length > 0) {
                         // Try to use direct_url from cached nearby search
                         if (place.photos[0].direct_url) {
                             photoUrls.push(place.photos[0].direct_url);
                         } 
                         // Or try using the Google Photos object if available
                         else if (typeof place.photos[0].getUrl === 'function') {
                             photoUrls.push(place.photos[0].getUrl({ maxWidth: 800, maxHeight: 600 }));
                         }
                     }
                     
                     // If still no photos, use placeholder
                     if (photoUrls.length === 0) {
                         photoUrls.push("https://placehold.co/800x600/FF5864/white?text=No+Image");
                     }
                     
                     let displayCuisine = searchKeyword ? searchKeyword.trim().toLowerCase().replace(/\b\w/g, l => l.toUpperCase()) : getCuisineFromTypes(place.types || []);
                     return { 
                         id: place.place_id, 
                         name: place.name || "Unnamed", 
                         address: place.vicinity || "Address unavailable", 
                         cuisine: displayCuisine, 
                         rating: place.rating ? `${place.rating}‚òÖ (${place.user_ratings_total || 0})` : "Not rated", 
                         ratingValue: place.rating || 0,
                         user_ratings_total: place.user_ratings_total || 0,
                         priceLevel: place.price_level ?? 0, 
                         photoUrls, 
                         currentPhotoIndex: 0,
                         reviews: placeDetails.reviews || [],
                         isNew: placeDetails.isNew || false,
                         // Store coordinates for travel time calculation
                         coordinates: place.geometry && place.geometry.location ? {
                             lat: place.geometry.location.lat(),
                             lng: place.geometry.location.lng()
                         } : null,
                         // Initialize travel times property
                         travelTimes: null
                     };
                 });
                 
                 // Removed filtering for high rating and popular places
                 
                 if (restaurants.length === 0) { showError('No food places found matching your criteria.'); showView(views.search); return; }
                 
                 // Always apply custom scoring and ranking
                     setLoadingText("Ranking and analyzing restaurants...");
                     try {
                         restaurants = await enhanceResultsWithLLM(restaurants, searchKeyword);
                         console.log("Restaurants ranked with custom scoring system");
                     } catch (error) {
                         console.error("Ranking failed:", error);
                         // Continue with normal results if ranking fails
                 }
                 
                 sessionId = generateSessionId(); saveSessionToFirebase();
                 currentIndex = 0; likedRestaurants = {};
                 updateRestaurantDisplay(); showView(views.swipe);
             } catch (error) { console.error("Error processing results:", error); showError("Error loading details."); showView(views.search); }
         }

        // Function to call the LLM service
        async function callLLMService(restaurantData, userPreferences) {
            // This function is now just a placeholder since we're using our own algorithm
            // We're keeping it to maintain the code structure
            return null;
        }

        // LLM-based restaurant enhancement and filtering
        async function enhanceResultsWithLLM(restaurants, searchKeyword) {
            // Prevent processing if no restaurants
            if (!restaurants || restaurants.length === 0) return restaurants;
            
            // Store original order to maintain info
            restaurants.forEach((r, index) => {
                r.originalIndex = index;
            });
            
            // Clone the array to avoid modifying the original directly
            let rankedRestaurants = [...restaurants];
            
            // Get the cuisine keyword for scoring
            const cuisineKeyword = cuisineKeywordInput.value.toLowerCase().trim();
            
            // Calculate scores based on the defined scoring system
            rankedRestaurants = rankedRestaurants.map(restaurant => {
                let score = 0;
                
                // 1. If the searched cuisine is found in the restaurant name, 15pts
                if (cuisineKeyword && restaurant.name.toLowerCase().includes(cuisineKeyword)) {
                    score += 15;
                }
                
                // 2. If the searched cuisine is found in the reviews, 15pts
                let cuisineInReviews = false;
                if (cuisineKeyword && restaurant.reviews && restaurant.reviews.length > 0) {
                    for (const review of restaurant.reviews) {
                        if (review.text && review.text.toLowerCase().includes(cuisineKeyword)) {
                            cuisineInReviews = true;
                            break;
                        }
                    }
                    if (cuisineInReviews) {
                        score += 15;
                    }
                }
                
                // 3. Ratings multiply by 4. (example 4 stars = 16pts)
                const rating = parseFloat(restaurant.ratingValue) || 0;
                score += rating * 4;
                
                // 4. Reviews below 100 = 5pts, 101 to 500 = 10pts, 501 and above = 15pts
                const reviewCount = restaurant.user_ratings_total || 0;
                if (reviewCount <= 100) {
                    score += 5;
                } else if (reviewCount <= 500) {
                    score += 10;
                } else {
                    score += 15;
                }
                
                // 5. Last 3 recent reviews added together
                if (restaurant.reviews && restaurant.reviews.length > 0) {
                    // Sort by time if available, newest first
                    const sortedReviews = [...restaurant.reviews].sort((a, b) => {
                        if (a.time && b.time) {
                            return b.time - a.time;
                        }
                        return 0;
                    });
                    
                    const recentReviews = sortedReviews.slice(0, 3);
                    let recentReviewScore = 0;
                    
                    for (const review of recentReviews) {
                        if (review.rating) {
                            recentReviewScore += review.rating;
                        }
                    }
                    
                    score += recentReviewScore;
                }
                
                // Add score to restaurant object
                restaurant.scoreDetails = {
                    cuisineInName: cuisineKeyword && restaurant.name.toLowerCase().includes(cuisineKeyword) ? 15 : 0,
                    cuisineInReviews: cuisineInReviews ? 15 : 0,
                    ratingScore: rating * 4,
                    reviewCountScore: reviewCount <= 100 ? 5 : (reviewCount <= 500 ? 10 : 15),
                    recentReviewsScore: restaurant.reviews ? 
                        restaurant.reviews.slice(0, 3).reduce((sum, review) => sum + (review.rating || 0), 0) : 0
                };
                restaurant.totalScore = score;
                
                return restaurant;
            });
            
            // Sort by total score, highest first
            rankedRestaurants.sort((a, b) => b.totalScore - a.totalScore);
            
            // Generate insights using OpenAI for each restaurant
            // Process in batches to avoid overwhelming the API
            const batchSize = 5; // Process 5 restaurants at a time
            const batches = Math.ceil(rankedRestaurants.length / batchSize);
            
            setLoadingText("Generating AI insights...");
            
            for (let i = 0; i < batches; i++) {
                const start = i * batchSize;
                const end = Math.min(start + batchSize, rankedRestaurants.length);
                const batch = rankedRestaurants.slice(start, end);
                
                // Update loading message to show progress
                setLoadingText(`Generating AI insights... (${Math.min(end, rankedRestaurants.length)}/${rankedRestaurants.length})`);
                
                // Process each restaurant in the batch concurrently
                await Promise.all(batch.map(async (restaurant) => {
                    try {
                        restaurant.llmInsights = await generateOpenAIInsights(restaurant, cuisineKeyword);
                    } catch (error) {
                        console.error("Error generating insights for restaurant:", restaurant.name, error);
                        restaurant.llmInsights = generateScoreInsights(restaurant, cuisineKeyword);
                    }
                }));
            }
            
            // Hide any error that might have shown earlier
            hideError();
            
            return rankedRestaurants;
        }

        // Function to generate insights based on score breakdown
        function generateScoreInsights(restaurant, cuisineKeyword) {
            const insightPoints = [];
            
            // Singapore-specific cuisine insights
            if (restaurant.scoreDetails.cuisineInName > 0) {
                if (cuisineKeyword.toLowerCase().includes('hawker')) {
                    insightPoints.push(`authentic hawker experience for ${cuisineKeyword}`);
                } else if (cuisineKeyword.toLowerCase().includes('laksa') || 
                          cuisineKeyword.toLowerCase().includes('chicken rice') || 
                          cuisineKeyword.toLowerCase().includes('chilli crab')) {
                    insightPoints.push(`known for authentic ${cuisineKeyword} - a local favorite`);
                } else {
                    insightPoints.push(`popular spot for ${cuisineKeyword} in Singapore`);
                }
            } else if (restaurant.scoreDetails.cuisineInReviews > 0) {
                insightPoints.push(`locals recommend the ${cuisineKeyword} here`);
            }
            
            // Singapore-specific rating insights
            if (restaurant.ratingValue >= 4.5) {
                insightPoints.push("shiok with top ratings among Singaporeans");
            } else if (restaurant.ratingValue >= 4.0) {
                insightPoints.push("can make it with good local ratings");
            } else if (restaurant.ratingValue >= 3.5) {
                insightPoints.push("not bad lah, decent reviews overall");
            }
            
            // Singapore-specific popularity insights
            if (restaurant.user_ratings_total > 500) {
                insightPoints.push("super crowded with both locals and tourists");
            } else if (restaurant.user_ratings_total > 100) {
                insightPoints.push("got quite a following among Singaporeans");
            }
            
            // Recent review insights with local flair
            if (restaurant.reviews && restaurant.reviews.length > 0) {
                const avgRecentRating = restaurant.scoreDetails.recentReviewsScore / Math.min(3, restaurant.reviews.length);
                if (avgRecentRating >= 4.5) {
                    insightPoints.push("wah, recent reviews all very good one");
                } else if (avgRecentRating >= 4.0) {
                    insightPoints.push("recent visitors say quite power lah");
                }
            }
            
            // Make sure we have at least one insight
            if (insightPoints.length === 0) {
                insightPoints.push("ranked based on local Singaporean preferences");
            }
            
            // Convert array of points to a single sentence
            // Take the top 2-3 insights and combine them
            const selectedPoints = insightPoints.slice(0, Math.min(3, insightPoints.length));
            
            if (selectedPoints.length === 1) {
                return [capitalizeFirstLetter(selectedPoints[0]) + "."];
            } else {
                return [capitalizeFirstLetter(selectedPoints.join(" and ")) + "."];
            }
        }

        // Using OpenAI to generate restaurant insights
        async function generateOpenAIInsights(restaurant, cuisineKeyword) {
            try {
                // Get API key from Firebase instead of hardcoding it
                const apiKey = await getOpenAIKeyFromFirebase();
                if (!apiKey) {
                    console.error("Could not retrieve OpenAI API key from Firebase");
                    return generateScoreInsights(restaurant, cuisineKeyword);
                }
                
                // Prepare the restaurant data to send to OpenAI
                const restaurantData = {
                    name: restaurant.name,
                    cuisine: cuisineKeyword || restaurant.cuisine,
                    rating: restaurant.ratingValue,
                    reviewCount: restaurant.user_ratings_total,
                    priceLevel: restaurant.priceLevel,
                    reviews: restaurant.reviews?.slice(0, 3).map(r => r.text).filter(Boolean) || []
                };
                
                // Construct a prompt for OpenAI
                const prompt = `You are a helpful Singaporean food blogger who loves recommending local food places. Write a short, enthusiastic recommendation for this restaurant using Singlish expressions and local Singapore phrases. Make it sound authentic like a local speaking, with phrases like "shiok", "can make it", "not bad lah", "die die must try", "wah so good", etc. Keep it under 35 words and make it personable.

Restaurant information:
Name: ${restaurantData.name}
Cuisine: ${restaurantData.cuisine}
Rating: ${restaurantData.rating} stars (from ${restaurantData.reviewCount} reviews)
Price Level: ${getPriceLevelText(restaurantData.priceLevel)}

${restaurantData.reviews.length > 0 ? 'Sample reviews:\n' + restaurantData.reviews.map(r => `- "${r}"`).join('\n') : 'No reviews available.'}

Your recommendation should sound like a real Singaporean friend giving authentic advice about why this place worth visiting. Use casual Singlish tone with local expressions.`;

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: "gpt-3.5-turbo",
                        messages: [
                            {
                                role: "system",
                                content: "You are a Singaporean food enthusiast who speaks in Singlish. Use local Singapore expressions and casual speaking style. Be authentic in how Singaporeans actually talk about food."
                            },
                            {
                                role: "user",
                                content: prompt
                            }
                        ],
                        max_tokens: 100
                    })
                });
                
                if (!response.ok) {
                    console.error("OpenAI API Error:", await response.text());
                    // Fallback to static insights if API call fails
                    return generateScoreInsights(restaurant, cuisineKeyword);
                }
                
                const data = await response.json();
                const aiInsight = data.choices[0].message.content.trim();
                console.log("OpenAI insight:", aiInsight);
                
                // Remove any quotes that OpenAI might have added
                const formattedInsight = aiInsight.replace(/^["'](.*)["']$/, '$1');
                
                // Track the API usage
                incrementAPIUsageCounter();
                
                return [formattedInsight];
            } catch (error) {
                console.error("Error generating OpenAI insights:", error);
                // Fallback to static insights if any error occurs
                return generateScoreInsights(restaurant, cuisineKeyword);
            }
        }

        // Retrieve OpenAI API key from Firebase
        async function getOpenAIKeyFromFirebase() {
            if (typeof firebase === 'undefined' || !firebase.apps.length) {
                console.error("Firebase not initialized for API key retrieval");
                return null;
            }
            
            try {
                // Path to the stored API key in Firebase
                const apiKeyRef = firebase.database().ref('apiKeys/openai');
                const snapshot = await apiKeyRef.once('value');
                
                if (snapshot.exists()) {
                    const apiKeyData = snapshot.val();
                    // Access the 'key' property of the stored object
                    return apiKeyData.key;
                } else {
                    console.error("OpenAI API key not found in Firebase");
                    return null;
                }
            } catch (error) {
                console.error("Error retrieving OpenAI API key from Firebase:", error);
                return null;
            }
        }
        
        // Helper function to get price level text
        function getPriceLevelText(priceLevel) {
            switch(priceLevel) {
                case 1: return "Inexpensive";
                case 2: return "Moderate";
                case 3: return "Expensive";
                case 4: return "Very Expensive";
                default: return "Unknown";
            }
        }
        
        // Track API usage
        function incrementAPIUsageCounter() {
            try {
                const today = new Date().toISOString().split('T')[0]; // Get date in YYYY-MM-DD format
                
                // Get existing data from localStorage
                const usageData = JSON.parse(localStorage.getItem('openaiApiUsage')) || {};
                
                // Increment today's count
                usageData[today] = (usageData[today] || 0) + 1;
                
                // Save back to localStorage
                localStorage.setItem('openaiApiUsage', JSON.stringify(usageData));
                
                console.log(`API call recorded for ${today}. Total calls today: ${usageData[today]}`);
                
                // Update the display
                updateAPIUsageDisplay();
            } catch (error) {
                console.error("Error tracking API usage:", error);
            }
        }
        
        // Function to get API usage statistics
        function getAPIUsageStats() {
            try {
                const usageData = JSON.parse(localStorage.getItem('openaiApiUsage')) || {};
                return usageData;
            } catch (error) {
                console.error("Error getting API usage stats:", error);
                return {};
            }
        }

        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function getCuisineFromTypes(types) { 
            const typeMap = {
                'cafe': 'Cafe',
                'bar': 'Bar',
                'bakery': 'Bakery',
                'food': 'Food Stall',
                'meal_takeaway': 'Takeaway',
                'meal_delivery': 'Delivery'
            }; 
            const knownCuisines = ["Italian", "Chinese", "Japanese", "Mexican", "Indian", "Thai", "American", "French", "Vietnamese", "Korean", "Mediterranean", "Pizza", "Sushi", "Seafood", "Steakhouse"]; 
            for(const type of types){ 
                const fmt = type.replace(/_/g,' ').replace(/\b\w/g,l=>l.toUpperCase()); 
                if(knownCuisines.includes(fmt)) return fmt; 
                if(typeMap[type]) return typeMap[type]; 
            } 
            return types.includes('restaurant') ? 'Restaurant' : (types.includes('cafe') ? 'Cafe' : 'Food Place'); 
        }
        function createGoogleMapsLink(restaurant) { 
            if (!restaurant) return null; 
            let url; 
            if (restaurant.id) { 
                url = `https://www.google.com/maps/search/?api=1&query=Google&query_place_id=${restaurant.id}`; 
            } else if (restaurant.name && restaurant.address) { 
                const query = encodeURIComponent(`${restaurant.name}, ${restaurant.address}`); 
                url = `https://www.google.com/maps/search/?api=1&query=${query}`; 
            } else { 
                return null; 
            } 
            const link = document.createElement('a'); 
            link.href = url; 
            link.textContent = "View on Google Maps ‚Üó"; 
            link.className = "google-maps-link"; 
            link.target = "_blank"; 
            link.rel = "noopener noreferrer"; 
            return link; 
        }

        // Updated function for creating a combined maps link + travel times row
        function createMapsAndTravelRow(restaurant) {
            // This function is no longer used - Maps link and travel times are now displayed below the image
            return document.createElement('div');
        }

        // --- Travel Time Functions ---
        async function getTravelTimes(origin, destination) {
            if (!origin || !destination || typeof google === 'undefined' || !google.maps?.DistanceMatrixService) {
                return { driving: null, transit: null };
            }
            
            // Generate a unique key for this origin-destination pair
            const originStr = `${origin.lat().toFixed(6)},${origin.lng().toFixed(6)}`;
            const destStr = `${destination.lat().toFixed(6)},${destination.lng().toFixed(6)}`;
            const cacheKey = `${originStr}|${destStr}`;
            
            // Check if we have server-cached travel times (preferred)
            const serverCachedTimes = await getServerCachedTravelTimes(cacheKey).catch(() => null);
            if (serverCachedTimes) {
                console.log('Using server-cached travel times');
                return serverCachedTimes;
            }
            
            // Check if we have cached travel times in local storage
            const cachedTimes = window.placesCache?.getCachedTravelTimes(cacheKey);
            if (cachedTimes) {
                console.log('Using locally cached travel times');
                // Also save to server cache for future use
                saveServerTravelTimes(cacheKey, cachedTimes).catch(console.error);
                return cachedTimes;
            }
            
            // If not in cache, calculate travel times
            const service = new google.maps.DistanceMatrixService();
            
            try {
                // First get driving time
                const drivingResult = await new Promise((resolve, reject) => {
                    service.getDistanceMatrix({
                        origins: [origin],
                        destinations: [destination],
                        travelMode: google.maps.TravelMode.DRIVING,
                        unitSystem: google.maps.UnitSystem.METRIC
                    }, (response, status) => {
                        if (status === 'OK') {
                            resolve(response);
                        } else {
                            console.error("Driving time calculation failed:", status);
                            resolve(null);
                        }
                    });
                });
                
                // Then get transit time
                const transitResult = await new Promise((resolve, reject) => {
                    service.getDistanceMatrix({
                        origins: [origin],
                        destinations: [destination],
                        travelMode: google.maps.TravelMode.TRANSIT,
                        unitSystem: google.maps.UnitSystem.METRIC
                    }, (response, status) => {
                        if (status === 'OK') {
                            resolve(response);
                        } else {
                            console.error("Transit time calculation failed:", status);
                            resolve(null);
                        }
                    });
                });
                
                // Process results
                const drivingTime = drivingResult && 
                                    drivingResult.rows[0]?.elements[0]?.status === "OK" ? 
                                    drivingResult.rows[0].elements[0].duration.text : null;
                                    
                const transitTime = transitResult && 
                                    transitResult.rows[0]?.elements[0]?.status === "OK" ? 
                                    transitResult.rows[0].elements[0].duration.text : null;
                
                const travelTimes = { driving: drivingTime, transit: transitTime };
                
                // Cache results in both local storage and server
                window.placesCache?.cacheTravelTimes(cacheKey, travelTimes);
                saveServerTravelTimes(cacheKey, travelTimes).catch(console.error);
                
                return travelTimes;
            } catch (error) {
                console.error("Error calculating travel times:", error);
                return { driving: null, transit: null };
            }
        }
        
        // Creates travel time elements for a restaurant
        function createTravelTimeElements(restaurant) {
            const container = document.createElement('div');
            container.className = 'travel-times';
            
            // Check if we've already calculated travel times for this restaurant
            if (restaurant.travelTimes) {
                console.log(`Using cached travel times for ${restaurant.name}`);
                // Use cached travel times
                displayTravelTimes(restaurant.travelTimes, container);
                return container;
            }
            
            if (!userCoordinates || !restaurant.coordinates) {
                return container; // Return empty container if no coordinates
            }
            
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'travel-time-loading';
            loadingDiv.textContent = 'Calculating travel times...';
            container.appendChild(loadingDiv);
            
            console.log(`Calculating new travel times for ${restaurant.name}`);
            
            // Start async calculation of travel times
            const origin = new google.maps.LatLng(userCoordinates.lat, userCoordinates.lng);
            const destination = new google.maps.LatLng(
                restaurant.coordinates.lat, 
                restaurant.coordinates.lng
            );
            
            getTravelTimes(origin, destination).then(times => {
                // Store the calculated times with the restaurant
                restaurant.travelTimes = times;
                console.log(`Travel times calculated and stored for ${restaurant.name}`);
                
                // Remove loading message
                container.removeChild(loadingDiv);
                
                // Display the travel times
                displayTravelTimes(times, container);
            }).catch(error => {
                console.error(`Travel time display error for ${restaurant.name}:`, error);
                loadingDiv.textContent = 'Unable to calculate travel times';
            });
            
            return container;
        }
        
        // Helper function to display travel times in a container
        function displayTravelTimes(times, container) {
            // Add driving time if available
            if (times.driving) {
                const drivingItem = document.createElement('div');
                drivingItem.className = 'travel-time-item';
                drivingItem.innerHTML = `<span class="travel-time-icon">üöó</span> ${times.driving}`;
                container.appendChild(drivingItem);
            }
            
            // Add transit time if available
            if (times.transit) {
                const transitItem = document.createElement('div');
                transitItem.className = 'travel-time-item';
                transitItem.innerHTML = `<span class="travel-time-icon">üöá</span> ${times.transit}`;
                container.appendChild(transitItem);
            }
            
            // If no times available, show message
            if (!times.driving && !times.transit) {
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'travel-time-item';
                noDataDiv.textContent = 'Travel time information unavailable';
                container.appendChild(noDataDiv);
            }
        }

        // --- Swipe UI Functions ---
        function updateRestaurantDisplay() {
            if (!restaurants || restaurants.length === 0 || currentIndex >= restaurants.length) {
                console.warn("No restaurants to display");
                return;
            }
            
            const restaurant = restaurants[currentIndex];
            
            // Update indexes
            swipeUI.currentIndex.textContent = currentIndex + 1;
            swipeUI.totalRestaurants.textContent = restaurants.length;
            
            // Update image
            swipeUI.image.src = restaurant.photoUrls[restaurant.currentPhotoIndex || 0];
            
            // Update photo indicators
            updatePhotoIndicators(restaurant);
            
            // Update restaurant information
            swipeUI.name.textContent = restaurant.name;
            swipeUI.rating.innerHTML = `<span class="meta-icon">‚≠ê</span> ${restaurant.rating}`;
            swipeUI.price.innerHTML = `<span class="meta-icon">üí∞</span> ${restaurant.priceLevel > 0 ? '$'.repeat(restaurant.priceLevel) : 'N/A'}`;
            swipeUI.address.innerHTML = `<span class="meta-icon">üìç</span> <a href="${restaurant.id ? 
                `https://www.google.com/maps/search/?api=1&query=Google&query_place_id=${restaurant.id}` : 
                `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(restaurant.name + ' ' + restaurant.address)}`
            }" target="_blank" rel="noopener noreferrer" class="address-link">${restaurant.address}</a>`;
            
            // Update travel times if user coordinates are available
            if (userCoordinates && restaurant.coordinates) {
                const travelTimesContainer = document.getElementById('travel-times');
                if (travelTimesContainer) {
                    travelTimesContainer.innerHTML = '';
                    
                    // Show travel times if available
                    if (restaurant.travelTimes) {
                        if (restaurant.travelTimes.driving) {
                            const drivingBadge = document.createElement('span');
                            drivingBadge.className = 'travel-time-badge';
                            drivingBadge.innerHTML = `<span class="travel-time-icon">üöó</span> ${restaurant.travelTimes.driving}`;
                            travelTimesContainer.appendChild(drivingBadge);
                        }
                        
                        if (restaurant.travelTimes.transit) {
                            const transitBadge = document.createElement('span');
                            transitBadge.className = 'travel-time-badge';
                            transitBadge.innerHTML = `<span class="travel-time-icon">üöá</span> ${restaurant.travelTimes.transit}`;
                            travelTimesContainer.appendChild(transitBadge);
                        }
                    } else {
                        // If no travel times yet, calculate them
                        const origin = new google.maps.LatLng(userCoordinates.lat, userCoordinates.lng);
                        const destination = new google.maps.LatLng(
                            restaurant.coordinates.lat, restaurant.coordinates.lng
                        );
                        
                        // Show calculating indicator
                        const calculatingBadge = document.createElement('span');
                        calculatingBadge.className = 'travel-time-badge calculating';
                        calculatingBadge.innerHTML = 'Calculating...';
                        travelTimesContainer.appendChild(calculatingBadge);
                        
                        // Get travel times asynchronously
                        getTravelTimes(origin, destination).then(times => {
                            // Store for future use
                            restaurant.travelTimes = times;
                            
                            // Update display
                            travelTimesContainer.innerHTML = '';
                            
                            if (times.driving) {
                                const drivingBadge = document.createElement('span');
                                drivingBadge.className = 'travel-time-badge';
                                drivingBadge.innerHTML = `<span class="travel-time-icon">üöó</span> ${times.driving}`;
                                travelTimesContainer.appendChild(drivingBadge);
                            }
                            
                            if (times.transit) {
                                const transitBadge = document.createElement('span');
                                transitBadge.className = 'travel-time-badge';
                                transitBadge.innerHTML = `<span class="travel-time-icon">üöá</span> ${times.transit}`;
                                travelTimesContainer.appendChild(transitBadge);
                            }
                        });
                    }
                }
            }
            
            // Display LLM insights if available
            const reviewsContainer = document.getElementById('restaurant-reviews');
            if (reviewsContainer) {
                // Clear existing reviews
                reviewsContainer.innerHTML = '<div class="reviews-title">Reviews</div>';
                
                // Add LLM insights if available
                if (restaurant.llmInsights && restaurant.llmInsights.length > 0) {
                    const insightsContainer = document.createElement('div');
                    insightsContainer.className = 'llm-insights';
                    
                    // Update the title to "Local AI thinks..."
                    const insightsTitle = document.createElement('div');
                    insightsTitle.className = 'llm-insights-title';
                    insightsTitle.innerHTML = 'Your Singaporean Friend Says:';
                    
                    insightsContainer.appendChild(insightsTitle);
                    
                    // Show the insights as a paragraph instead of bullet points
                    const insightParagraph = document.createElement('div');
                    insightParagraph.className = 'llm-insight-paragraph';
                    insightParagraph.textContent = restaurant.llmInsights[0];
                    insightsContainer.appendChild(insightParagraph);
                    
                    reviewsContainer.appendChild(insightsContainer);
                }
                
                // Add reviews if available
                if (restaurant.reviews && restaurant.reviews.length > 0) {
                    restaurant.reviews.forEach(review => {
                        const reviewEl = document.createElement('div');
                        reviewEl.className = 'review-item';
                        
                        // Format date
                        let dateText = 'Unknown date';
                        if (review.time) {
                            const reviewDate = new Date(review.time * 1000);
                            dateText = reviewDate.toLocaleDateString();
                        }
                        
                        // Add review header
                        const reviewHeader = document.createElement('div');
                        reviewHeader.className = 'review-author';
                        reviewHeader.innerHTML = `
                            <div><strong>${review.author_name || 'Anonymous'}</strong></div>
                            <div><span class="review-star">${review.rating}‚òÖ</span> <span class="review-date">${dateText}</span></div>
                        `;
                        
                        // Add review text
                        const reviewText = document.createElement('div');
                        reviewText.className = 'review-text';
                        
                        // Handle long reviews
                        const fullText = review.text || 'No review text';
                        const isTruncated = fullText.length > 150;
                        
                        if (isTruncated) {
                            reviewText.className = 'review-text truncated';
                            reviewText.setAttribute('data-full-text', fullText);
                            reviewText.textContent = fullText.substring(0, 150) + '...';
                            
                            reviewText.addEventListener('click', function() {
                                if (this.classList.contains('truncated')) {
                                    this.textContent = this.getAttribute('data-full-text');
                                    this.classList.remove('truncated');
                                    this.classList.add('expanded');
                                } else {
                                    this.textContent = this.getAttribute('data-full-text').substring(0, 150) + '...';
                                    this.classList.remove('expanded');
                                    this.classList.add('truncated');
                                }
                            });
                        } else {
                            reviewText.textContent = fullText;
                        }
                        
                        // Add all elements to the review container
                        reviewEl.appendChild(reviewHeader);
                        reviewEl.appendChild(reviewText);
                        reviewsContainer.appendChild(reviewEl);
                    });
                } else {
                    // No reviews message
                    const noReviewsMsg = document.createElement('div');
                    noReviewsMsg.className = 'review-item';
                    noReviewsMsg.textContent = 'No reviews available for this restaurant.';
                    reviewsContainer.appendChild(noReviewsMsg);
                }
            }
            
            // Update 'NEW' badge if applicable
            const newBadge = restaurant.isNew;
            if (newBadge) {
                const existingSticker = document.querySelector('.new-sticker');
                if (!existingSticker) {
                    const newSticker = document.createElement('div');
                    newSticker.className = 'new-sticker';
                    newSticker.textContent = 'NEW';
                    const photoContainer = document.querySelector('.photo-container');
                    if (photoContainer) {
                        photoContainer.appendChild(newSticker);
                    }
                }
            } else {
                const existingSticker = document.querySelector('.new-sticker');
                if (existingSticker) {
                    existingSticker.remove();
                }
            }
            
            // Reset any swipe state
            resetSwipeState();
        }
        function changePhoto(direction) { if (currentIndex >= restaurants.length) return; const r=restaurants[currentIndex]; const num=r.photoUrls.length; if(num<=1)return; r.currentPhotoIndex=(r.currentPhotoIndex+direction+num)%num; updateRestaurantDisplay(); }
        function handleSwipe(liked) {
            if (currentIndex >= restaurants.length) return;
            const restaurantId = restaurants[currentIndex].id;
            if (liked) { 
                likedRestaurants[restaurantId] = true; 
                console.log("Liked:", restaurants[currentIndex].name);
                // Save likes immediately after liking
                saveLikesToFirebase();
            } else { 
                console.log("Disliked:", restaurants[currentIndex].name); 
            }
            currentIndex++;
            if (currentIndex < restaurants.length) { 
                updateRestaurantDisplay(); 
            } else { 
                showResultsView(); 
            }
        }

        // --- Results & Matching Functions ---
        function showResultsView() {
            const likedCount = Object.keys(likedRestaurants).length;
            resultsUI.likedCount.textContent = likedCount;
            resultsUI.sessionId.textContent = sessionId;
            resultsUI.friendCodeInput.value = '';
            populateLikedRestaurantsList();
            resultsUI.likedListContainer.classList.add('hidden');
            resultsUI.viewLikedButton.textContent = 'View My Liked Food Places';
            resultsUI.viewLikedButton.style.display = likedCount > 0 ? 'block' : 'none';
            generateShareLink();
            resultsUI.shareLinkSection.style.display = likedCount > 0 ? 'block' : 'none';
            showView(views.results);
        }
        function populateLikedRestaurantsList() {
            const likedListContainer = resultsUI.likedListContainer;
            likedListContainer.innerHTML = '';
            const myLikedIds = Object.keys(likedRestaurants);
            const likedRestaurantDetails = restaurants.filter(r => myLikedIds.includes(r.id));
            
            if (likedRestaurantDetails.length > 0) {
                // Add a header for the liked list
                const listHeader = document.createElement('div');
                listHeader.className = 'card';
                listHeader.style.marginBottom = '15px';
                
                const listHeaderContent = document.createElement('div');
                listHeaderContent.className = 'card-header';
                listHeaderContent.innerHTML = `<h3>Your Liked Food Places</h3>`;
                
                listHeader.appendChild(listHeaderContent);
                likedListContainer.appendChild(listHeader);
                
                // Add each restaurant item
                likedRestaurantDetails.forEach(r => { 
                    createRestaurantItemElement(r, likedListContainer); 
                });
            } else { 
                const emptyCard = document.createElement('div');
                emptyCard.className = 'card';
                emptyCard.innerHTML = '<div class="card-body"><p style="text-align:center; padding:20px;">You haven\'t liked any food places yet.</p></div>';
                likedListContainer.appendChild(emptyCard);
            }
        }
        function findMatches() {
            const friendCode = resultsUI.friendCodeInput.value.trim().toUpperCase();
            if (!friendCode) { showError('Please enter your friend\'s code.'); return; }
            if (friendCode === sessionId) { showError('You cannot match with your own code!'); return; }
            setLoadingText("Finding matches..."); // Update loading text
            showView(views.loading); hideError();
            if (typeof firebase === 'undefined' || !firebase.apps.length) { console.warn("Firebase not init."); showError("Matching unavailable."); setTimeout(() => { displayMatches([]); showView(views.matches); }, 1500); return; }
            firebase.database().ref('sessions/' + friendCode).once('value').then(snap => {
                const friendData = snap.val();
                if (!friendData) { showError(`Friend code "${friendCode}" not found.`); showView(views.results); return; }
                const friendLikes=friendData.likes||{}; const friendLikedIds=Object.keys(friendLikes); const myLikedIds=Object.keys(likedRestaurants);
                const matchedIds=myLikedIds.filter(id=>friendLikedIds.includes(id));
                const friendRestaurantsData=friendData.restaurants||[]; const friendMap=friendRestaurantsData.reduce((map,r)=>{map[r.id]=r;return map;},{});
                const myMap=restaurants.reduce((map,r)=>{map[r.id]=r;return map;},{}); // Use current session data as fallback
                const matchedRestaurants=matchedIds.map(id=>friendMap[id]||myMap[id]).filter(r=>r); // Get details, ensuring photos are available from friendMap
                console.log("Matches found:", matchedRestaurants); displayMatches(matchedRestaurants);
            }).catch(err => { console.error("Match error:", err); showError('Could not get friend data.'); showView(views.results); });
        }
        function displayMatches(matchedRestaurants) {
            const matchesListContainer = matchesUI.list;
            matchesListContainer.innerHTML = '';
            if (matchedRestaurants.length > 0) {
                matchedRestaurants.forEach(r => { createRestaurantItemElement(r, matchesListContainer); });
            } else { matchesListContainer.innerHTML = '<p style="text-align:center; padding:20px;">No common matches found!</p>'; }
            showView(views.matches);
        }
        function createRestaurantItemElement(r, container) {
            const item = document.createElement('div');
            item.className = 'restaurant-item';
            
            // Get image URL
            const imageUrl = (r.photoUrls && r.photoUrls.length > 0) ? 
                r.photoUrls[0] : "https://placehold.co/160x160/f0f0f0/999?text=No+Image";
                
            // Create price display
            const priceDisplay = r.priceLevel > 0 ? '$'.repeat(r.priceLevel) : 'N/A';
            
            // Create image container with actions below
            const imageContainer = document.createElement('div');
            imageContainer.className = 'restaurant-item-image-container';
            
            const itemImage = document.createElement('img');
            itemImage.src = imageUrl;
            itemImage.alt = r.name;
            itemImage.className = 'restaurant-item-image';
            
            // Create actions container below image
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'restaurant-item-actions';
            
            // Remove the Google Maps icon link
            // const mapsLink = document.createElement('a');
            // mapsLink.href = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(r.name + ' ' + (r.address || ''))}`;
            // mapsLink.className = 'map-icon';
            // mapsLink.innerHTML = 'üó∫Ô∏è';
            // mapsLink.target = '_blank';
            // mapsLink.rel = 'noopener noreferrer';
            // mapsLink.title = 'View on Google Maps';
            // 
            // actionsDiv.appendChild(mapsLink);
            
            // Add travel times below image if available
            if (r.travelTimes) {
                const travelTimesDiv = document.createElement('div');
                travelTimesDiv.className = 'travel-times-below';
                
                if (r.travelTimes.driving) {
                    const drivingTime = document.createElement('span');
                    drivingTime.className = 'travel-time-badge';
                    drivingTime.innerHTML = `üöó ${r.travelTimes.driving}`;
                    travelTimesDiv.appendChild(drivingTime);
                }
                
                if (r.travelTimes.transit) {
                    const transitTime = document.createElement('span');
                    transitTime.className = 'travel-time-badge';
                    transitTime.innerHTML = `üöá ${r.travelTimes.transit}`;
                    travelTimesDiv.appendChild(transitTime);
                }
                
                if (travelTimesDiv.childNodes.length > 0) {
                    actionsDiv.appendChild(travelTimesDiv);
                }
            }
            
            // Add image and actions to container
            imageContainer.appendChild(itemImage);
            imageContainer.appendChild(actionsDiv);
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'restaurant-item-content';
            
            // Create title and basic info
            const nameElement = document.createElement('h3');
            nameElement.textContent = r.name;
            
            const metaRow = document.createElement('div');
            metaRow.className = 'meta-row';
            
            // Add rating and price
            metaRow.innerHTML = `
                <div class="meta-item"><span class="meta-icon">‚≠ê</span> ${r.rating}</div>
                <div class="meta-item price-level"><span class="meta-icon">üí∞</span> ${priceDisplay}</div>
            `;
            
            // Create address
            const addressElement = document.createElement('p');
            addressElement.innerHTML = `<span class="meta-icon">üìç</span> <a href="${r.id ? 
                `https://www.google.com/maps/search/?api=1&query=Google&query_place_id=${r.id}` : 
                `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(r.name + ' ' + r.address)}`
            }" target="_blank" rel="noopener noreferrer" class="address-link">${r.address}</a>`;
            
            // Add elements to content div
            contentDiv.appendChild(nameElement);
            contentDiv.appendChild(metaRow);
            contentDiv.appendChild(addressElement);
            
            // Add LLM insights if available (compact version)
            if (r.llmInsights && r.llmInsights.length > 0) {
                const insightsElement = document.createElement('div');
                insightsElement.className = 'llm-insights-compact';
                
                // Update the text to include "Local AI thinks"
                const insightText = document.createElement('p');
                insightText.innerHTML = `Your Singaporean Friend Says: ${r.llmInsights[0]}`;
                insightText.className = 'llm-insight-paragraph';
                insightsElement.appendChild(insightText);
                
                // Remove multiple insight badges - we now only have one insight
                
                contentDiv.appendChild(insightsElement);
            }
            
            // Add a review if available - now full width
            if (r.reviews && r.reviews.length > 0) {
                const review = r.reviews[0]; // Use most relevant review
                
                const reviewDiv = document.createElement('div');
                reviewDiv.className = 'review-item';
                reviewDiv.style.marginTop = '8px';
                
                // Format date
                let dateText = 'Unknown date';
                if (review.time) {
                    const reviewDate = new Date(review.time * 1000);
                    dateText = reviewDate.toLocaleDateString();
                }
                
                // Create review header
                const reviewHeader = document.createElement('div');
                reviewHeader.className = 'review-author';
                reviewHeader.innerHTML = `
                    <div><strong>${review.author_name || 'Anonymous'}</strong></div>
                    <div><span class="review-star">${review.rating}‚òÖ</span> <span class="review-date">${dateText}</span></div>
                `;
                
                // Create review text
                const reviewText = document.createElement('div');
                reviewText.className = 'review-text';
                
                // Handle long reviews
                const fullText = review.text || 'No review text';
                const isTruncated = fullText.length > 150;
                
                if (isTruncated) {
                    reviewText.className = 'review-text truncated';
                    reviewText.setAttribute('data-full-text', fullText);
                    reviewText.textContent = fullText.substring(0, 150) + '...';
                    
                    reviewText.addEventListener('click', function() {
                        if (this.classList.contains('truncated')) {
                            this.textContent = this.getAttribute('data-full-text');
                            this.classList.remove('truncated');
                            this.classList.add('expanded');
                        } else {
                            this.textContent = this.getAttribute('data-full-text').substring(0, 150) + '...';
                            this.classList.remove('expanded');
                            this.classList.add('truncated');
                        }
                    });
                } else {
                    reviewText.textContent = fullText;
                }
                
                reviewDiv.appendChild(reviewHeader);
                reviewDiv.appendChild(reviewText);
                contentDiv.appendChild(reviewDiv);
            }
            
            // Create NEW badge if applicable
            if (r.isNew) {
                const newSticker = document.createElement('div');
                newSticker.className = 'new-sticker';
                newSticker.textContent = 'NEW';
                newSticker.style.top = '0';
                newSticker.style.right = '0';
                newSticker.style.fontSize = '10px';
                newSticker.style.padding = '3px 6px';
                
                // Position the new sticker on the image
                itemImage.style.position = 'relative';
                imageContainer.style.position = 'relative';
                imageContainer.appendChild(newSticker);
            }
            
            // Add elements to container
            item.appendChild(imageContainer);
            item.appendChild(contentDiv);
            container.appendChild(item);
        }

        // --- Sharing Functions ---
        function generateShareLink() {
            if (!sessionId) { 
                resultsUI.shareLinkInput.value = 'Error: No session ID.'; 
                resultsUI.copyLinkButton.disabled = true; 
                return; 
            }
            
            // Get the base URL, handling both http and https
            const baseUrl = window.location.href.split('?')[0];  // Remove any existing query params
            const shareUrl = `${baseUrl}?share=${sessionId}`;
            
            resultsUI.shareLinkInput.value = shareUrl;
            resultsUI.copyLinkButton.disabled = false;
        }
        function copyShareLink() {
            const link = resultsUI.shareLinkInput.value; if (!link || !navigator.clipboard) { showError("Cannot copy link. Try selecting manually."); return; }
            navigator.clipboard.writeText(link).then(() => { const originalText = resultsUI.copyLinkButton.textContent; resultsUI.copyLinkButton.textContent = '‚úÖ'; setTimeout(() => { resultsUI.copyLinkButton.textContent = 'üìã'; }, 1500); }).catch(err => { console.error('Failed to copy share link:', err); showError("Failed to copy link automatically."); });
        }
        async function handleSharedLink(sharedSessionId) {
            console.log("Handling shared link for session:", sharedSessionId);
            setLoadingText("Loading shared list...");
            showView(views.loading);
            hideError();
            
            if (typeof firebase === 'undefined' || !firebase.apps.length) {
                console.error("Firebase not initialized yet");
                showError("Cannot load shared list: Connection error.");
                sharedUI.list.innerHTML = '<p class="error-message">Cannot load shared list: Connection error.</p>';
                showView(views.shared);
                return;
            }
            
            try {
                console.log("Attempting to fetch session data from Firebase...");
                const sessionData = await fetchSharedSessionData(sharedSessionId);
                console.log("Received session data:", sessionData);
                
                if (!sessionData) {
                    console.error("No session data found for ID:", sharedSessionId);
                    showError(`Shared list "${sharedSessionId}" not found or has expired.`);
                    sharedUI.list.innerHTML = `<p class="error-message">Shared list "${sharedSessionId}" not found or has expired.</p>`;
                    showView(views.shared);
                    return;
                }
                
                const sharedLikes = sessionData.likes || {};
                const sharedLikedIds = Object.keys(sharedLikes).filter(id => sharedLikes[id] === true);  // Only include true values
                const sharedRestaurants = sessionData.restaurants || [];
                
                console.log("Shared likes:", sharedLikedIds.length, "restaurants:", sharedRestaurants.length);
                
                if (sharedLikedIds.length === 0) {
                    console.log("No liked restaurants found in session");
                    sharedUI.list.innerHTML = '<p style="text-align:center; padding:20px;">This shared list is empty.</p>';
                    showView(views.shared);
                    return;
                }
                
                const likedRestaurantDetails = sharedRestaurants.filter(r => sharedLikedIds.includes(r.id));
                console.log("Filtered liked restaurants:", likedRestaurantDetails.length);
                
                if (likedRestaurantDetails.length > 0) {
                    displaySharedRestaurants(likedRestaurantDetails);
                } else {
                    sharedUI.list.innerHTML = '<p style="text-align:center; padding:20px;">This shared list is empty.</p>';
                    showView(views.shared);
                }
            } catch (error) {
                console.error("Error fetching shared session:", error);
                showError("Could not load the shared list.");
                sharedUI.list.innerHTML = `<p class="error-message">Could not load the shared list.</p>`;
                showView(views.shared);
            }
        }
        
        function fetchSharedSessionData(sessionIdToFetch) { if (!sessionIdToFetch) return Promise.resolve(null); return firebase.database().ref('sessions/' + sessionIdToFetch).once('value').then(snapshot => snapshot.val()); }
        function displaySharedRestaurants(sharedRestaurantList) {
            const container = sharedUI.list; container.innerHTML = '';
            if (sharedRestaurantList.length > 0) { sharedRestaurantList.forEach(r => { createRestaurantItemElement(r, container); }); }
            else { container.innerHTML = '<p style="text-align:center; padding:20px;">This shared list is empty or could not be loaded.</p>'; }
            sharedUI.sourceText.textContent = `Viewing a shared list`; showView(views.shared);
        }

        // --- Firebase Integration ---
        function generateSessionId() { return Math.random().toString(36).substring(2, 10).toUpperCase(); }
        function saveSessionToFirebase() {
            if(typeof firebase==='undefined'||!firebase.apps.length||!sessionId)return;
            const restaurantsToSave = restaurants.map(r => {
                // Create a clean object with no undefined values
                let cleanCoordinates = null;
                if (r.coordinates) {
                    const lat = typeof r.coordinates.lat === 'function' ? r.coordinates.lat() : r.coordinates.lat;
                    const lng = typeof r.coordinates.lng === 'function' ? r.coordinates.lng() : r.coordinates.lng;
                    
                    // Only set coordinates if both values are valid numbers
                    if (lat !== undefined && lng !== undefined && !isNaN(lat) && !isNaN(lng)) {
                        cleanCoordinates = { lat, lng };
                    }
                }
                
                return { 
                    id: r.id, 
                    name: r.name, 
                    address: r.address, 
                    cuisine: r.cuisine, 
                    rating: r.rating, 
                    priceLevel: r.priceLevel, 
                    photoUrls: (r.photoUrls && r.photoUrls.length > 0) ? [r.photoUrls[0]] : [],
                    reviews: r.reviews || [],
                    isNew: r.isNew || false,
                    coordinates: cleanCoordinates,
                    travelTimes: r.travelTimes || null
                };
            });
            const sessionData = { 
                restaurants: restaurantsToSave, 
                timestamp: firebase.database.ServerValue.TIMESTAMP, 
                likes: likedRestaurants  // Include current likes in initial save
            };
            firebase.database().ref('sessions/'+sessionId).set(sessionData)
                .then(() => {
                    console.log("Session saved with likes:", Object.keys(likedRestaurants).length);
                })
                .catch(e => console.error("Session save error:",e));
        }
        function saveLikesToFirebase() {
            if(typeof firebase==='undefined'||!firebase.apps.length||!sessionId)return;
            firebase.database().ref('sessions/'+sessionId+'/likes').set(likedRestaurants).then(() => console.log("Likes updated for:", sessionId)).catch(e=>console.error("Likes update error:",e));
        }
        function initializeFirebase() {
            console.log("Attempting to initialize Firebase...");
            if (typeof firebase === 'undefined' || typeof firebase.initializeApp === 'undefined') {
                console.error("Firebase SDK not ready");
                return;
            }
            
            try {
                const cfg = {
                    apiKey: "AIzaSyDauSN6vXVeflYHYdx54hIsXWeTxp-CarM",
                    authDomain: "restaurant-finder-36e61.firebaseapp.com",
                    databaseURL: "https://restaurant-finder-36e61-default-rtdb.asia-southeast1.firebasedatabase.app",
                    projectId: "restaurant-finder-36e61",
                    storageBucket: "restaurant-finder-36e61.appspot.com",
                    messagingSenderId: "266887715200",
                    appId: "1:266887715200:web:6c68d924d7596cdfb44965",
                    measurementId: "G-TD5GNXZZMN"
                };
                
                if (!firebase.apps.length) {
                    firebase.initializeApp(cfg);
                    console.log("Firebase successfully initialized");
                    
                    // Set up security for API keys access if we're on the admin page
                    setupAPIKeySecurity();
                    
                    // Test the connection
                    firebase.database().ref('.info/connected').on('value', (snap) => {
                        if (snap.val() === true) {
                            console.log("Connected to Firebase");
                            // Initialize server cache cleanup
                            checkAndCleanServerCache();
                        } else {
                            console.log("Not connected to Firebase");
                        }
                    });
                } else {
                    console.log("Firebase was already initialized");
                    // Initialize server cache cleanup
                    checkAndCleanServerCache();
                }
            } catch (e) {
                console.error("Firebase initialization error:", e);
                showError("Sharing unavailable.");
                resultsUI.findMatchesButton.disabled = true;
                resultsUI.copyCodeButton.disabled = true;
                resultsUI.copyLinkButton.disabled = true;
            }
        }
        
        // Set up security for API keys access
        function setupAPIKeySecurity() {
            // Only call this if you're on an admin page or during development
            // In production, you would set these rules via Firebase Console
            
            // This function is just to document what security rules should be
            // implemented in your Firebase Realtime Database Rules:
            
            /*
            {
              "rules": {
                "apiKeys": {
                  // Only authenticated users with admin role can write
                  ".write": "auth != null && auth.token.admin === true",
                  
                  // Only the app's domain can read the keys
                  ".read": "auth != null || 
                            (request.auth == null && 
                             (request.origin == 'https://yourdomain.com' || 
                              request.origin == null))"
                },
                // Other rules for your database...
              }
            }
            */
        }
        
        // Check if the OpenAI API key is available and valid
        async function checkOpenAIAPIKey() {
            try {
                const apiKey = await getOpenAIKeyFromFirebase();
                if (!apiKey) {
                    console.warn("OpenAI API key not found in Firebase");
                    return false;
                }
                
                // Optional: Make a minimal API call to verify the key works
                const response = await fetch('https://api.openai.com/v1/models', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });
                
                if (response.ok) {
                    console.log("OpenAI API key validated successfully");
                    return true;
                } else {
                    console.error("OpenAI API key validation failed:", await response.text());
                    return false;
                }
            } catch (error) {
                console.error("Error validating OpenAI API key:", error);
                return false;
            }
        }

        // --- Server-Side Cache Implementation ---
        
        // Firebase cache paths
        const CACHE_PATHS = {
            NEARBY_SEARCH: 'googleApiCache/nearbySearch',
            PLACE_DETAILS: 'googleApiCache/placeDetails',
            TRAVEL_TIMES: 'googleApiCache/travelTimes',
            METADATA: 'googleApiCache/metadata'
        };
        
        // One month in milliseconds (30 days)
        const ONE_MONTH_MS = 30 * 24 * 60 * 60 * 1000;
        
        // Create a hash for cache keys to avoid invalid Firebase path characters
        function createCacheHash(str) {
            // Simple hash function that works for our purpose
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            // Make positive and convert to base 36 (alphanumeric) with a prefix
            return 'h' + Math.abs(hash).toString(36);
        }
        
        // Check server cache and clean expired entries
        function checkAndCleanServerCache() {
            if (typeof firebase === 'undefined' || !firebase.apps.length) return;
            
            // Get the current timestamp
            const now = Date.now();
            
            // First check when the last cleanup occurred
            firebase.database().ref(CACHE_PATHS.METADATA + '/lastCleanup').once('value')
                .then(snapshot => {
                    const lastCleanup = snapshot.val() || 0;
                    
                    // Only clean once a day (24 hours)
                    if (now - lastCleanup < 24 * 60 * 60 * 1000) {
                        console.log('Server cache was cleaned within the last 24 hours, skipping cleanup');
                        return;
                    }
                    
                    console.log('Checking server cache for expired entries...');
                    
                    // Update last cleanup time immediately to prevent concurrent cleanups
                    firebase.database().ref(CACHE_PATHS.METADATA + '/lastCleanup').set(now);
                    
                    // Clean each cache type
                    cleanCacheEntries(CACHE_PATHS.NEARBY_SEARCH);
                    cleanCacheEntries(CACHE_PATHS.PLACE_DETAILS);
                    cleanCacheEntries(CACHE_PATHS.TRAVEL_TIMES);
                })
                .catch(error => {
                    console.error('Error checking server cache metadata:', error);
                });
        }
        
        // Clean expired entries from a specific cache path
        function cleanCacheEntries(cachePath) {
            if (typeof firebase === 'undefined' || !firebase.apps.length) return;
            
            const now = Date.now();
            const expireTime = now - ONE_MONTH_MS;
            
            // Query for expired entries
            firebase.database().ref(cachePath).once('value')
                .then(snapshot => {
                    if (!snapshot.exists()) return;
                    
                    const updates = {};
                    let expiredCount = 0;
                    
                    snapshot.forEach(child => {
                        const entry = child.val();
                        if (entry && entry.timestamp && entry.timestamp < expireTime) {
                            // Mark this entry for deletion
                            updates[child.key] = null;
                            expiredCount++;
                        }
                    });
                    
                    // If we have entries to delete, do it in one batch operation
                    if (expiredCount > 0) {
                        console.log(`Removing ${expiredCount} expired entries from ${cachePath}`);
                        return firebase.database().ref(cachePath).update(updates);
                    }
                })
                .then(() => {
                    console.log(`Finished cleaning ${cachePath}`);
                })
                .catch(error => {
                    console.error(`Error cleaning expired entries from ${cachePath}:`, error);
                });
        }
        
        // Check server cache for near search results
        async function getServerCachedNearbySearch(searchKey) {
            if (typeof firebase === 'undefined' || !firebase.apps.length) return null;
            
            try {
                const hashKey = createCacheHash(searchKey);
                const snapshot = await firebase.database().ref(`${CACHE_PATHS.NEARBY_SEARCH}/${hashKey}`).once('value');
                
                if (snapshot.exists()) {
                    const cachedData = snapshot.val();
                    const now = Date.now();
                    
                    // Check if cache is still valid (not expired)
                    if (cachedData.timestamp && now - cachedData.timestamp < ONE_MONTH_MS) {
                        console.log('Using server-cached nearby search results for:', searchKey);
                        return cachedData.data;
                    }
                }
                return null;
            } catch (error) {
                console.error('Error getting server-cached nearby search:', error);
                return null;
            }
        }
        
        // Save nearby search results to server cache
        async function saveServerNearbySearch(searchKey, results) {
            if (typeof firebase === 'undefined' || !firebase.apps.length) return;
            
            try {
                // Ensure the results are serializable
                const serializableResults = results.map(place => {
                    return {
                        place_id: place.place_id,
                        name: place.name,
                        vicinity: place.vicinity,
                        rating: place.rating,
                        user_ratings_total: place.user_ratings_total,
                        price_level: place.price_level,
                        types: place.types ? [...place.types] : [],
                        business_status: place.business_status,
                        // Include a basic photo reference if available
                        photos: place.photos && place.photos.length > 0 ? [{
                            photo_reference: place.photos[0].photo_reference,
                            // Store a direct URL if possible
                            direct_url: typeof place.photos[0].getUrl === 'function' ? 
                                place.photos[0].getUrl({ maxWidth: 800, maxHeight: 600 }) : null
                        }] : null,
                        // Handle geometry coordinates in a safe way
                        geometry: place.geometry ? {
                            location: {
                                lat: typeof place.geometry.location.lat === 'function' ? 
                                    place.geometry.location.lat() : place.geometry.location.lat,
                                lng: typeof place.geometry.location.lng === 'function' ? 
                                    place.geometry.location.lng() : place.geometry.location.lng
                            }
                        } : null
                    };
                });
                
                const hashKey = createCacheHash(searchKey);
                const cacheEntry = {
                    data: serializableResults,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                };
                
                await firebase.database().ref(`${CACHE_PATHS.NEARBY_SEARCH}/${hashKey}`).set(cacheEntry);
                console.log('Saved nearby search to server cache for:', searchKey);
            } catch (error) {
                console.error('Error saving nearby search to server cache:', error);
            }
        }
        
        // Check server cache for place details
        async function getServerCachedPlaceDetails(placeId) {
            if (typeof firebase === 'undefined' || !firebase.apps.length) return null;
            
            try {
                const snapshot = await firebase.database().ref(`${CACHE_PATHS.PLACE_DETAILS}/${placeId}`).once('value');
                
                if (snapshot.exists()) {
                    const cachedData = snapshot.val();
                    const now = Date.now();
                    
                    // Check if cache is still valid (not expired)
                    if (cachedData.timestamp && now - cachedData.timestamp < ONE_MONTH_MS) {
                        console.log('Using server-cached place details for:', placeId);
                        return cachedData.data;
                    }
                }
                return null;
            } catch (error) {
                console.error('Error getting server-cached place details:', error);
                return null;
            }
        }
        
        // Save place details to server cache
        async function saveServerPlaceDetails(placeId, details) {
            if (typeof firebase === 'undefined' || !firebase.apps.length) return;
            
            try {
                // Create a serializable version of the photos array
                let serializablePhotos = [];
                if (details.photos && details.photos.length) {
                    serializablePhotos = details.photos.map(photo => {
                        // Store the direct URL at a reasonable size
                        let directUrl = null;
                        if (typeof photo.getUrl === 'function') {
                            directUrl = photo.getUrl({ maxWidth: 1000, maxHeight: 1000 });
                        } else if (photo.url) {
                            directUrl = photo.url;
                        }
                        
                        return { 
                            url: directUrl,
                            width: photo.width || 1000,
                            height: photo.height || 800,
                            html_attributions: photo.html_attributions || []
                        };
                    }).filter(p => p !== null && p.url);
                }
                
                // Create a serializable copy of details
                const serializableDetails = {
                    placeId: details.placeId,
                    isNew: details.isNew,
                    reviews: details.reviews || [],
                    photos: serializablePhotos
                };
                
                const cacheEntry = {
                    data: serializableDetails,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                };
                
                await firebase.database().ref(`${CACHE_PATHS.PLACE_DETAILS}/${placeId}`).set(cacheEntry);
                console.log('Saved place details to server cache for:', placeId);
            } catch (error) {
                console.error('Error saving place details to server cache:', error);
            }
        }
        
        // Check server cache for travel times
        async function getServerCachedTravelTimes(originDestKey) {
            if (typeof firebase === 'undefined' || !firebase.apps.length) return null;
            
            try {
                const hashKey = createCacheHash(originDestKey);
                const snapshot = await firebase.database().ref(`${CACHE_PATHS.TRAVEL_TIMES}/${hashKey}`).once('value');
                
                if (snapshot.exists()) {
                    const cachedData = snapshot.val();
                    const now = Date.now();
                    
                    // Check if cache is still valid (not expired)
                    if (cachedData.timestamp && now - cachedData.timestamp < ONE_MONTH_MS) {
                        console.log('Using server-cached travel times for:', originDestKey);
                        return cachedData.data;
                    }
                }
                return null;
            } catch (error) {
                console.error('Error getting server-cached travel times:', error);
                return null;
            }
        }
        
        // Save travel times to server cache
        async function saveServerTravelTimes(originDestKey, times) {
            if (typeof firebase === 'undefined' || !firebase.apps.length) return;
            
            try {
                const hashKey = createCacheHash(originDestKey);
                const cacheEntry = {
                    data: times,
                    timestamp: firebase.database.ServerValue.TIMESTAMP
                };
                
                await firebase.database().ref(`${CACHE_PATHS.TRAVEL_TIMES}/${hashKey}`).set(cacheEntry);
                console.log('Saved travel times to server cache for:', originDestKey);
            } catch (error) {
                console.error('Error saving travel times to server cache:', error);
            }
        }

        // --- Utility & Event Listeners ---
        function resetApp() {
            locationInput.value=''; radiusSelect.value='2000'; priceLevelSelect.value=''; cuisineKeywordInput.value=''; resultsUI.friendCodeInput.value='';
            useLLM.checked = false; // Reset the smart ranking filter
            
            // API key handling removed since we're using a predefined key
            
            restaurants=[]; currentIndex=0; likedRestaurants={}; sessionId=''; userCoordinates=null;
            resultsUI.likedListContainer.innerHTML = ''; resultsUI.likedListContainer.classList.add('hidden');
            resultsUI.viewLikedButton.textContent = 'View My Liked Food Places';
            resultsUI.shareLinkInput.value = ''; resultsUI.copyLinkButton.disabled = true;
            matchesUI.list.innerHTML = ''; sharedUI.list.innerHTML = '';
            hideError();
            // Ensure URL is cleaned up if resetting from a shared link view
            if (window.location.search.includes('share=')) {
                window.history.replaceState({}, document.title, window.location.pathname); // Remove query param
            }
            showView(views.search); console.log("App reset.");
        }
        function copySessionId() {
             const code=resultsUI.sessionId.textContent; if(!code||code==='CODE'||!navigator.clipboard){showError("Copy failed.");return;}
             navigator.clipboard.writeText(code).then(()=>{const t=resultsUI.copyCodeButton.textContent;resultsUI.copyCodeButton.textContent='‚úÖ';setTimeout(()=>{resultsUI.copyCodeButton.textContent='üìã';},1500);}).catch(err=>{console.error('Copy failed:',err);showError("Copy failed.");});
        }

        // --- Swipe Gesture Handling ---
        let touchStartX = 0;
        let touchStartY = 0;
        let touchDeltaX = 0;
        let touchDeltaY = 0;
        let isSwiping = false;
        let isScrolling = false;
        const SWIPE_THRESHOLD = 100;
        const SCROLL_THRESHOLD = 15;
        
        function initSwipeGestures() {
            const card = document.querySelector('.restaurant-card');
            if (!card) return;
            
            const likeOverlay = document.querySelector('.swipe-like-overlay');
            const dislikeOverlay = document.querySelector('.swipe-dislike-overlay');
            
            if (!likeOverlay || !dislikeOverlay) return;
            
            // Remove existing listeners if any (to prevent duplicates)
            card.removeEventListener('touchstart', handleTouchStart);
            card.removeEventListener('touchmove', handleTouchMove);
            card.removeEventListener('touchend', handleTouchEnd);
            card.removeEventListener('touchcancel', handleTouchCancel);
            
            // Add touch event listeners
            card.addEventListener('touchstart', handleTouchStart, { passive: true });
            card.addEventListener('touchmove', handleTouchMove, { passive: false });
            card.addEventListener('touchend', handleTouchEnd, { passive: true });
            card.addEventListener('touchcancel', handleTouchCancel, { passive: true });
            
            function handleTouchStart(e) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchDeltaX = 0;
                touchDeltaY = 0;
                isSwiping = false;
                isScrolling = false;
            }
            
            function handleTouchMove(e) {
                if (e.touches.length === 0) return;
                
                touchDeltaX = e.touches[0].clientX - touchStartX;
                touchDeltaY = e.touches[0].clientY - touchStartY;
                
                // Check if vertical scrolling
                if (Math.abs(touchDeltaY) > SCROLL_THRESHOLD && Math.abs(touchDeltaY) > Math.abs(touchDeltaX) && !isSwiping) {
                    isScrolling = true;
                    return;
                }
                
                // If we're scrolling vertically, don't swipe
                if (isScrolling) return;
                
                // Once we've determined it's a horizontal swipe
                if (Math.abs(touchDeltaX) > 20 && !isScrolling) {
                    isSwiping = true;
                    e.preventDefault(); // Prevent scrolling while swiping
                    
                    if (touchDeltaX > 0) {
                        // Swiping right (like)
                        card.classList.add('swiping-right');
                        card.classList.remove('swiping-left');
                        likeOverlay.style.opacity = Math.min(touchDeltaX / (SWIPE_THRESHOLD * 1.5), 0.8);
                        dislikeOverlay.style.opacity = 0;
                    } else {
                        // Swiping left (dislike)
                        card.classList.add('swiping-left');
                        card.classList.remove('swiping-right');
                        dislikeOverlay.style.opacity = Math.min(Math.abs(touchDeltaX) / (SWIPE_THRESHOLD * 1.5), 0.8);
                        likeOverlay.style.opacity = 0;
                    }
                }
            }
            
            function handleTouchEnd() {
                if (isSwiping && !isScrolling) {
                    if (touchDeltaX > SWIPE_THRESHOLD) {
                        // Swipe right completed - Like
                        handleSwipe(true);
                    } else if (touchDeltaX < -SWIPE_THRESHOLD) {
                        // Swipe left completed - Dislike
                        handleSwipe(false);
                    }
                }
                resetSwipeState();
            }
            
            function handleTouchCancel() {
                resetSwipeState();
            }
        }
        
        function resetSwipeState() {
            const card = document.querySelector('.restaurant-card');
            const likeOverlay = document.querySelector('.swipe-like-overlay');
            const dislikeOverlay = document.querySelector('.swipe-dislike-overlay');
            
            if (!card || !likeOverlay || !dislikeOverlay) return;
            
            isSwiping = false;
            isScrolling = false;
            
            card.classList.remove('swiping-left', 'swiping-right');
            likeOverlay.style.opacity = 0;
            dislikeOverlay.style.opacity = 0;
        }
        
        function skipToResults() {
            // Save session to Firebase before transitioning
            saveSessionToFirebase();
            
            // Update liked count display
            const likedCount = Object.keys(likedRestaurants).length;
            resultsUI.likedCount.textContent = likedCount;
            
            // Generate share link
            generateShareLink();
            
            // Transition to results view
            showView(views.results);
            
            // Populate liked restaurants list
            populateLikedRestaurantsList();
        }

        window.swipeUI = swipeUI; window.resultsUI = resultsUI; window.matchesUI = matchesUI; window.sharedUI = sharedUI;

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', function(){
            // Page setup
            setTimeout(initializeFirebase, 500);
            loadGoogleMapsScript();
            
            // Remove API key related code since we're using a predefined key
            // Keep the container hidden at all times
            document.getElementById('api-key-container').classList.add('hidden');
            
            // Search view events
            searchForm.addEventListener('submit', function(e) { e.preventDefault(); fetchRestaurants(); });
        useLocationButton.addEventListener('click', getUserLocation);
            
            // Swipe view events
            swipeUI.prevPhotoBtn.addEventListener('click', showPreviousPhoto);
            swipeUI.nextPhotoBtn.addEventListener('click', showNextPhoto);
        swipeUI.dislikeButton.addEventListener('click', () => handleSwipe(false));
        swipeUI.likeButton.addEventListener('click', () => handleSwipe(true));
            document.getElementById('skip-to-results-button').addEventListener('click', skipToResults);
            
            // Initialize swipe gestures when entering swipe view
            // We need to re-initialize after each view change to capture the current card
            views.swipe.addEventListener('transitionend', function(e) {
                if (e.target === views.swipe && !views.swipe.classList.contains('transition-hidden')) {
                    // Only initialize when swipe view becomes visible
                    setTimeout(initSwipeGestures, 100); // Short delay to ensure DOM is ready
                }
            });
            
            // Initialize immediately if swipe view is already visible
            if (!views.swipe.classList.contains('transition-hidden')) {
                setTimeout(initSwipeGestures, 100);
            }
            
            // Results view events
        resultsUI.findMatchesButton.addEventListener('click', findMatches);
        resultsUI.startOverButton.addEventListener('click', resetApp);
        resultsUI.copyCodeButton.addEventListener('click', copySessionId);
            resultsUI.sessionId.addEventListener('click', () => { 
                if (resultsUI.sessionId.textContent !== 'CODE') { 
                    window.getSelection().selectAllChildren(resultsUI.sessionId); 
                }
            });
            resultsUI.viewLikedButton.addEventListener('click', () => { 
                console.log("View liked button clicked");
                const isHidden = resultsUI.likedListContainer.classList.toggle('hidden'); 
                console.log("Liked list is now:", isHidden ? "hidden" : "visible");
                
                // Update button text
                resultsUI.viewLikedButton.textContent = isHidden ? 'View My Liked Food Places' : 'Hide My Liked Food Places'; 
                
                // If showing the list, make sure it's populated
                if (!isHidden) {
                    console.log("Populating liked restaurants list");
                    populateLikedRestaurantsList();
                }
            });
        resultsUI.copyLinkButton.addEventListener('click', copyShareLink);
            
            // Other view events
        matchesUI.startOverButton.addEventListener('click', resetApp);
        sharedUI.startOverButton.addEventListener('click', resetApp);

            // Check for shared link params
            const urlParams = new URLSearchParams(window.location.search);
            const shareId = urlParams.get('share');

            if (shareId) {
                // If share ID exists, prepare to handle it after Firebase is ready
                setLoadingText("Loading shared list...");
                showView(views.loading); // Show loading early

                const firebaseInitInterval = setInterval(() => {
                    // Check if Firebase is initialized
                    if (typeof firebase !== 'undefined' && firebase.apps.length > 0 && firebase.database()) {
                        clearInterval(firebaseInitInterval);
                        console.log("Firebase ready, handling shared link...");
                        handleSharedLink(shareId); // Handle the link AFTER Firebase is ready
                    }
                 }, 150); // Check slightly less frequently

                 // Timeout safeguard in case Firebase never loads/initializes
                 setTimeout(() => {
                      // Check if we are still stuck on loading or haven't transitioned to shared view
                      if(currentVisibleView === views.loading || currentVisibleView !== views.shared){
                         clearInterval(firebaseInitInterval);
                         console.error("Timeout waiting for Firebase initialization for shared link.");
                         showError("Failed to initialize services to load shared list in time.");
                         // Decide on a fallback view - Resetting is usually safest
                         resetApp(); // Reset state and show search view
                      }
                 }, 10000); // 10 second timeout
            } else {
                // Normal startup sequence: Just show the search view
                showView(views.search);
            }

            // Initialize the API usage display
            updateAPIUsageDisplay();
        });

        function showPreviousPhoto() {
            if (!restaurants[currentIndex]) return;
            const r = restaurants[currentIndex];
            if (!r.photoUrls || r.photoUrls.length <= 1) return;
            r.currentPhotoIndex = (r.currentPhotoIndex - 1 + r.photoUrls.length) % r.photoUrls.length;
            swipeUI.image.src = r.photoUrls[r.currentPhotoIndex];
            
            // Only update photo indicators, don't recreate travel times
            updatePhotoIndicators(r);
        }
        
        function showNextPhoto() {
            if (!restaurants[currentIndex]) return;
            const r = restaurants[currentIndex];
            if (!r.photoUrls || r.photoUrls.length <= 1) return;
            r.currentPhotoIndex = (r.currentPhotoIndex + 1) % r.photoUrls.length;
            swipeUI.image.src = r.photoUrls[r.currentPhotoIndex];
            
            // Only update photo indicators, don't recreate travel times
            updatePhotoIndicators(r);
        }
        
        // New function to update only photo indicators, separate from full display update
        function updatePhotoIndicators(restaurant) {
            if (!swipeUI.photoIndicators) return;
            
            swipeUI.photoIndicators.innerHTML = '';
            if (!restaurant || !restaurant.photoUrls) return;
            
            restaurant.photoUrls.forEach((_, index) => {
                const dot = document.createElement('span');
                dot.className = 'photo-dot' + (index === restaurant.currentPhotoIndex ? ' active' : '');
                swipeUI.photoIndicators.appendChild(dot);
            });
        }

        function navigatePhoto(direction) {
            const r = restaurants[currentIndex];
            if (!r || !r.photoUrls || r.photoUrls.length <= 1) return;
            
            const num = r.photoUrls.length;
            r.currentPhotoIndex = ((r.currentPhotoIndex || 0) + direction + num) % num;
            
            // Only update photo indicators, don't recreate travel times
            if (swipeUI.image) {
                swipeUI.image.src = r.photoUrls[r.currentPhotoIndex];
            }
            updatePhotoIndicators(r);
        }

        function updateAPIUsageDisplay() {
            const usageData = getAPIUsageStats();
            const usageDisplay = document.getElementById('api-usage-display');
            
            if (!usageDisplay) return;
            
            if (Object.keys(usageData).length === 0) {
                usageDisplay.textContent = "No API calls yet";
                return;
            }
            
            // Sort dates from most recent to oldest
            const sortedDates = Object.keys(usageData).sort().reverse();
            
            // Get last 7 days of data
            const recentDates = sortedDates.slice(0, 7);
            
            // Format for display
            const formattedUsage = recentDates.map(date => {
                const count = usageData[date];
                // Format date as "MMM DD" (e.g., "Jan 15")
                const formattedDate = new Date(date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                return `${formattedDate}: ${count}`;
            }).join(' | ');
            
            usageDisplay.textContent = formattedUsage;
        }
    </script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js" defer></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js" defer></script>

    <!-- Place API Caching Script -->
    <script>
        // Cache system to reduce API calls
        class PlacesCache {
            constructor() {
                this.storageKey = 'restaurantFinderCache';
                this.expiryTime = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
                this.cache = this.loadFromStorage();
            }

            // Load cache from localStorage
            loadFromStorage() {
                try {
                    const cachedData = localStorage.getItem(this.storageKey);
                    if (cachedData) {
                        const parsed = JSON.parse(cachedData);
                        // Clean expired entries
                        this.cleanExpiredEntries(parsed);
                        return parsed;
                    }
                } catch (error) {
                    console.error('Error loading cache:', error);
                }
                return { 
                    nearbySearches: {}, 
                    placeDetails: {}, 
                    travelTimes: {},  // Add travel times cache
                    lastCleanup: Date.now() 
                };
            }

            // Save cache to localStorage
            saveToStorage() {
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(this.cache));
                } catch (error) {
                    console.error('Error saving cache:', error);
                    // If storage is full, clear it and try again
                    if (error.name === 'QuotaExceededError') {
                        this.clearOldEntries(75); // Clear 75% of old entries
                        try {
                            localStorage.setItem(this.storageKey, JSON.stringify(this.cache));
                        } catch (innerError) {
                            console.error('Still cannot save cache after cleanup:', innerError);
                        }
                    }
                }
            }

            // Clean expired entries
            cleanExpiredEntries(cacheObj) {
                const now = Date.now();
                // Only run cleanup once a day
                if (cacheObj.lastCleanup && now - cacheObj.lastCleanup < 24 * 60 * 60 * 1000) {
                    return;
                }

                // Clean nearby searches
                for (const key in cacheObj.nearbySearches) {
                    if (now - cacheObj.nearbySearches[key].timestamp > this.expiryTime) {
                        delete cacheObj.nearbySearches[key];
                    }
                }

                // Clean place details
                for (const key in cacheObj.placeDetails) {
                    if (now - cacheObj.placeDetails[key].timestamp > this.expiryTime) {
                        delete cacheObj.placeDetails[key];
                    }
                }
                
                // Clean travel times
                if (cacheObj.travelTimes) {
                    for (const key in cacheObj.travelTimes) {
                        if (now - cacheObj.travelTimes[key].timestamp > this.expiryTime) {
                            delete cacheObj.travelTimes[key];
                        }
                    }
                } else {
                    cacheObj.travelTimes = {};
                }

                cacheObj.lastCleanup = now;
            }

            // Clear a percentage of oldest entries when storage is full
            clearOldEntries(percentage) {
                const sortedNearby = Object.entries(this.cache.nearbySearches)
                    .sort((a, b) => a[1].timestamp - b[1].timestamp);
                
                const sortedDetails = Object.entries(this.cache.placeDetails)
                    .sort((a, b) => a[1].timestamp - b[1].timestamp);
                
                const sortedTravelTimes = Object.entries(this.cache.travelTimes || {})
                    .sort((a, b) => a[1].timestamp - b[1].timestamp);
                
                // Calculate how many to remove
                const nearbyToRemove = Math.floor(sortedNearby.length * (percentage / 100));
                const detailsToRemove = Math.floor(sortedDetails.length * (percentage / 100));
                const travelTimesToRemove = Math.floor(sortedTravelTimes.length * (percentage / 100));
                
                // Remove oldest entries
                for (let i = 0; i < nearbyToRemove; i++) {
                    if (sortedNearby[i]) {
                        delete this.cache.nearbySearches[sortedNearby[i][0]];
                    }
                }
                
                for (let i = 0; i < detailsToRemove; i++) {
                    if (sortedDetails[i]) {
                        delete this.cache.placeDetails[sortedDetails[i][0]];
                    }
                }
                
                for (let i = 0; i < travelTimesToRemove; i++) {
                    if (sortedTravelTimes[i]) {
                        delete this.cache.travelTimes[sortedTravelTimes[i][0]];
                    }
                }
                
                console.log(`Cleared ${nearbyToRemove} nearby searches, ${detailsToRemove} place details, and ${travelTimesToRemove} travel times from cache`);
            }

            // Get cached nearby search results
            getCachedNearbySearch(searchKey) {
                const cachedResult = this.cache.nearbySearches[searchKey];
                if (cachedResult && Date.now() - cachedResult.timestamp < this.expiryTime) {
                    console.log('Using cached nearby search results for:', searchKey);
                    return cachedResult.data;
                }
                return null;
            }

            // Cache nearby search results
            cacheNearbySearch(searchKey, results) {
                try {
                    // We need to ensure we're not trying to cache Google Maps objects directly
                    // which are not serializable. Create a clean copy with only the data we need.
                    const serializableResults = results.map(place => {
                        return {
                            place_id: place.place_id,
                            name: place.name,
                            vicinity: place.vicinity,
                            rating: place.rating,
                            user_ratings_total: place.user_ratings_total,
                            price_level: place.price_level,
                            types: place.types ? [...place.types] : [],
                            business_status: place.business_status,
                            // Include a basic photo reference if available
                            photos: place.photos && place.photos.length > 0 ? [{
                                photo_reference: place.photos[0].photo_reference,
                                // Store a direct URL if possible
                                direct_url: typeof place.photos[0].getUrl === 'function' ? 
                                    place.photos[0].getUrl({ maxWidth: 800, maxHeight: 600 }) : null
                            }] : null,
                            // Handle geometry coordinates in a safe way
                            geometry: place.geometry ? {
                                location: {
                                    lat: typeof place.geometry.location.lat === 'function' ? 
                                        place.geometry.location.lat() : place.geometry.location.lat,
                                    lng: typeof place.geometry.location.lng === 'function' ? 
                                        place.geometry.location.lng() : place.geometry.location.lng
                                }
                            } : null
                        };
                    });
                    
                    this.cache.nearbySearches[searchKey] = {
                        data: serializableResults,
                        timestamp: Date.now()
                    };
                    this.saveToStorage();
                } catch (error) {
                    console.error('Error caching nearby search results:', error);
                    // Continue without caching if there's an error
                }
            }

            // Get cached place details
            getCachedPlaceDetails(placeId) {
                const cachedResult = this.cache.placeDetails[placeId];
                if (cachedResult && Date.now() - cachedResult.timestamp < this.expiryTime) {
                    console.log('Using cached place details for:', placeId);
                    return cachedResult.data;
                }
                return null;
            }

            // Cache place details
            cachePlaceDetails(placeId, details) {
                try {
                    // Create a serializable version of the photos array
                    let serializablePhotos = [];
                    if (details.photos && details.photos.length) {
                        serializablePhotos = details.photos.map(photo => {
                            // Store the direct URL at a reasonable size
                            let directUrl = null;
                            if (typeof photo.getUrl === 'function') {
                                directUrl = photo.getUrl({ maxWidth: 1000, maxHeight: 1000 });
                            } else if (photo.url) {
                                directUrl = photo.url;
                            }
                            
                            return { 
                                url: directUrl,
                                width: photo.width || 1000,
                                height: photo.height || 800,
                                html_attributions: photo.html_attributions || []
                            };
                        }).filter(p => p !== null && p.url);
                    }
                    
                    // Create a serializable copy of details
                    const serializableDetails = {
                        placeId: details.placeId,
                        isNew: details.isNew,
                        reviews: details.reviews || [],
                        photos: serializablePhotos
                    };
                    
                    this.cache.placeDetails[placeId] = {
                        data: serializableDetails,
                        timestamp: Date.now()
                    };
                    this.saveToStorage();
                } catch (error) {
                    console.error('Error caching place details:', error);
                    // Continue without caching if there's an error
                }
            }
            
            // Get cached travel times
            getCachedTravelTimes(originDestKey) {
                if (!this.cache.travelTimes) {
                    this.cache.travelTimes = {};
                    return null;
                }
                
                const cachedResult = this.cache.travelTimes[originDestKey];
                if (cachedResult && Date.now() - cachedResult.timestamp < this.expiryTime) {
                    console.log('Using cached travel times for:', originDestKey);
                    return cachedResult.data;
                }
                return null;
            }
            
            // Cache travel times
            cacheTravelTimes(originDestKey, times) {
                if (!this.cache.travelTimes) {
                    this.cache.travelTimes = {};
                }
                
                this.cache.travelTimes[originDestKey] = {
                    data: times,
                    timestamp: Date.now()
                };
                this.saveToStorage();
            }
        }

        // Create global cache instance
        window.placesCache = new PlacesCache();
    </script>
</body>
</html>
