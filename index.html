<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Restaurant Matcher</title>
    <style>
        /* --- Base Styles --- */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', Roboto, Arial, sans-serif; }
        body { 
            background-color: #f8f9fa; 
            color: #333; 
            line-height: 1.6;
            font-size: 15px;
            -webkit-text-size-adjust: 100%; /* Prevent text scaling in Safari */
            width: 100%;
            overflow-x: hidden;
        }
        :root {
            --primary: #FF5864;
            --primary-dark: #e1404d;
            --secondary: #007bff;
            --accent: #00d174;
            --light-gray: #f5f5f5;
            --mid-gray: #ddd;
            --dark-gray: #555;
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --shadow-sm: 0 2px 5px rgba(0,0,0,0.08);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.1);
            --transition: all 0.2s ease;
        }
        .container { 
            max-width: 100%; 
            width: 100%; 
            max-width: 500px; 
            margin: 0 auto; 
            padding: 15px;
            padding-left: max(15px, env(safe-area-inset-left));
            padding-right: max(15px, env(safe-area-inset-right));
            overflow: visible;
            box-sizing: border-box;
        }
        .hidden { display: none !important; }

        /* --- Typography --- */
        h1, h2, h3 { line-height: 1.3; }
        h1 { font-size: 22px; font-weight: 600; }
        h2 { font-size: 18px; font-weight: 600; }
        h3 { font-size: 16px; font-weight: 600; }
        p { margin-bottom: 0.5rem; }

        /* --- Layout Components --- */
        .card {
            background: white;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            margin-bottom: 15px;
            overflow: hidden;
        }
        .card-header {
            padding: 12px 15px;
            border-bottom: 1px solid var(--light-gray);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .card-body {
            padding: 15px;
        }
        .card-footer {
            padding: 12px 15px;
            border-top: 1px solid var(--light-gray);
        }

        /* --- View Transitions --- */
        .view { width: 100%; opacity: 1; transition: opacity 0.3s ease-in-out; display: block; }
        .view.transition-hidden { opacity: 0; height: 0; overflow: hidden; pointer-events: none; }

        /* --- Header --- */
        .header { 
            text-align: center; 
            margin-bottom: 15px; 
        }
        .header h1 { 
            color: var(--primary); 
            margin-bottom: 4px; 
        }
        .header p { 
            font-size: 14px; 
            color: var(--dark-gray);
        }

        /* --- Forms & Inputs --- */
        .search-form { 
            background-color: white; 
            border-radius: var(--radius-md); 
            padding: 15px; 
            box-shadow: var(--shadow-sm); 
            margin-bottom: 15px; 
        }
        .form-group { 
            margin-bottom: 12px; 
            position: relative;
        }
        .form-group:last-child {
            margin-bottom: 0;
        }
        label { 
            font-size: 13px;
            font-weight: 500; 
            color: var(--dark-gray); 
            display: block;
            margin-bottom: 4px;
        }
        .input-with-icon {
            position: relative;
        }
        .input-icon {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #777;
            font-size: 16px;
        }
        .button .input-icon {
            position: static;
            transform: none;
            margin-right: 6px;
            display: inline;
        }
        input, select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--mid-gray);
            border-radius: var(--radius-sm);
            font-size: 14px;
            background-color: #fff;
            height: 38px;
            transition: var(--transition);
        }
        .input-with-icon input,
        .input-with-icon select {
            padding-left: 35px;
        }
        input:focus, select:focus { 
            border-color: var(--primary); 
            outline: none; 
            box-shadow: 0 0 0 2px rgba(255, 88, 100, 0.15); 
        }
        .checkbox-group {
            display: flex;
            align-items: center;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
            height: auto;
            margin-right: 8px;
        }
        .checkbox-group label {
            margin: 0;
            display: inline;
            font-size: 13px;
        }

        /* --- Buttons --- */
        .button {
            display: inline-block;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 30px;
            padding: 9px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            text-align: center;
            width: 100%;
            transition: var(--transition);
            line-height: 1.3;
        }
        .button:hover:not(:disabled) { 
            background-color: var(--primary-dark); 
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        .button:active:not(:disabled) { 
            transform: translateY(0);
        }
        .button:disabled { 
            background-color: #ccc; 
            cursor: not-allowed; 
        }
        .button.secondary { 
            background-color: var(--secondary); 
        }
        .button.tertiary { 
            background-color: #6c757d; 
        }
        .button.outline {
            background: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }
        .button.outline:hover {
            background-color: rgba(255,88,100,0.05);
        }
        .button.small {
            font-size: 13px;
            padding: 6px 12px;
        }
        .button.icon-button {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .button.icon-button i {
            margin-right: 6px;
        }
        .button.icon-button .input-icon {
            flex-shrink: 0;
        }
        .location-button { 
            margin-top: 8px;
        }
        .action-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            box-shadow: var(--shadow-sm);
            cursor: pointer;
            transition: var(--transition);
            font-size: 18px;
            border: none;
        }
        .action-button:hover { 
            transform: scale(1.08); 
            box-shadow: var(--shadow-md);
        }
        .action-button:active { 
            transform: scale(1.02);
        }
        .like-button { 
            color: var(--accent);
        }
        .dislike-button { 
            color: var(--primary);
        }

        /* --- Restaurant Cards --- */
        .restaurant-card {
            border-radius: var(--radius-md);
            overflow: hidden;
            background: white;
            box-shadow: var(--shadow-md);
            display: flex;
            flex-direction: column;
            height: calc(100vh - 140px);
            max-height: 700px;
            position: relative;
            transition: transform 0.3s ease;
            touch-action: pan-y; /* Allow vertical scrolling but capture horizontal */
        }
        .swipe-hint {
            text-align: center;
            color: var(--dark-gray);
            font-size: 12px;
            margin-top: 5px;
            opacity: 0.7;
            font-style: italic;
        }
        .restaurant-info {
            position: relative;
        }
        .restaurant-info::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 10px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.05), transparent);
            pointer-events: none;
        }
        /* Touch feedback styles */
        .swiping-right {
            transform: rotate(5deg) translateX(40px);
            box-shadow: 0 5px 20px rgba(0, 209, 116, 0.4);
            border: 2px solid var(--accent);
        }
        .swiping-left {
            transform: rotate(-5deg) translateX(-40px);
            box-shadow: 0 5px 20px rgba(255, 88, 100, 0.4);
            border: 2px solid var(--primary);
        }
        .swipe-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
            font-size: 80px;
        }
        .swipe-like-overlay {
            background-color: rgba(0, 209, 116, 0.2);
            color: var(--accent);
        }
        .swipe-dislike-overlay {
            background-color: rgba(255, 88, 100, 0.2);
            color: var(--primary);
        }
        .photo-container { 
            position: relative;
            width: 100%;
            height: 40%;
            min-height: 200px;
            overflow: hidden;
            background-color: #f0f0f0;
        }
        .card-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        .photo-nav { 
            position: absolute;
            left: 0;
            right: 0;
            bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1;
        }
        .photo-nav-btn { 
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 5px;
            transition: var(--transition);
        }
        .photo-nav-btn:hover { 
            background-color: rgba(0, 0, 0, 0.8);
        }
        #photo-indicators { 
            display: flex;
            justify-content: center;
            margin: 0 10px;
        }
        .photo-dot { 
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
            margin: 0 3px;
            display: inline-block;
            transition: var(--transition);
        }
        .photo-dot.active { 
            background-color: #fff;
        }
        .restaurant-info {
            padding: 15px;
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow-y: auto;
        }
        .restaurant-info-header {
            margin-bottom: 8px;
        }
        .restaurant-info-header h2 {
            margin-bottom: 2px;
        }
        .restaurant-meta {
            display: flex;
            flex-wrap: wrap;
            font-size: 13px;
            color: var(--dark-gray);
            margin-bottom: 8px;
        }
        .meta-item {
            margin-right: 12px;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
        }
        .meta-icon {
            margin-right: 4px;
            font-size: 14px;
        }
        .restaurant-info-body {
            flex: 1;
            overflow-y: auto;
        }
        .restaurant-info-footer {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--light-gray);
        }
        .card-actions {
            display: flex;
            justify-content: space-evenly;
            padding: 15px;
            background: none;
            border-top: 1px solid #eee;
            z-index: 2;
        }
        .google-maps-link {
            display: inline-flex;
            align-items: center;
            color: var(--secondary);
            text-decoration: none;
            font-size: 13px;
            font-weight: 500;
        }
        .google-maps-link:hover {
            text-decoration: underline;
        }

        /* --- Travel Times --- */
        .travel-times {
            display: flex;
            flex-wrap: wrap;
            margin-top: 8px;
            font-size: 13px;
            color: var(--dark-gray);
        }
        .travel-times-compact {
            display: flex;
            font-size: 12px;
            color: var(--dark-gray);
            flex-wrap: nowrap;
            align-items: center;
        }
        .travel-times-compact .travel-time-item {
            margin-right: 8px;
            padding: 2px 6px;
            background: var(--light-gray);
            border-radius: 12px;
            white-space: nowrap;
        }
        .travel-time-item {
            display: flex;
            align-items: center;
            margin-right: 12px;
            margin-bottom: 4px;
            background: var(--light-gray);
            padding: 4px 8px;
            border-radius: 20px;
        }
        .travel-time-icon {
            margin-right: 4px;
        }
        .travel-time-loading {
            font-style: italic;
            font-size: 12px;
        }

        /* --- Reviews --- */
        .reviews-section {
            margin-top: 15px;
        }
        .reviews-title {
            font-size: 15px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        .reviews-title::before {
            content: "★";
            margin-right: 5px;
            color: #FFA534;
        }
        .review-item {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--light-gray);
        }
        .review-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .review-author {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
            font-size: 12px;
        }
        .review-author strong {
            font-weight: 600;
        }
        .review-star {
            color: #FFA534;
        }
        .review-date {
            color: #888;
            font-size: 11px;
        }
        .review-text {
            margin-top: 4px;
            font-size: 13px;
            line-height: 1.4;
            color: var(--dark-gray);
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            max-width: 100%;
        }
        .review-text.truncated {
            cursor: pointer;
        }
        .review-text.truncated::after {
            content: "⋯ Read more";
            color: var(--secondary);
            white-space: nowrap;
            margin-left: 4px;
        }
        .review-text.expanded {
            white-space: pre-wrap;
        }
        .review-type {
            font-size: 10px;
            background-color: #f0f0f0;
            color: #666;
            padding: 1px 4px;
            border-radius: 3px;
            margin-left: 5px;
        }

        /* --- Restaurant Lists --- */
        .restaurant-list {
            margin-top: 15px;
        }
        .restaurant-item {
            display: flex;
            border-bottom: 1px solid var(--light-gray);
            padding: 12px;
            width: 100%;
            box-sizing: border-box;
        }
        .restaurant-item:last-child {
            border-bottom: none;
        }
        .restaurant-item-image {
            width: 80px;
            height: 80px;
            border-radius: var(--radius-sm);
            object-fit: cover;
            margin-right: 12px;
            flex-shrink: 0;
        }
        .restaurant-item-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0; /* Prevents flex items from overflowing */
            width: calc(100% - 92px); /* 80px image + 12px margin */
        }
        .restaurant-item h3 {
            font-size: 15px;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .restaurant-item p {
            font-size: 12px;
            color: var(--dark-gray);
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .restaurant-item .meta-row {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 2px;
        }
        .restaurant-item .meta-item {
            font-size: 12px;
            margin-right: 8px;
            color: var(--dark-gray);
        }
        .price-level {
            color: #27ae60;
            font-weight: 500;
        }
        .restaurant-item .travel-times {
            margin-top: 4px;
            margin-bottom: 4px;
        }
        .restaurant-item .review-item {
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .restaurant-item .google-maps-link {
            font-size: 12px;
            margin-top: 4px;
            margin-bottom: 4px;
            display: block;
        }

        /* --- Loading & Error --- */
        .loading {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            padding: 20px;
            text-align: center;
            color: var(--dark-gray);
        }
        .spinner {
            border: 3px solid rgba(0, 0, 0, 0.1);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border-left-color: var(--primary);
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error-message {
            color: #c0392b;
            text-align: center;
            padding: 12px;
            background-color: #fbecea;
            border: 1px solid #e74c3c;
            border-radius: var(--radius-sm);
            margin: 15px 0;
            font-size: 14px;
        }

        /* --- New Restaurant Sticker --- */
        .new-sticker {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #FF3B30;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            transform: rotate(5deg);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 10;
            animation: pulse-bounce 2s infinite;
        }
        @keyframes pulse-bounce {
            0% { transform: rotate(5deg) scale(1); }
            20% { transform: rotate(5deg) scale(1.05); }
            30% { transform: rotate(5deg) scale(1); }
            40% { transform: rotate(5deg) scale(1.05); }
            50% { transform: rotate(5deg) scale(1); }
            100% { transform: rotate(5deg) scale(1); }
        }

        /* --- Results/Matching UI --- */
        .session-code {
            font-size: 20px;
            background-color: var(--light-gray);
            padding: 5px 10px;
            border-radius: var(--radius-sm);
            user-select: all;
            cursor: pointer;
            font-family: monospace;
        }
        .copy-button {
            background: none;
            border: none;
            color: var(--dark-gray);
            font-size: 16px;
            cursor: pointer;
            padding: 3px 5px;
            vertical-align: middle;
        }
        .share-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--light-gray);
        }

        /* --- Responsive design --- */
        @media (max-width: 580px) {
            .container {
                padding: 10px;
                padding-left: max(10px, env(safe-area-inset-left));
                padding-right: max(10px, env(safe-area-inset-right));
                width: 100%;
            }
            .restaurant-card {
                height: calc(100vh - 120px);
                width: 100%;
                max-width: 100%;
            }
            .restaurant-item {
                width: 100%;
                box-sizing: border-box;
            }
            .restaurant-item-image {
                width: 70px;
                height: 70px;
            }
            /* Adjust font sizes for better mobile legibility */
            .restaurant-item h3 {
                font-size: 14px;
            }
            .restaurant-item p,
            .restaurant-item .meta-item,
            .travel-times-compact {
                font-size: 11px;
            }
        }

        /* Fix for iOS Safari notch support */
        @supports (padding: max(0px)) {
            body {
                padding-left: min(0px, env(safe-area-inset-left));
                padding-right: min(0px, env(safe-area-inset-right));
            }
            .container {
                padding-left: max(15px, env(safe-area-inset-left));
                padding-right: max(15px, env(safe-area-inset-right));
            }
        }
    </style>
</head>
<body>
    <div class="container">
         <div id="error-container" class="error-message hidden"></div>

        <!-- Search View -->
        <div id="search-view" class="view">
            <div class="header"> <h1>Restaurant Matcher</h1> <p>Find food places to enjoy with friends</p> </div>
            <form id="search-form" class="search-form">
                 <div class="form-group">
                    <label for="location">Location</label>
                    <div class="input-with-icon">
                        <span class="input-icon">📍</span>
                        <input id="location" type="text" placeholder="Enter city, neighborhood, or address" required />
                </div>
                    <button type="button" id="use-location-button" class="button icon-button location-button">
                        <span class="input-icon">📍</span> Use My Location
                    </button>
                </div>
                 <div class="form-group">
                    <label for="radius">Search radius</label>
                    <div class="input-with-icon">
                        <span class="input-icon">🔍</span>
                        <select id="radius" name="radius">
                            <option value="1000">1 km</option>
                            <option value="2000" selected>2 km</option>
                            <option value="5000">5 km</option>
                            <option value="10000">10 km</option>
                            <option value="20000">20 km</option>
                        </select>
                 </div>
                </div>
                <div class="form-group">
                    <label for="price-level">Price range</label>
                    <div class="input-with-icon">
                        <span class="input-icon">💰</span>
                        <select id="price-level" name="price-level">
                            <option value="">Any price</option>
                            <option value="1">$ (Inexpensive)</option>
                            <option value="2">$$ (Moderate)</option>
                            <option value="3">$$$ (Expensive)</option>
                            <option value="4">$$$$ (Very Expensive)</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <label for="cuisine-keyword">Cuisine or place type</label>
                    <div class="input-with-icon">
                        <span class="input-icon">🍽️</span>
                        <input type="text" id="cuisine-keyword" name="cuisine-keyword" placeholder="e.g., Italian, Pizza, Cafe, Hawker">
                    </div>
                </div>
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="high-rating-filter" name="high-rating-filter">
                        <label for="high-rating-filter">Only highly-rated places (4.5+ stars)</label>
                    </div>
                </div>
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="popular-places-filter" name="popular-places-filter">
                        <label for="popular-places-filter">Only popular places (4.2+ stars, 100+ reviews)</label>
                    </div>
                </div>
                <button type="submit" class="button icon-button" id="search-button">
                    <span class="input-icon">🔍</span> Find Food Places
                </button>
            </form>
        </div>

        <!-- Loading View -->
        <div id="loading-view" class="view transition-hidden"> <div class="loading"><div class="spinner"></div><p id="loading-text">Finding food places...</p></div> </div>

        <!-- Swipe View -->
        <div id="swipe-view" class="view transition-hidden">
            <div class="header">
                <h1>Find Your Match</h1>
                <p>Food Place <span id="current-index">1</span> of <span id="total-restaurants">?</span></p>
            </div>
            <div class="restaurant-card">
                <div class="swipe-overlay swipe-like-overlay">❤️</div>
                <div class="swipe-overlay swipe-dislike-overlay">❌</div>
                <div class="photo-container">
                    <img class="card-img" id="restaurant-image" src="..." alt="Restaurant">
                    <div class="photo-nav">
                        <button id="prev-photo" class="photo-nav-btn">❮</button>
                        <div id="photo-indicators"></div>
                        <button id="next-photo" class="photo-nav-btn">❯</button>
                    </div>
                </div>
                <div class="restaurant-info">
                    <div class="restaurant-info-header">
                        <h2 id="restaurant-name">...</h2>
                        <div class="restaurant-meta">
                            <div class="meta-item" id="restaurant-rating"><span class="meta-icon">⭐</span> ...</div>
                            <div class="meta-item" id="restaurant-price"><span class="meta-icon">💰</span> ...</div>
                        </div>
                        <div class="meta-item" id="restaurant-address"><span class="meta-icon">📍</span> ...</div>
                    </div>
                    
                    <div class="restaurant-info-body" id="google-maps-link-placeholder">
                        <!-- Travel times and reviews will be inserted here -->
                    </div>
                </div>
                <div class="card-actions">
                    <button class="action-button dislike-button" id="dislike-button">❌</button>
                    <button class="action-button like-button" id="like-button">❤️</button>
                </div>
                <div class="swipe-hint">Swipe right to like, left to dislike, or use buttons</div>
            </div>
        </div>

        <!-- Results View -->
        <div id="results-view" class="view transition-hidden">
            <div class="header">
                <h1>Your Results</h1>
                <p>You liked <span id="liked-count">0</span> food place(s)</p>
            </div>
            <div class="card">
                <div class="card-header">
                    <h3>Share & Match</h3>
                </div>
                <div class="card-body">
                 <!-- Session Code -->
                    <div class="form-group">
                        <label>Your session code</label>
                        <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 15px;">
                            <span id="session-id" class="session-code">CODE</span>
                            <button id="copy-code-button" title="Copy Code" class="copy-button">📋</button>
                        </div>
                    </div>

                 <!-- Find Matches -->
                    <div class="form-group">
                        <label for="friend-code">Enter friend's code</label>
                        <input id="friend-code" type="text" placeholder="Paste friend's code"/>
                    </div>
                 <button class="button" id="find-matches-button">Find Matches</button>

                 <!-- Share Link Section -->
                    <div id="share-link-section" class="share-section">
                        <label for="share-link-input">Share your liked list</label>
                     <div style="display: flex; align-items: center;">
                         <input type="text" id="share-link-input" readonly placeholder="Generating share link...">
                            <button id="copy-link-button" title="Copy Link" class="copy-button">📋</button>
                    </div>
                 </div>
                </div>
                <div class="card-footer">
                 <!-- View Liked / Start Over -->
                    <button type="button" class="button secondary" id="view-liked-button" style="margin-bottom: 10px;">View My Liked Food Places</button>
                    <button class="button tertiary" id="start-over-button">Start Over</button>
                </div>
             </div>

            <div id="liked-restaurants-list" class="restaurant-list hidden card">
                 <!-- Liked restaurants populated here -->
             </div>
        </div>

        <!-- Matches View -->
        <div id="matches-view" class="view transition-hidden">
            <div class="header"> <h1>Your Matches!</h1> <p>Food places you both liked</p> </div>
            <div id="matches-list" class="restaurant-list"> <!-- Content will be generated --> </div>
            <button class="button" id="matches-start-over-button" style="margin-top:20px;">Start Over</button>
        </div>

        <!-- Shared View -->
        <div id="shared-view" class="view transition-hidden">
             <div class="header"> <h1>Shared Food Places</h1> <p id="shared-list-source">List from a friend</p> </div>
             <div id="shared-restaurants-list" class="restaurant-list">
                 <p style="text-align:center; padding: 20px;">Loading shared list...</p>
                 <!-- Shared restaurants will be populated here -->
             </div>
             <button class="button" id="shared-start-over-button" style="margin-top:20px;">Start Your Own Search</button>
        </div>

    </div>

    <script>
        // --- JS Code ---
        const views = { search: document.getElementById('search-view'), loading: document.getElementById('loading-view'), swipe: document.getElementById('swipe-view'), results: document.getElementById('results-view'), matches: document.getElementById('matches-view'),
                      shared: document.getElementById('shared-view') };
        const searchForm = document.getElementById('search-form');
        const locationInput = document.getElementById('location');
        const useLocationButton = document.getElementById('use-location-button');
        const radiusSelect = document.getElementById('radius');
        const priceLevelSelect = document.getElementById('price-level');
        const cuisineKeywordInput = document.getElementById('cuisine-keyword');
        const highRatingFilter = document.getElementById('high-rating-filter');
        const popularPlacesFilter = document.getElementById('popular-places-filter');
        const searchButton = document.getElementById('search-button');
        const loadingText = document.getElementById('loading-text');
        const swipeUI = { currentIndex: document.getElementById('current-index'), totalRestaurants: document.getElementById('total-restaurants'), image: document.getElementById('restaurant-image'), name: document.getElementById('restaurant-name'), cuisine: document.getElementById('restaurant-cuisine'), rating: document.getElementById('restaurant-rating'), price: document.getElementById('restaurant-price'), address: document.getElementById('restaurant-address'), prevPhotoBtn: document.getElementById('prev-photo'), nextPhotoBtn: document.getElementById('next-photo'), photoIndicators: document.getElementById('photo-indicators'), dislikeButton: document.getElementById('dislike-button'), likeButton: document.getElementById('like-button'), mapsLinkPlaceholder: document.getElementById('google-maps-link-placeholder') };
        const resultsUI = { likedCount: document.getElementById('liked-count'), sessionId: document.getElementById('session-id'), friendCodeInput: document.getElementById('friend-code'), findMatchesButton: document.getElementById('find-matches-button'), startOverButton: document.getElementById('start-over-button'), copyCodeButton: document.getElementById('copy-code-button'),
                         viewLikedButton: document.getElementById('view-liked-button'), likedListContainer: document.getElementById('liked-restaurants-list'),
                         shareLinkSection: document.getElementById('share-link-section'),
                         shareLinkInput: document.getElementById('share-link-input'),
                         copyLinkButton: document.getElementById('copy-link-button') };
        const matchesUI = { list: document.getElementById('matches-list'), startOverButton: document.getElementById('matches-start-over-button') };
        const sharedUI = { list: document.getElementById('shared-restaurants-list'), startOverButton: document.getElementById('shared-start-over-button'), sourceText: document.getElementById('shared-list-source') };
        const errorContainer = document.getElementById('error-container');

        let restaurants = [];
        let currentIndex = 0;
        let likedRestaurants = {};
        let sessionId = '';
        let userCoordinates = null;
        let autocomplete = null;
        let currentVisibleView = views.search;

        // --- Helper Functions ---
        function showView(viewToShow) { Object.values(views).forEach(view => { if (view !== viewToShow) view.classList.add('transition-hidden'); }); viewToShow.classList.remove('transition-hidden'); currentVisibleView = viewToShow; window.scrollTo(0, 0); }
        function showError(message) { errorContainer.textContent = message; errorContainer.classList.remove('hidden'); }
        function hideError() { errorContainer.classList.add('hidden'); errorContainer.textContent = ''; }
        function setLoadingText(text) { loadingText.textContent = text; }

        // --- Google Maps & Places API Functions ---
        function loadGoogleMapsScript() {
            if (document.getElementById('google-maps-script')) return;
            const script = document.createElement('script'); script.id = 'google-maps-script';
            const apiKey = "AIzaSyCHBWV_-CcYHftllY2aZ22SfSySw9PjqFo"; // Your key
            if (!apiKey || apiKey === "YOUR_GOOGLE_MAPS_API_KEY" || apiKey.length < 20) { console.error("Google Maps API Key missing/invalid!"); showError("Map services not configured."); locationInput.disabled = true; useLocationButton.disabled = true; searchButton.disabled = true; return; }
            script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places,geometry&callback=initMapServices`;
            script.async = true; script.defer = true;
            script.onerror = () => { console.error("Failed to load Google Maps script."); showError("Failed to load location services."); };
            document.head.appendChild(script);
        }
        window.initMapServices = function() { console.log("Google Maps API loaded."); initAutocomplete(); };
        function initAutocomplete() {
            if (typeof google === 'undefined' || !google.maps?.places?.Autocomplete) { console.error("Autocomplete library not ready."); showError("Location search failed."); return; }
            try {
                // Set up autocomplete with Singapore bias
                autocomplete = new google.maps.places.Autocomplete(locationInput, { 
                    types: ['geocode', 'establishment'], 
                    fields: ['geometry', 'name', 'formatted_address', 'place_id'], 
                    componentRestrictions: { country: ['sg'] } // Restrict to Singapore
                });
                
                // Append "Singapore" to the search query if not already present
                locationInput.addEventListener('input', function() {
                    const value = this.value.trim();
                    if (value && !value.toLowerCase().includes('singapore') && 
                        !value.startsWith("Current Location") && value.length > 3) {
                        // Only append when typing has paused for 1 second
                        if (this.searchTimer) clearTimeout(this.searchTimer);
                        this.searchTimer = setTimeout(() => {
                            const cursorPosition = this.selectionStart;
                            if (!this.value.toLowerCase().includes('singapore')) {
                                this.value = value + ', Singapore';
                                // Restore cursor position to where it was before appending
                                this.setSelectionRange(cursorPosition, cursorPosition);
                            }
                        }, 1000);
                    }
                });
                
                autocomplete.addListener('place_changed', () => {
                    const place = autocomplete.getPlace(); hideError();
                    if (!place.geometry?.location) { userCoordinates = null; return; }
                    userCoordinates = { lat: place.geometry.location.lat(), lng: place.geometry.location.lng() };
                    console.log("Place selected:", place.name); locationInput.value = place.formatted_address || place.name;
                }); console.log("Autocomplete initialized.");
            } catch (error) { console.error("Error initializing Autocomplete:", error); showError("Failed to init location search."); }
        }
        function getUserLocation() {
             if (!navigator.geolocation) { showError("Geolocation not supported."); return; }
             const btn = useLocationButton; btn.textContent = "Finding..."; btn.disabled = true; hideError();
             navigator.geolocation.getCurrentPosition( (pos) => {
                 userCoordinates = { lat: pos.coords.latitude, lng: pos.coords.longitude };
                 console.log("Geolocation:", userCoordinates); locationInput.value = `Current Location (${userCoordinates.lat.toFixed(4)}, ${userCoordinates.lng.toFixed(4)})`;
                 btn.textContent = "📍 My Location"; btn.disabled = false;
             }, (err) => {
                 console.error("Geolocation error:", err); let msg = "Could not get location."; switch(err.code){case 1:msg="Permission denied.";break; case 2:msg="Position unavailable.";break; case 3:msg="Timeout.";break;} showError(msg); userCoordinates = null; locationInput.value = ''; btn.textContent = "📍 My Location"; btn.disabled = false;
             }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
         }
        function fetchRestaurants() {
            let loadingMessage = "Finding food places...";
            if (highRatingFilter.checked && popularPlacesFilter.checked) {
                loadingMessage = "Finding highly-rated popular food places...";
            } else if (highRatingFilter.checked) {
                loadingMessage = "Finding highly-rated food places...";
            } else if (popularPlacesFilter.checked) {
                loadingMessage = "Finding popular food places...";
            }
            setLoadingText(loadingMessage);
            showView(views.loading); hideError();
            const locationText = locationInput.value.trim(), radius = parseInt(radiusSelect.value), priceLevel = priceLevelSelect.value, keyword = cuisineKeywordInput.value.trim();
            if (typeof google === 'undefined' || !google.maps?.places) { showError("Location services not ready."); showView(views.search); return; }
            if (userCoordinates) { performNearbySearch(userCoordinates, radius, keyword, priceLevel); }
            else if (locationText && !locationText.startsWith("Current Location")) {
                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ address: locationText }, (results, status) => {
                    if (status === 'OK' && results?.[0]?.geometry?.location) {
                        userCoordinates = { lat: results[0].geometry.location.lat(), lng: results[0].geometry.location.lng() };
                        performNearbySearch(userCoordinates, radius, keyword, priceLevel);
                    } else { showError(`Could not find "${locationText}".`); showView(views.search); }
                });
            } else { showError("Please provide a location."); showView(views.search); }
        }
        function performNearbySearch(coords, radius, keyword, priceLevel) {
            const placesService = new google.maps.places.PlacesService(document.createElement('div'));
            
            // Create an array of types to search for - restaurant, cafe, food, etc.
            const establishmentTypes = ['restaurant', 'cafe', 'meal_takeaway', 'meal_delivery', 'bakery', 'food'];
            
            // Create an array of promises to hold all the different search requests
            const searchPromises = establishmentTypes.map(type => {
                return new Promise(resolve => {
                    let request = {
                        location: new google.maps.LatLng(coords.lat, coords.lng),
                        radius: radius,
                        type: type
                    };
            if (keyword) request.keyword = keyword;
                    if (priceLevel) {
                        const price = parseInt(priceLevel);
                        request.minPriceLevel = price;
                        request.maxPriceLevel = price;
                    }
                    
                    console.log(`Places Request for ${type}:`, request);
                    
            placesService.nearbySearch(request, (results, status) => {
                        console.log(`Places Status for ${type}:`, status);
                if (status === google.maps.places.PlacesServiceStatus.OK && results?.length > 0) {
                            resolve(results);
                        } else {
                            resolve([]); // Return empty array if no results or error
                        }
                    });
                });
            });
            
            // Additional keyword search for hawker centers, food courts, etc.
            const keywordPromise = new Promise(resolve => {
                if (!keyword || keyword.toLowerCase().includes('hawker') || keyword.toLowerCase().includes('food court')) {
                    // Only add this search if no specific keyword is provided or if looking for hawkers
                    const hawkerRequest = {
                        location: new google.maps.LatLng(coords.lat, coords.lng),
                        radius: radius,
                        keyword: keyword || 'hawker center food court'
                    };
                    
                    if (priceLevel) {
                        const price = parseInt(priceLevel);
                        hawkerRequest.minPriceLevel = price;
                        hawkerRequest.maxPriceLevel = price;
                    }
                    
                    console.log("Hawker Center Request:", hawkerRequest);
                    
                    placesService.nearbySearch(hawkerRequest, (results, status) => {
                        console.log("Hawker Center Status:", status);
                if (status === google.maps.places.PlacesServiceStatus.OK && results?.length > 0) {
                            resolve(results);
                        } else {
                            resolve([]);
                        }
                    });
                } else {
                    resolve([]); // Skip this search if specific keyword provided
                }
            });
            
            // Combine all search promises
            const allPromises = [...searchPromises, keywordPromise];
            
            // Wait for all searches to complete, then combine and deduplicate results
            Promise.all(allPromises).then(resultsArrays => {
                // Flatten array of arrays and remove duplicates based on place_id
                const allPlaces = [];
                const placeIds = new Set();
                
                resultsArrays.flat().forEach(place => {
                    if (!placeIds.has(place.place_id)) {
                        placeIds.add(place.place_id);
                        allPlaces.push(place);
                    }
                });
                
                console.log("Total unique places found:", allPlaces.length);
                
                if (allPlaces.length > 0) {
                    const operational = allPlaces.filter(p => p.business_status === 'OPERATIONAL').slice(0, 20);
                    if (operational.length === 0) {
                        showError(`No operational food establishments found.`);
                        showView(views.search);
                        return;
                    }
                    console.log("Found", operational.length, "operational food establishments.");
                    processRestaurantResults(operational, keyword);
                } else {
                    showError(`No food establishments found${keyword ? ` for "${keyword}"` : ''}.`);
                    showView(views.search);
                }
            }).catch(error => {
                console.error("Error in searches:", error);
                showError("Error searching for food establishments.");
                showView(views.search);
            });
        }
        function getPlaceDetails(placeIds) {
            const placesService = new google.maps.places.PlacesService(document.createElement('div'));
            const promises = placeIds.map(id => new Promise(res => placesService.getDetails({ 
                placeId: id, 
                fields: [
                    'photos', 'name', 'reviews', 'opening_hours', 
                    'utc_offset_minutes', 'business_status', 
                    'user_ratings_total', 'website', 'formatted_phone_number'
                ],
                reviews_sort: 'relevance' // Request reviews sorted by relevance first
            }, (d, s) => {
                // Process reviews if available
                let reviews = [];
                if (s === google.maps.places.PlacesServiceStatus.OK && d?.reviews && d.reviews.length > 0) {
                    // First review is already most relevant (by Google's ranking)
                    const mostRelevant = d.reviews[0];
                    
                    // Sort the rest by date (most recent first)
                    const otherReviews = d.reviews.slice(1).sort((a, b) => 
                        new Date(b.time * 1000) - new Date(a.time * 1000)
                    );
                    
                    // Combine: most relevant first, then two most recent
                    reviews = [mostRelevant, ...otherReviews.slice(0, 2)];
                }
                
                // Check if the place is new (3 months or less)
                // We need to analyze all reviews and additional signals to determine if the place is truly new
                let isNew = false;
                
                if (s === google.maps.places.PlacesServiceStatus.OK) {
                    // Multiple signals to check if a restaurant is new
                    
                    // 1. Review count - new places typically have few reviews
                    const fewReviews = d.user_ratings_total && d.user_ratings_total < 15;
                    
                    // 2. Review dates - check if all reviews are recent
                    let allReviewsRecent = false;
                    let hasReviews = false;
                    
                    if (d.reviews && d.reviews.length > 0) {
                        hasReviews = true;
                        // Sort all reviews by date (oldest first)
                        const sortedReviews = [...d.reviews].sort((a, b) => 
                            new Date(a.time * 1000) - new Date(b.time * 1000)
                        );
                        
                        // Get the oldest review date
                        const oldestReviewDate = new Date(sortedReviews[0].time * 1000);
                        const threeMonthsAgo = new Date();
                        threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
                        
                        // Check if oldest review is less than 3 months old
                        allReviewsRecent = oldestReviewDate > threeMonthsAgo;
                        
                        // 3. Review text analysis - look for clues
                        const reviewText = d.reviews.map(r => r.text || '').join(' ').toLowerCase();
                        
                        // Phrases that suggest the place is NOT new
                        const notNewPhrases = [
                            'been here for years', 'been open for years', 'old favorite', 
                            'long time', 'year ago', 'years ago', 'was here last year', 
                            'returned after', 'used to be', 'always been', 'regular',
                            'again', 'back to', 'still good', 'still great', 'still the best',
                            'as usual', 'as always', 'reopened', 're-opened'
                        ];
                        
                        // Phrases that suggest the place IS new
                        const newPhrases = [
                            'just opened', 'newly opened', 'new place', 'new restaurant', 
                            'new opening', 'recent opening', 'grand opening', 'soft opening',
                            'opening week', 'first week', 'first day', 'first customers',
                            'recent addition', 'recently opened', 'brand new', 'newly established',
                            'only been open', 'month since opening', 'weeks since opening'
                        ];
                        
                        const hasNotNewPhrase = notNewPhrases.some(phrase => reviewText.includes(phrase));
                        const hasNewPhrase = newPhrases.some(phrase => reviewText.includes(phrase));
                        
                        // If we have strong signals in the review text, override other factors
                        if (hasNotNewPhrase) {
                            isNew = false;
                        } else if (hasNewPhrase) {
                            isNew = true;
                        } else {
                            // 4. Combine signals - only mark as new if both conditions are met
                            isNew = fewReviews && allReviewsRecent;
                        }
                    } else {
                        // No reviews might mean it's very new, but allow other signals to override
                        isNew = true;
                    }
                    
                    // Additional signal: Very low review count is a strong indicator of newness
                    // Override previous determination if review count is extremely low (3 or fewer)
                    if (d.user_ratings_total !== undefined && d.user_ratings_total <= 3) {
                        isNew = true;
                    } else if (d.user_ratings_total > 30) {
                        // Many reviews usually means established business
                        isNew = false;
                    }
                    
                    // Business status check - OPERATIONAL doesn't tell us much about age
                    // Most places don't have their opening date in the API
                }
                
                res({ 
                    placeId: id, 
                    photos: (s === google.maps.places.PlacesServiceStatus.OK && d?.photos) ? d.photos : [],
                    reviews: reviews,
                    isNew: isNew
                });
            })));
            return Promise.all(promises);
        }
        async function processRestaurantResults(results, searchKeyword) {
             try {
                 const placeIds = results.map(r => r.place_id); const details = await getPlaceDetails(placeIds);
                 const detailsMap = details.reduce((map, d) => { 
                     map[d.placeId] = {
                         photos: d.photos || [],
                         reviews: d.reviews || [],
                         isNew: d.isNew
                     }; 
                     return map; 
                 }, {});
                 restaurants = results.map(place => {
                     const placeDetails = detailsMap[place.place_id] || { photos: [], reviews: [], isNew: false };
                     const placePhotos = placeDetails.photos;
                     const photoUrls = placePhotos.slice(0, 5).map(p => p.getUrl ? p.getUrl({ maxWidth: 800, maxHeight: 600 }) : null).filter(url => url);
                     if (photoUrls.length === 0) { photoUrls.push("https://placehold.co/800x600/FF5864/white?text=No+Image"); }
                     let displayCuisine = searchKeyword ? searchKeyword.trim().toLowerCase().replace(/\b\w/g, l => l.toUpperCase()) : getCuisineFromTypes(place.types || []);
                     return { 
                         id: place.place_id, 
                         name: place.name || "Unnamed", 
                         address: place.vicinity || "Address unavailable", 
                         cuisine: displayCuisine, 
                         rating: place.rating ? `${place.rating}★ (${place.user_ratings_total || 0})` : "Not rated", 
                         ratingValue: place.rating || 0, // Add actual numeric rating for filtering
                         user_ratings_total: place.user_ratings_total || 0, // Store total rating count for filtering
                         priceLevel: place.price_level ?? 0, 
                         photoUrls, 
                         currentPhotoIndex: 0,
                         reviews: placeDetails.reviews || [],
                         isNew: placeDetails.isNew || false,
                         // Store coordinates for travel time calculation
                         coordinates: place.geometry && place.geometry.location ? {
                             lat: place.geometry.location.lat(),
                             lng: place.geometry.location.lng()
                         } : null,
                         // Initialize travel times property
                         travelTimes: null
                     };
                 });
                 
                 // Apply filters
                 // Filter by high rating if the option is checked
                 if (highRatingFilter.checked) {
                     restaurants = restaurants.filter(place => place.ratingValue >= 4.5);
                 }
                 
                 // Filter by popular places if the option is checked
                 if (popularPlacesFilter.checked) {
                     restaurants = restaurants.filter(place => place.ratingValue >= 4.2 && place.user_ratings_total >= 100);
                 }
                 
                 if (restaurants.length === 0) { showError('No food places found matching your criteria.'); showView(views.search); return; }
                 sessionId = generateSessionId(); saveSessionToFirebase();
                 currentIndex = 0; likedRestaurants = {};
                 updateRestaurantDisplay(); showView(views.swipe);
             } catch (error) { console.error("Error processing results:", error); showError("Error loading details."); showView(views.search); }
         }
        function getCuisineFromTypes(types) { 
            const typeMap = {
                'cafe': 'Cafe',
                'bar': 'Bar',
                'bakery': 'Bakery',
                'food': 'Food Stall',
                'meal_takeaway': 'Takeaway',
                'meal_delivery': 'Delivery'
            }; 
            const knownCuisines = ["Italian", "Chinese", "Japanese", "Mexican", "Indian", "Thai", "American", "French", "Vietnamese", "Korean", "Mediterranean", "Pizza", "Sushi", "Seafood", "Steakhouse"]; 
            for(const type of types){ 
                const fmt = type.replace(/_/g,' ').replace(/\b\w/g,l=>l.toUpperCase()); 
                if(knownCuisines.includes(fmt)) return fmt; 
                if(typeMap[type]) return typeMap[type]; 
            } 
            return types.includes('restaurant') ? 'Restaurant' : (types.includes('cafe') ? 'Cafe' : 'Food Place'); 
        }
        function createGoogleMapsLink(restaurant) { if (!restaurant) return null; let url; if (restaurant.id) { url = `https://www.google.com/maps/search/?api=1&query=Google&query_place_id=${restaurant.id}`; } else if (restaurant.name && restaurant.address) { const query = encodeURIComponent(`${restaurant.name}, ${restaurant.address}`); url = `https://www.google.com/maps/search/?api=1&query=${query}`; } else { return null; } const link = document.createElement('a'); link.href = url; link.textContent = "View on Google Maps ↗"; link.className = "google-maps-link"; link.target = "_blank"; link.rel = "noopener noreferrer"; return link; }

        // --- Travel Time Functions ---
        async function getTravelTimes(origin, destination) {
            if (!origin || !destination || typeof google === 'undefined' || !google.maps?.DistanceMatrixService) {
                return { driving: null, transit: null };
            }
            
            const service = new google.maps.DistanceMatrixService();
            
            try {
                // First get driving time
                const drivingResult = await new Promise((resolve, reject) => {
                    service.getDistanceMatrix({
                        origins: [origin],
                        destinations: [destination],
                        travelMode: google.maps.TravelMode.DRIVING,
                        unitSystem: google.maps.UnitSystem.METRIC
                    }, (response, status) => {
                        if (status === 'OK') {
                            resolve(response);
                        } else {
                            console.error("Driving time calculation failed:", status);
                            resolve(null);
                        }
                    });
                });
                
                // Then get transit time
                const transitResult = await new Promise((resolve, reject) => {
                    service.getDistanceMatrix({
                        origins: [origin],
                        destinations: [destination],
                        travelMode: google.maps.TravelMode.TRANSIT,
                        unitSystem: google.maps.UnitSystem.METRIC
                    }, (response, status) => {
                        if (status === 'OK') {
                            resolve(response);
                        } else {
                            console.error("Transit time calculation failed:", status);
                            resolve(null);
                        }
                    });
                });
                
                // Process results
                const drivingTime = drivingResult && 
                                    drivingResult.rows[0]?.elements[0]?.status === "OK" ? 
                                    drivingResult.rows[0].elements[0].duration.text : null;
                                    
                const transitTime = transitResult && 
                                    transitResult.rows[0]?.elements[0]?.status === "OK" ? 
                                    transitResult.rows[0].elements[0].duration.text : null;
                
                return { driving: drivingTime, transit: transitTime };
            } catch (error) {
                console.error("Error calculating travel times:", error);
                return { driving: null, transit: null };
            }
        }
        
        // Creates travel time elements for a restaurant
        function createTravelTimeElements(restaurant) {
            const container = document.createElement('div');
            container.className = 'travel-times';
            
            // Check if we've already calculated travel times for this restaurant
            if (restaurant.travelTimes) {
                console.log(`Using cached travel times for ${restaurant.name}`);
                // Use cached travel times
                displayTravelTimes(restaurant.travelTimes, container);
                return container;
            }
            
            if (!userCoordinates || !restaurant.coordinates) {
                return container; // Return empty container if no coordinates
            }
            
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'travel-time-loading';
            loadingDiv.textContent = 'Calculating travel times...';
            container.appendChild(loadingDiv);
            
            console.log(`Calculating new travel times for ${restaurant.name}`);
            
            // Start async calculation of travel times
            const origin = new google.maps.LatLng(userCoordinates.lat, userCoordinates.lng);
            const destination = new google.maps.LatLng(
                restaurant.coordinates.lat, 
                restaurant.coordinates.lng
            );
            
            getTravelTimes(origin, destination).then(times => {
                // Store the calculated times with the restaurant
                restaurant.travelTimes = times;
                console.log(`Travel times calculated and stored for ${restaurant.name}`);
                
                // Remove loading message
                container.removeChild(loadingDiv);
                
                // Display the travel times
                displayTravelTimes(times, container);
            }).catch(error => {
                console.error(`Travel time display error for ${restaurant.name}:`, error);
                loadingDiv.textContent = 'Unable to calculate travel times';
            });
            
            return container;
        }
        
        // Helper function to display travel times in a container
        function displayTravelTimes(times, container) {
            // Add driving time if available
            if (times.driving) {
                const drivingItem = document.createElement('div');
                drivingItem.className = 'travel-time-item';
                drivingItem.innerHTML = `<span class="travel-time-icon">🚗</span> ${times.driving}`;
                container.appendChild(drivingItem);
            }
            
            // Add transit time if available
            if (times.transit) {
                const transitItem = document.createElement('div');
                transitItem.className = 'travel-time-item';
                transitItem.innerHTML = `<span class="travel-time-icon">🚇</span> ${times.transit}`;
                container.appendChild(transitItem);
            }
            
            // If no times available, show message
            if (!times.driving && !times.transit) {
                const noDataDiv = document.createElement('div');
                noDataDiv.className = 'travel-time-item';
                noDataDiv.textContent = 'Travel time information unavailable';
                container.appendChild(noDataDiv);
            }
        }

        // --- Swipe UI Functions ---
        function updateRestaurantDisplay() {
            if (currentIndex >= restaurants.length) { showResultsView(); return; }
            const restaurant = restaurants[currentIndex];
            
            // Update counter and photo
            swipeUI.currentIndex.textContent = currentIndex + 1; 
            swipeUI.totalRestaurants.textContent = restaurants.length;
            restaurant.currentPhotoIndex = restaurant.currentPhotoIndex || 0; 
            swipeUI.image.src = restaurant.photoUrls[restaurant.currentPhotoIndex]; 
            swipeUI.image.alt = restaurant.name;
            
            // Update photo indicators
            updatePhotoIndicators(restaurant);
            const showNav = restaurant.photoUrls.length > 1; 
            swipeUI.prevPhotoBtn.style.display = showNav ? 'flex' : 'none'; 
            swipeUI.nextPhotoBtn.style.display = showNav ? 'flex' : 'none'; 
            swipeUI.photoIndicators.style.display = showNav ? 'flex' : 'none';
            
            // Update restaurant information
            swipeUI.name.textContent = restaurant.name;
            swipeUI.rating.innerHTML = `<span class="meta-icon">⭐</span> ${restaurant.rating}`;
            swipeUI.price.innerHTML = `<span class="meta-icon">💰</span> ${restaurant.priceLevel > 0 ? '$'.repeat(restaurant.priceLevel) : 'N/A'}`;
            swipeUI.address.innerHTML = `<span class="meta-icon">📍</span> ${restaurant.address}`;
            
            // Clear and rebuild the info body
            swipeUI.mapsLinkPlaceholder.innerHTML = '';
            
            // Add Google Maps link
            const mapsLink = createGoogleMapsLink(restaurant); 
            if (mapsLink) swipeUI.mapsLinkPlaceholder.appendChild(mapsLink);
            
            // Add travel time information if coordinates are available
            if (userCoordinates && restaurant.coordinates) {
                const travelTimeElement = createTravelTimeElements(restaurant);
                swipeUI.mapsLinkPlaceholder.appendChild(travelTimeElement);
            }
            
            // Add NEW sticker if restaurant is new
            const photoContainer = document.querySelector('.photo-container');
            const existingSticker = photoContainer.querySelector('.new-sticker');
            if (existingSticker) {
                photoContainer.removeChild(existingSticker);
            }
            
            if (restaurant.isNew) {
                const newSticker = document.createElement('div');
                newSticker.className = 'new-sticker';
                newSticker.textContent = 'NEW';
                photoContainer.appendChild(newSticker);
            }
            
            // Add reviews section
            if (restaurant.reviews && restaurant.reviews.length > 0) {
                const reviewsContainer = document.createElement('div');
                reviewsContainer.className = 'reviews-section';
                
                const reviewsTitle = document.createElement('h3');
                reviewsTitle.className = 'reviews-title';
                reviewsTitle.textContent = 'Reviews';
                reviewsContainer.appendChild(reviewsTitle);
                
                restaurant.reviews.forEach((review, index) => {
                    const reviewElement = document.createElement('div');
                    reviewElement.className = 'review-item';
                    
                    // Format the date
                    let dateText = 'Unknown date';
                    if (review.time) {
                        const reviewDate = new Date(review.time * 1000);
                        dateText = reviewDate.toLocaleDateString();
                    }
                    
                    const authorDiv = document.createElement('div');
                    authorDiv.className = 'review-author';
                    
                    // Add a label for the first review to indicate it's most relevant
                    const reviewType = index === 0 ? 
                        '<span class="review-type">Most Relevant</span>' : 
                        '<span class="review-type">Recent</span>';
                    
                    authorDiv.innerHTML = `<div><strong>${review.author_name || 'Anonymous'}</strong> ${reviewType}</div><div><span class="review-star">${review.rating}★</span> <span class="review-date">${dateText}</span></div>`;
                    
                    const textDiv = document.createElement('div');
                    textDiv.className = 'review-text';
                    
                    // Handle long reviews with truncation and expansion
                    const fullText = review.text || 'No review text';
                    const isTruncated = fullText.length > 100;
                    
                    if (isTruncated) {
                        // Add truncated class and store full text as data attribute
                        textDiv.className = 'review-text truncated';
                        textDiv.setAttribute('data-full-text', fullText);
                        textDiv.textContent = fullText.substring(0, 100);
                        
                        // Add click handler to expand
                        textDiv.addEventListener('click', function() {
                            if (this.classList.contains('truncated')) {
                                this.textContent = this.getAttribute('data-full-text');
                                this.classList.remove('truncated');
                                this.classList.add('expanded');
                            } else {
                                this.textContent = this.getAttribute('data-full-text').substring(0, 100);
                                this.classList.remove('expanded');
                                this.classList.add('truncated');
                            }
                        });
                    } else {
                        textDiv.textContent = fullText;
                    }
                    
                    reviewElement.appendChild(authorDiv);
                    reviewElement.appendChild(textDiv);
                    
                    reviewsContainer.appendChild(reviewElement);
                });
                
                swipeUI.mapsLinkPlaceholder.appendChild(reviewsContainer);
            }
        }
        function changePhoto(direction) { if (currentIndex >= restaurants.length) return; const r=restaurants[currentIndex]; const num=r.photoUrls.length; if(num<=1)return; r.currentPhotoIndex=(r.currentPhotoIndex+direction+num)%num; updateRestaurantDisplay(); }
        function handleSwipe(liked) {
            if (currentIndex >= restaurants.length) return;
            const restaurantId = restaurants[currentIndex].id;
            if (liked) { likedRestaurants[restaurantId] = true; console.log("Liked:", restaurants[currentIndex].name); }
             else { console.log("Disliked:", restaurants[currentIndex].name); }
            saveLikesToFirebase();
            currentIndex++;
            if (currentIndex < restaurants.length) { updateRestaurantDisplay(); }
             else { showResultsView(); }
        }

        // --- Results & Matching Functions ---
        function showResultsView() {
            const likedCount = Object.keys(likedRestaurants).length;
            resultsUI.likedCount.textContent = likedCount;
            resultsUI.sessionId.textContent = sessionId;
            resultsUI.friendCodeInput.value = '';
            populateLikedRestaurantsList();
            resultsUI.likedListContainer.classList.add('hidden');
            resultsUI.viewLikedButton.textContent = 'View My Liked Food Places';
            resultsUI.viewLikedButton.style.display = likedCount > 0 ? 'block' : 'none';
            generateShareLink();
            resultsUI.shareLinkSection.style.display = likedCount > 0 ? 'block' : 'none';
            showView(views.results);
        }
        function populateLikedRestaurantsList() {
            const likedListContainer = resultsUI.likedListContainer;
            likedListContainer.innerHTML = '';
            const myLikedIds = Object.keys(likedRestaurants);
            const likedRestaurantDetails = restaurants.filter(r => myLikedIds.includes(r.id));
            if (likedRestaurantDetails.length > 0) {
                 const listTitle = document.createElement('h3'); listTitle.style.padding = '15px 15px 0 15px'; listTitle.style.marginBottom = '10px'; listTitle.textContent = "Your Liked Food Places:"; listTitle.style.textAlign = 'center'; likedListContainer.appendChild(listTitle);
                likedRestaurantDetails.forEach(r => { createRestaurantItemElement(r, likedListContainer); });
            } else { likedListContainer.innerHTML = '<p style="text-align:center; padding:20px;">You haven\'t liked any food places yet.</p>'; }
        }
        function findMatches() {
            const friendCode = resultsUI.friendCodeInput.value.trim().toUpperCase();
            if (!friendCode) { showError('Please enter your friend\'s code.'); return; }
            if (friendCode === sessionId) { showError('You cannot match with your own code!'); return; }
            setLoadingText("Finding matches..."); // Update loading text
            showView(views.loading); hideError();
            if (typeof firebase === 'undefined' || !firebase.apps.length) { console.warn("Firebase not init."); showError("Matching unavailable."); setTimeout(() => { displayMatches([]); showView(views.matches); }, 1500); return; }
            firebase.database().ref('sessions/' + friendCode).once('value').then(snap => {
                const friendData = snap.val();
                if (!friendData) { showError(`Friend code "${friendCode}" not found.`); showView(views.results); return; }
                const friendLikes=friendData.likes||{}; const friendLikedIds=Object.keys(friendLikes); const myLikedIds=Object.keys(likedRestaurants);
                const matchedIds=myLikedIds.filter(id=>friendLikedIds.includes(id));
                const friendRestaurantsData=friendData.restaurants||[]; const friendMap=friendRestaurantsData.reduce((map,r)=>{map[r.id]=r;return map;},{});
                const myMap=restaurants.reduce((map,r)=>{map[r.id]=r;return map;},{}); // Use current session data as fallback
                const matchedRestaurants=matchedIds.map(id=>friendMap[id]||myMap[id]).filter(r=>r); // Get details, ensuring photos are available from friendMap
                console.log("Matches found:", matchedRestaurants); displayMatches(matchedRestaurants);
            }).catch(err => { console.error("Match error:", err); showError('Could not get friend data.'); showView(views.results); });
        }
        function displayMatches(matchedRestaurants) {
            const matchesListContainer = matchesUI.list;
            matchesListContainer.innerHTML = '';
            if (matchedRestaurants.length > 0) {
                matchedRestaurants.forEach(r => { createRestaurantItemElement(r, matchesListContainer); });
            } else { matchesListContainer.innerHTML = '<p style="text-align:center; padding:20px;">No common matches found!</p>'; }
            showView(views.matches);
        }
        function createRestaurantItemElement(r, container) {
            const item = document.createElement('div');
            item.className = 'restaurant-item';
            
            // Get image URL
            const imageUrl = (r.photoUrls && r.photoUrls.length > 0) ? 
                r.photoUrls[0] : "https://placehold.co/160x160/f0f0f0/999?text=No+Image";
                
            // Create price display
            const priceDisplay = r.priceLevel > 0 ? '$'.repeat(r.priceLevel) : 'N/A';
            
            // Create item structure
            const itemImage = document.createElement('img');
            itemImage.src = imageUrl;
            itemImage.alt = r.name;
            itemImage.className = 'restaurant-item-image';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'restaurant-item-content';
            
            // Create title and basic info
            const nameElement = document.createElement('h3');
            nameElement.textContent = r.name;
            
            const metaRow = document.createElement('div');
            metaRow.className = 'meta-row';
            
            // Add rating and price
            metaRow.innerHTML = `
                <div class="meta-item"><span class="meta-icon">⭐</span> ${r.rating}</div>
                <div class="meta-item price-level"><span class="meta-icon">💰</span> ${priceDisplay}</div>
            `;
            
            // Create address
            const addressElement = document.createElement('p');
            addressElement.innerHTML = `<span class="meta-icon">📍</span> ${r.address}`;
            
            // Add elements to content div
            contentDiv.appendChild(nameElement);
            contentDiv.appendChild(metaRow);
            contentDiv.appendChild(addressElement);
            
            // Create maps link and travel times row
            const mapsRow = document.createElement('div');
            mapsRow.style.display = 'flex';
            mapsRow.style.alignItems = 'center';
            mapsRow.style.marginTop = '4px';
            mapsRow.style.marginBottom = '4px';
            
            // Add maps link
            const mapsLink = createGoogleMapsLink(r);
            if (mapsLink) { 
                mapsLink.style.marginRight = '10px';
                mapsRow.appendChild(mapsLink);
            }
            
            // Add travel times inline with maps link
            if (userCoordinates && r.coordinates) {
                const travelTimesElement = document.createElement('div');
                travelTimesElement.className = 'travel-times-compact';
                travelTimesElement.style.display = 'flex';
                travelTimesElement.style.flexWrap = 'nowrap';
                
                // Add travel times if available
                if (r.travelTimes) {
                    // Car time
                    if (r.travelTimes.driving) {
                        const drivingItem = document.createElement('div');
                        drivingItem.className = 'travel-time-item';
                        drivingItem.innerHTML = `<span class="travel-time-icon">🚗</span> ${r.travelTimes.driving}`;
                        travelTimesElement.appendChild(drivingItem);
                    }
                    
                    // Transit time
                    if (r.travelTimes.transit) {
                        const transitItem = document.createElement('div');
                        transitItem.className = 'travel-time-item';
                        transitItem.innerHTML = `<span class="travel-time-icon">🚇</span> ${r.travelTimes.transit}`;
                        travelTimesElement.appendChild(transitItem);
                    }
                    
                    // If no times available, calculate them
                    if (!r.travelTimes.driving && !r.travelTimes.transit) {
                        const loadingDiv = document.createElement('div');
                        loadingDiv.className = 'travel-time-item';
                        loadingDiv.textContent = 'Calculating...';
                        travelTimesElement.appendChild(loadingDiv);
                        
                        // Start async calculation of travel times
                        const origin = new google.maps.LatLng(userCoordinates.lat, userCoordinates.lng);
                        const destination = new google.maps.LatLng(
                            r.coordinates.lat, 
                            r.coordinates.lng
                        );
                        
                        getTravelTimes(origin, destination).then(times => {
                            // Store the calculated times with the restaurant
                            r.travelTimes = times;
                            
                            // Clear and update the display
                            travelTimesElement.innerHTML = '';
                            
                            if (times.driving) {
                                const drivingItem = document.createElement('div');
                                drivingItem.className = 'travel-time-item';
                                drivingItem.innerHTML = `<span class="travel-time-icon">🚗</span> ${times.driving}`;
                                travelTimesElement.appendChild(drivingItem);
                            }
                            
                            if (times.transit) {
                                const transitItem = document.createElement('div');
                                transitItem.className = 'travel-time-item';
                                transitItem.innerHTML = `<span class="travel-time-icon">🚇</span> ${times.transit}`;
                                travelTimesElement.appendChild(transitItem);
                            }
                            
                            if (!times.driving && !times.transit) {
                                const noDataDiv = document.createElement('div');
                                noDataDiv.className = 'travel-time-item';
                                noDataDiv.textContent = 'N/A';
                                travelTimesElement.appendChild(noDataDiv);
                            }
                        });
                    }
                } else {
                    // Initialize calculation if no travel times are stored
                    const loadingDiv = document.createElement('div');
                    loadingDiv.className = 'travel-time-item';
                    loadingDiv.textContent = 'Calculating...';
                    travelTimesElement.appendChild(loadingDiv);
                    
                    // Start async calculation
                    const origin = new google.maps.LatLng(userCoordinates.lat, userCoordinates.lng);
                    const destination = new google.maps.LatLng(
                        r.coordinates.lat, 
                        r.coordinates.lng
                    );
                    
                    getTravelTimes(origin, destination).then(times => {
                        // Store the calculated times
                        r.travelTimes = times;
                        
                        // Clear and update
                        travelTimesElement.innerHTML = '';
                        
                        if (times.driving) {
                            const drivingItem = document.createElement('div');
                            drivingItem.className = 'travel-time-item';
                            drivingItem.innerHTML = `<span class="travel-time-icon">🚗</span> ${times.driving}`;
                            travelTimesElement.appendChild(drivingItem);
                        }
                        
                        if (times.transit) {
                            const transitItem = document.createElement('div');
                            transitItem.className = 'travel-time-item';
                            transitItem.innerHTML = `<span class="travel-time-icon">🚇</span> ${times.transit}`;
                            travelTimesElement.appendChild(transitItem);
                        }
                        
                        if (!times.driving && !times.transit) {
                            const noDataDiv = document.createElement('div');
                            noDataDiv.className = 'travel-time-item';
                            noDataDiv.textContent = 'N/A';
                            travelTimesElement.appendChild(noDataDiv);
                        }
                    });
                }
                
                mapsRow.appendChild(travelTimesElement);
            }
            
            contentDiv.appendChild(mapsRow);
            
            // Add a review if available - now full width
            if (r.reviews && r.reviews.length > 0) {
                const review = r.reviews[0]; // Use most relevant review
                
                const reviewDiv = document.createElement('div');
                reviewDiv.className = 'review-item';
                reviewDiv.style.marginTop = '8px';
                
                // Format date
                let dateText = 'Unknown date';
                if (review.time) {
                    const reviewDate = new Date(review.time * 1000);
                    dateText = reviewDate.toLocaleDateString();
                }
                
                // Create review header
                const reviewHeader = document.createElement('div');
                reviewHeader.className = 'review-author';
                reviewHeader.innerHTML = `
                    <div><strong>Top Review</strong></div>
                    <div><span class="review-star">${review.rating}★</span> <span class="review-date">${dateText}</span></div>
                `;
                
                // Create review text
                const reviewText = document.createElement('div');
                reviewText.className = 'review-text';
                
                // Handle long reviews
                const fullText = review.text || 'No review text';
                const isTruncated = fullText.length > 100;
                
                if (isTruncated) {
                    reviewText.className = 'review-text truncated';
                    reviewText.setAttribute('data-full-text', fullText);
                    reviewText.textContent = fullText.substring(0, 100);
                    
                    reviewText.addEventListener('click', function() {
                        if (this.classList.contains('truncated')) {
                            this.textContent = this.getAttribute('data-full-text');
                            this.classList.remove('truncated');
                            this.classList.add('expanded');
                        } else {
                            this.textContent = this.getAttribute('data-full-text').substring(0, 100);
                            this.classList.remove('expanded');
                            this.classList.add('truncated');
                        }
                    });
                } else {
                    reviewText.textContent = fullText;
                }
                
                reviewDiv.appendChild(reviewHeader);
                reviewDiv.appendChild(reviewText);
                contentDiv.appendChild(reviewDiv);
            }
            
            // Create NEW badge if applicable
            if (r.isNew) {
                const imageWrapper = document.createElement('div');
                imageWrapper.style.position = 'relative';
                
                const newSticker = document.createElement('div');
                newSticker.className = 'new-sticker';
                newSticker.textContent = 'NEW';
                newSticker.style.top = '0';
                newSticker.style.right = '0';
                newSticker.style.fontSize = '10px';
                newSticker.style.padding = '3px 6px';
                
                imageWrapper.appendChild(itemImage);
                imageWrapper.appendChild(newSticker);
                
                // Add elements to container
                item.appendChild(imageWrapper);
            } else {
                item.appendChild(itemImage);
            }
            
            item.appendChild(contentDiv);
            container.appendChild(item);
        }

        // --- Sharing Functions ---
        function generateShareLink() {
            if (!sessionId) { resultsUI.shareLinkInput.value = 'Error: No session ID.'; resultsUI.copyLinkButton.disabled = true; return; }
            const baseUrl = window.location.origin + window.location.pathname; const shareUrl = `${baseUrl}?share=${sessionId}`;
            resultsUI.shareLinkInput.value = shareUrl; resultsUI.copyLinkButton.disabled = false;
        }
        function copyShareLink() {
            const link = resultsUI.shareLinkInput.value; if (!link || !navigator.clipboard) { showError("Cannot copy link. Try selecting manually."); return; }
            navigator.clipboard.writeText(link).then(() => { const originalText = resultsUI.copyLinkButton.textContent; resultsUI.copyLinkButton.textContent = '✅'; setTimeout(() => { resultsUI.copyLinkButton.textContent = '📋'; }, 1500); }).catch(err => { console.error('Failed to copy share link:', err); showError("Failed to copy link automatically."); });
        }
        async function handleSharedLink(sharedSessionId) {
             console.log("Handling shared link for session:", sharedSessionId); setLoadingText("Loading shared list..."); showView(views.loading); hideError();
             if (typeof firebase === 'undefined' || !firebase.apps.length) { showError("Cannot load shared list: Connection error."); sharedUI.list.innerHTML = '<p class="error-message">Cannot load shared list: Connection error.</p>'; showView(views.shared); return; }
             try {
                 const sessionData = await fetchSharedSessionData(sharedSessionId);
                 if (!sessionData) { showError(`Shared list "${sharedSessionId}" not found or has expired.`); sharedUI.list.innerHTML = `<p class="error-message">Shared list "${sharedSessionId}" not found or has expired.</p>`; showView(views.shared); return; }
                 const sharedLikes = sessionData.likes || {}; const sharedLikedIds = Object.keys(sharedLikes); const sharedRestaurants = sessionData.restaurants || [];
                 if (sharedLikedIds.length === 0 || sharedRestaurants.length === 0) { sharedUI.list.innerHTML = '<p style="text-align:center; padding:20px;">This shared list is empty.</p>'; showView(views.shared); return; }
                 const likedRestaurantDetails = sharedRestaurants.filter(r => sharedLikedIds.includes(r.id));
                 displaySharedRestaurants(likedRestaurantDetails);
             } catch (error) { console.error("Error fetching shared session:", error); showError("Could not load the shared list."); sharedUI.list.innerHTML = `<p class="error-message">Could not load the shared list.</p>`; showView(views.shared); }
         }
         function fetchSharedSessionData(sessionIdToFetch) { if (!sessionIdToFetch) return Promise.resolve(null); return firebase.database().ref('sessions/' + sessionIdToFetch).once('value').then(snapshot => snapshot.val()); }
         function displaySharedRestaurants(sharedRestaurantList) {
            const container = sharedUI.list; container.innerHTML = '';
            if (sharedRestaurantList.length > 0) { sharedRestaurantList.forEach(r => { createRestaurantItemElement(r, container); }); }
            else { container.innerHTML = '<p style="text-align:center; padding:20px;">This shared list is empty or could not be loaded.</p>'; }
            sharedUI.sourceText.textContent = `Viewing a shared list`; showView(views.shared);
         }

        // --- Firebase Integration ---
        function generateSessionId() { return Math.random().toString(36).substring(2, 10).toUpperCase(); }
        function saveSessionToFirebase() {
            if(typeof firebase==='undefined'||!firebase.apps.length||!sessionId)return;
            const restaurantsToSave = restaurants.map(r => ({ 
                id: r.id, 
                name: r.name, 
                address: r.address, 
                cuisine: r.cuisine, 
                rating: r.rating, 
                priceLevel: r.priceLevel, 
                photoUrls: (r.photoUrls && r.photoUrls.length > 0) ? [r.photoUrls[0]] : [],
                reviews: r.reviews || [],
                isNew: r.isNew || false,
                coordinates: r.coordinates || null,
                travelTimes: r.travelTimes || null
            }));
            const sessionData = { restaurants: restaurantsToSave, timestamp: firebase.database.ServerValue.TIMESTAMP, likes: {} };
            firebase.database().ref('sessions/'+sessionId).set(sessionData).then(() => console.log("Session saved:", sessionId)).catch(e=>console.error("Session save error:",e));
        }
        function saveLikesToFirebase() {
            if(typeof firebase==='undefined'||!firebase.apps.length||!sessionId)return;
            firebase.database().ref('sessions/'+sessionId+'/likes').set(likedRestaurants).then(() => console.log("Likes updated for:", sessionId)).catch(e=>console.error("Likes update error:",e));
        }
        function initializeFirebase() {
            if(typeof firebase==='undefined'||typeof firebase.initializeApp==='undefined'){console.warn("Firebase SDK not ready.");return;}
            try{
                 const cfg={apiKey:"AIzaSyDauSN6vXVeflYHYdx54hIsXWeTxp-CarM",authDomain:"restaurant-finder-36e61.firebaseapp.com",databaseURL:"https://restaurant-finder-36e61-default-rtdb.asia-southeast1.firebasedatabase.app",projectId:"restaurant-finder-36e61",storageBucket:"restaurant-finder-36e61.appspot.com",messagingSenderId:"266887715200",appId:"1:266887715200:web:6c68d924d7596cdfb44965",measurementId:"G-TD5GNXZZMN"};
                 if (!firebase.apps.length) {firebase.initializeApp(cfg);console.log("Firebase initialized.");}
                 else {console.log("Firebase already initialized.");}
            }catch(e){console.error("Firebase init error:",e);showError("Sharing unavailable."); resultsUI.findMatchesButton.disabled = true; resultsUI.copyCodeButton.disabled = true; resultsUI.copyLinkButton.disabled = true;}
        }

        // --- Utility & Event Listeners ---
        function resetApp() {
            locationInput.value=''; radiusSelect.value='2000'; priceLevelSelect.value=''; cuisineKeywordInput.value=''; resultsUI.friendCodeInput.value='';
            highRatingFilter.checked = false; // Reset the high-rating filter
            popularPlacesFilter.checked = false; // Reset the popular places filter
            restaurants=[]; currentIndex=0; likedRestaurants={}; sessionId=''; userCoordinates=null;
            resultsUI.likedListContainer.innerHTML = ''; resultsUI.likedListContainer.classList.add('hidden');
            resultsUI.viewLikedButton.textContent = 'View My Liked Food Places';
            resultsUI.shareLinkInput.value = ''; resultsUI.copyLinkButton.disabled = true;
            matchesUI.list.innerHTML = ''; sharedUI.list.innerHTML = '';
            hideError();
            // Ensure URL is cleaned up if resetting from a shared link view
            if (window.location.search.includes('share=')) {
                window.history.replaceState({}, document.title, window.location.pathname); // Remove query param
            }
            showView(views.search); console.log("App reset.");
        }
        function copySessionId() {
             const code=resultsUI.sessionId.textContent; if(!code||code==='CODE'||!navigator.clipboard){showError("Copy failed.");return;}
             navigator.clipboard.writeText(code).then(()=>{const t=resultsUI.copyCodeButton.textContent;resultsUI.copyCodeButton.textContent='✅';setTimeout(()=>{resultsUI.copyCodeButton.textContent='📋';},1500);}).catch(err=>{console.error('Copy failed:',err);showError("Copy failed.");});
        }

        // --- Swipe Gesture Handling ---
        let touchStartX = 0;
        let touchStartY = 0;
        let touchDeltaX = 0;
        let touchDeltaY = 0;
        let isSwiping = false;
        let swipeDetectionTimer = null;
        let isScrolling = false;
        const SWIPE_THRESHOLD = 100; // Medium sensitivity - was 120 (too high), was 80 (too low)
        const SCROLL_THRESHOLD = 15; // Slightly increased to better detect intentional scrolling
        
        function initSwipeGestures() {
            const card = document.querySelector('.restaurant-card');
            const likeOverlay = document.querySelector('.swipe-like-overlay');
            const dislikeOverlay = document.querySelector('.swipe-dislike-overlay');
            const infoBody = card.querySelector('.restaurant-info-body');
            
            // Touch start
            card.addEventListener('touchstart', function(e) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchDeltaX = 0;
                touchDeltaY = 0;
                
                // Don't immediately start swiping - wait to see if it's a scroll
                isScrolling = false;
                isSwiping = false;
                
                // Clear any existing timer
                if (swipeDetectionTimer) {
                    clearTimeout(swipeDetectionTimer);
                }
                
                // Set a timer to delay swipe detection
                swipeDetectionTimer = setTimeout(() => {
                    // Only enable swiping if we're not scrolling vertically
                    if (!isScrolling) {
                        isSwiping = true;
                    }
                }, 70); // Reduced from 100ms to 70ms for more responsive swiping
            }, { passive: true });
            
            // Touch move
            card.addEventListener('touchmove', function(e) {
                touchDeltaX = e.touches[0].clientX - touchStartX;
                touchDeltaY = e.touches[0].clientY - touchStartY;
                
                // Check if the user is scrolling vertically
                if (Math.abs(touchDeltaY) > SCROLL_THRESHOLD && !isSwiping) {
                    isScrolling = true;
                    // Cancel the swipe detection once we know we're scrolling
                    if (swipeDetectionTimer) {
                        clearTimeout(swipeDetectionTimer);
                        swipeDetectionTimer = null;
                    }
                }
                
                // Only handle horizontal swipes if we're not scrolling
                if (isSwiping && !isScrolling) {
                    // Apply transform based on swipe direction
                    if (touchDeltaX > 20) { // Reduced from 30 to 20 for faster visual feedback
                        // Swiping right (like)
                        card.classList.add('swiping-right');
                        card.classList.remove('swiping-left');
                        likeOverlay.style.opacity = Math.min(touchDeltaX / (SWIPE_THRESHOLD * 1.5), 0.8); // Reduced multiplier for faster visual feedback
                        dislikeOverlay.style.opacity = 0;
                    } else if (touchDeltaX < -20) { // Reduced from -30 to -20 for faster visual feedback
                        // Swiping left (dislike)
                        card.classList.add('swiping-left');
                        card.classList.remove('swiping-right');
                        dislikeOverlay.style.opacity = Math.min(Math.abs(touchDeltaX) / (SWIPE_THRESHOLD * 1.5), 0.8); // Reduced multiplier for faster visual feedback
                        likeOverlay.style.opacity = 0;
                    } else {
                        // No movement yet
                        card.classList.remove('swiping-left', 'swiping-right');
                        likeOverlay.style.opacity = 0;
                        dislikeOverlay.style.opacity = 0;
                    }
                }
            }, { passive: true });
            
            // Touch end
            card.addEventListener('touchend', function() {
                // Clear the timer if it's still active
                if (swipeDetectionTimer) {
                    clearTimeout(swipeDetectionTimer);
                    swipeDetectionTimer = null;
                }
                
                // Only trigger swipe actions if we were swiping and not scrolling
                if (isSwiping && !isScrolling) {
                    if (touchDeltaX > SWIPE_THRESHOLD) {
                        // Swipe right completed - Like
                        handleSwipe(true);
                    } else if (touchDeltaX < -SWIPE_THRESHOLD) {
                        // Swipe left completed - Dislike
                        handleSwipe(false);
                    }
                }
                
                // Reset state and appearance
                resetSwipeState();
            });
            
            // Touch cancel
            card.addEventListener('touchcancel', resetSwipeState);
        }
        
        function resetSwipeState() {
            const card = document.querySelector('.restaurant-card');
            const likeOverlay = document.querySelector('.swipe-like-overlay');
            const dislikeOverlay = document.querySelector('.swipe-dislike-overlay');
            
            isSwiping = false;
            isScrolling = false;
            if (swipeDetectionTimer) {
                clearTimeout(swipeDetectionTimer);
                swipeDetectionTimer = null;
            }
            card.classList.remove('swiping-left', 'swiping-right');
            likeOverlay.style.opacity = 0;
            dislikeOverlay.style.opacity = 0;
        }

        window.swipeUI = swipeUI; window.resultsUI = resultsUI; window.matchesUI = matchesUI; window.sharedUI = sharedUI;

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', function(){
            // Page setup
            setTimeout(initializeFirebase, 500);
            loadGoogleMapsScript();
            
            // Search view events
            searchForm.addEventListener('submit', function(e) { e.preventDefault(); fetchRestaurants(); });
            useLocationButton.addEventListener('click', getUserLocation);
            
            // Swipe view events
            swipeUI.prevPhotoBtn.addEventListener('click', showPreviousPhoto);
            swipeUI.nextPhotoBtn.addEventListener('click', showNextPhoto);
            swipeUI.dislikeButton.addEventListener('click', () => handleSwipe(false));
            swipeUI.likeButton.addEventListener('click', () => handleSwipe(true));
            
            // Initialize swipe gestures when entering swipe view
            // We need to re-initialize after each view change to capture the current card
            views.swipe.addEventListener('transitionend', function(e) {
                if (e.target === views.swipe && !views.swipe.classList.contains('transition-hidden')) {
                    // Only initialize when swipe view becomes visible
                    setTimeout(initSwipeGestures, 100); // Short delay to ensure DOM is ready
                }
            });
            
            // Initialize immediately if swipe view is already visible
            if (!views.swipe.classList.contains('transition-hidden')) {
                setTimeout(initSwipeGestures, 100);
            }
            
            // Results view events
            resultsUI.findMatchesButton.addEventListener('click', findMatches);
            resultsUI.startOverButton.addEventListener('click', resetApp);
            resultsUI.copyCodeButton.addEventListener('click', copySessionId);
            resultsUI.sessionId.addEventListener('click', () => { 
                if (resultsUI.sessionId.textContent !== 'CODE') { 
                    window.getSelection().selectAllChildren(resultsUI.sessionId); 
                }
            });
            resultsUI.viewLikedButton.addEventListener('click', () => { 
                const isHidden = resultsUI.likedListContainer.classList.toggle('hidden'); 
                resultsUI.viewLikedButton.textContent = isHidden ? 'View My Liked Food Places' : 'Hide My Liked Food Places'; 
            });
            resultsUI.copyLinkButton.addEventListener('click', copyShareLink);
            
            // Other view events
            matchesUI.startOverButton.addEventListener('click', resetApp);
            sharedUI.startOverButton.addEventListener('click', resetApp);
            
            // Check for shared link params
            const urlParams = new URLSearchParams(window.location.search);
            const shareId = urlParams.get('share');
            
            if (shareId) {
                // If share ID exists, prepare to handle it after Firebase is ready
                setLoadingText("Loading shared list...");
                showView(views.loading); // Show loading early
                
                const firebaseInitInterval = setInterval(() => {
                    // Check if Firebase is initialized
                    if (typeof firebase !== 'undefined' && firebase.apps.length > 0 && firebase.database()) {
                        clearInterval(firebaseInitInterval);
                        console.log("Firebase ready, handling shared link...");
                        handleSharedLink(shareId); // Handle the link AFTER Firebase is ready
                    }
                }, 150); // Check slightly less frequently
                
                // Timeout safeguard in case Firebase never loads/initializes
                setTimeout(() => {
                    // Check if we are still stuck on loading or haven't transitioned to shared view
                    if(currentVisibleView === views.loading || currentVisibleView !== views.shared){
                        clearInterval(firebaseInitInterval);
                        console.error("Timeout waiting for Firebase initialization for shared link.");
                        showError("Failed to initialize services to load shared list in time.");
                        // Decide on a fallback view - Resetting is usually safest
                        resetApp(); // Reset state and show search view
                    }
                }, 10000); // 10 second timeout
            } else {
                // Normal startup sequence: Just show the search view
                showView(views.search);
            }
        });

        function showPreviousPhoto() {
            if (!restaurants[currentIndex]) return;
            const r = restaurants[currentIndex];
            if (!r.photoUrls || r.photoUrls.length <= 1) return;
            r.currentPhotoIndex = (r.currentPhotoIndex - 1 + r.photoUrls.length) % r.photoUrls.length;
            swipeUI.image.src = r.photoUrls[r.currentPhotoIndex];
            
            // Only update photo indicators, don't recreate travel times
            updatePhotoIndicators(r);
        }
        
        function showNextPhoto() {
            if (!restaurants[currentIndex]) return;
            const r = restaurants[currentIndex];
            if (!r.photoUrls || r.photoUrls.length <= 1) return;
            r.currentPhotoIndex = (r.currentPhotoIndex + 1) % r.photoUrls.length;
            swipeUI.image.src = r.photoUrls[r.currentPhotoIndex];
            
            // Only update photo indicators, don't recreate travel times
            updatePhotoIndicators(r);
        }
        
        // New function to update only photo indicators, separate from full display update
        function updatePhotoIndicators(restaurant) {
            swipeUI.photoIndicators.innerHTML = '';
            restaurant.photoUrls.forEach((_, index) => {
                const dot = document.createElement('span');
                dot.className = 'photo-dot' + (index === restaurant.currentPhotoIndex ? ' active' : '');
                swipeUI.photoIndicators.appendChild(dot);
            });
        }
    </script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js" defer></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js" defer></script>

</body>
</html>
