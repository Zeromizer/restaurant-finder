<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Restaurant Matcher</title>
    <style>
        /* --- Base Styles --- */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: Arial, sans-serif; }
        body { background-color: #f5f5f5; color: #333; line-height: 1.6; }
        .container { max-width: 100%; width: 500px; margin: 20px auto; padding: 20px; overflow: visible; }
        .hidden { display: none !important; }

        /* --- View Transitions --- */
        .view { width: 100%; opacity: 1; transition: opacity 0.3s ease-in-out; display: block; }
        .view.transition-hidden { opacity: 0; height: 0; overflow: hidden; pointer-events: none; }

        /* --- Header --- */
        .header { text-align: center; margin-bottom: 10px; }
        .header h1 { color: #FF5864; margin-bottom: 2px; font-size: 24px; }
        .header p { font-size: 14px; }

        /* --- Forms & Inputs --- */
        .search-form { background-color: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); margin-bottom: 20px; }
        .form-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 8px; font-weight: 500; color: #555; }
        input, select {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            background-color: #fff;
            line-height: normal;
            height: 44px; /* Maintain consistent height */
        }
        input:focus, select:focus { border-color: #FF5864; outline: none; box-shadow: 0 0 0 2px rgba(255, 88, 100, 0.2); }
        /* Style for the share link input */
        #share-link-input {
            background-color: #eee;
            font-size: 14px;
            word-wrap: break-word; /* Allow long link to wrap */
             height: auto; /* Allow wrapping */
             padding: 10px;
             margin-top: 5px;
        }


        /* --- Buttons --- */
        .button {
            background-color: #FF5864; color: white; border: none;
            padding: 12px 20px; border-radius: 30px; cursor: pointer; font-size: 16px; font-weight: 600;
            display: inline-block; text-align: center; vertical-align: middle;
            width: 100%;
            transition: background-color 0.2s ease, transform 0.1s ease;
            line-height: 1.5;
        }
        .button:hover:not(:disabled) { background-color: #e1404d; transform: scale(1.02); }
        .button:active:not(:disabled) { transform: scale(0.98); }
        .button:disabled { background-color: #ccc; cursor: not-allowed; transform: none; }
        /* Specific button colors */
        .button.secondary { background-color: #007bff; border-color: #007bff; }
        .button.tertiary { background-color: #6c757d; border-color: #6c757d; }
        .button.copy-button { font-size: 1.2em; background: none; border: none; color: #555; width: auto; padding: 5px; vertical-align: middle; cursor:pointer; }


        .location-button { width: 100%; margin-top: 10px; }

        /* --- Card Layout --- */
        .card { background-color: white; border-radius: 10px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15); overflow: hidden; margin-bottom: 10px; height: auto; position: relative; display: flex; flex-direction: column; }
        .photo-container { position: relative; width: 100%; height: 220px; overflow: hidden; flex-shrink: 0; background-color: #f0f0f0; }
        .photo-nav { position: absolute; left: 0; right: 0; bottom: 10px; display: flex; justify-content: center; align-items: center; z-index: 1; }
        .photo-nav-btn { background-color: rgba(0, 0, 0, 0.5); color: white; border: none; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; display: flex; justify-content: center; align-items: center; margin: 0 5px; transition: background-color 0.2s; }
        .photo-nav-btn:hover { background-color: rgba(0, 0, 0, 0.8); }
        #photo-indicators { display: flex; justify-content: center; margin: 0 10px; }
        .photo-dot { width: 6px; height: 6px; border-radius: 50%; background-color: rgba(255, 255, 255, 0.5); margin: 0 3px; display: inline-block; transition: background-color 0.3s; }
        .photo-dot.active { background-color: #fff; }
        .card-content { padding: 10px; flex-grow: 1; }
        .card-title { font-size: 20px; font-weight: 600; margin-bottom: 5px; color: #333; }
        .card-info { color: #555; margin-bottom: 5px; font-size: 14px; }
        .card-info#restaurant-address { line-height: 1.3; }
        .google-maps-link { display: inline-block; margin-top: 5px; padding: 4px 10px; background-color: #4285F4; color: white; text-decoration: none; border-radius: 4px; font-size: 13px; font-weight: 500; transition: background-color 0.2s; }
        .google-maps-link:hover { background-color: #357ae8; }
        .card-actions { position: relative; left: 0; right: 0; display: flex; justify-content: space-evenly; padding: 10px; background: none; border-top: 1px solid #eee; z-index: 2; }
        .action-button { width: 50px; height: 50px; border-radius: 50%; display: flex; justify-content: center; align-items: center; background-color: white; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15); cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; font-size: 22px; }
        .action-button:hover { transform: scale(1.1); box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); }
        .action-button:active { transform: scale(1.05); box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15); }
        .like-button { color: #00d174; }
        .dislike-button { color: #fd5068; }

        /* --- Loading & Error --- */
        .loading { display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 300px; padding: 20px; text-align: center; color: #555; }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #FF5864; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .error-message { color: #c0392b; text-align: center; padding: 15px; background-color: #fbecea; border: 1px solid #e74c3c; border-radius: 8px; margin: 20px 0; font-size: 15px; }

        /* --- Restaurant Lists (Liked, Matched, Shared) --- */
        .restaurant-list { background-color: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); margin-top: 15px; overflow: visible; }
        .restaurant-item { border-bottom: 1px solid #eee; }
        .restaurant-item:last-child { border-bottom: none; }
        .liked-item-image { height: 200px; }
        .restaurant-item-content { padding: 10px; }
        .restaurant-item h3 { margin-bottom: 3px; color: #333; font-size: 16px; }
        .restaurant-item p { font-size: 13px; color: #666; margin-bottom: 2px; }
        .price-level { color: #27ae60; font-weight: 500; }
        .restaurant-item .google-maps-link { font-size: 12px; padding: 3px 8px; margin-top: 5px; }

        /* Travel time styles */
        .travel-times {
            margin-top: 8px;
            padding-top: 5px;
            border-top: 1px dashed #eee;
            font-size: 12px;
            color: #555;
            margin-bottom: 10px; /* Reduce space after travel times */
        }
        .travel-time-item {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }
        .travel-time-icon {
            margin-right: 6px;
            font-size: 14px;
        }
        .travel-time-loading {
            color: #777;
            font-style: italic;
        }

        /* --- Google Places Autocomplete --- */
        .pac-container { font-family: Arial, sans-serif; border-radius: 4px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); z-index: 1000 !important; }
        .pac-item { padding: 10px; cursor: pointer; font-size: 15px; }
        .pac-item:hover { background-color: #f5f5f5; }
        .pac-item-query { font-weight: 500; }

        /* --- Review Styles --- */
        .restaurant-reviews {
            margin-top: 10px; /* Reduced from default */
        }
        .reviews-title {
            margin-top: 0; /* Remove top margin */
            margin-bottom: 8px;
            font-size: 16px;
            color: #333;
            padding-top: 5px;
            border-top: 1px dashed #eee;
        }
        .review-item { 
            padding: 5px 0; /* Reduced padding */
        }
        .review-author { 
            display: flex; 
            justify-content: space-between; 
            margin-bottom: 2px; /* Reduced margin */
            font-size: 13px; 
        }
        .review-author span { color: #FFA534; }
        .review-date { color: #888; font-size: 12px; }
        .review-text { font-size: 13px; line-height: 1.4; white-space: pre-line; color: #555; }
        .review-text.truncated { cursor: pointer; position: relative; }
        .review-text.truncated:after { content: "⋯ Read more"; color: #4285F4; font-style: italic; display: inline; }
        .review-text.expanded { white-space: pre-line; }
        .review-type { font-size: 11px; background-color: #f0f0f0; color: #666; padding: 1px 4px; border-radius: 3px; margin-left: 5px; }
        .more-reviews { font-size: 12px; color: #4285F4; margin-top: 5px; text-align: right; font-style: italic; }

        /* Image padding for proper display */
        .card-img, .liked-item-image {
            width: 100%;
            height: 100%;
            object-fit: contain; 
            display: block;
            background-color: #f0f0f0;
            padding: 5px;
            max-height: 100%;
        }

        /* --- New Restaurant Sticker --- */
        .new-sticker {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #FF3B30;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: bold;
            transform: rotate(5deg);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 10;
            animation: pulse-bounce 2s infinite;
        }
        
        .restaurant-item .new-sticker {
            top: 5px;
            right: 5px;
            font-size: 11px;
            padding: 4px 8px;
        }
        
        /* Animation for NEW sticker */
        @keyframes pulse-bounce {
            0% { transform: rotate(5deg) scale(1); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
            20% { transform: rotate(5deg) scale(1.1); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
            30% { transform: rotate(5deg) scale(1); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
            40% { transform: rotate(5deg) scale(1.1); box-shadow: 0 4px 8px rgba(0,0,0,0.3); }
            50% { transform: rotate(5deg) scale(1); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
            70% { transform: rotate(5deg) translateY(-3px); box-shadow: 0 5px 8px rgba(0,0,0,0.3); }
            80% { transform: rotate(5deg) translateY(0); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
            100% { transform: rotate(5deg) scale(1); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        }

    </style>
</head>
<body>
    <div class="container">
         <div id="error-container" class="error-message hidden"></div>

        <!-- Search View -->
        <div id="search-view" class="view">
            <div class="header"> <h1>Restaurant Matcher</h1> <p>Find food places to enjoy with friends</p> </div>
            <form id="search-form" class="search-form">
                 <div class="form-group">
                    <label for="location">Location</label>
                    <input id="location" type="text" placeholder="Enter city, neighborhood, or address" class="location-input" required />
                    <button type="button" id="use-location-button" class="button location-button">📍 My Location</button>
                </div>
                 <div class="form-group"> <label for="radius">Distance (km)</label> <select id="radius" name="radius"> <option value="1000">1 km</option> <option value="2000" selected>2 km</option> <option value="5000">5 km</option> <option value="10000">10 km</option> <option value="20000">20 km</option> </select> </div>
                 <div class="form-group"> <label for="price-level">Price Level</label> <select id="price-level" name="price-level"> <option value="">Any</option> <option value="1">$ (Inexpensive)</option> <option value="2">$$ (Moderate)</option> <option value="3">$$$ (Expensive)</option> <option value="4">$$$$ (Very Expensive)</option> </select> </div>
                 <div class="form-group">
                    <label for="cuisine-keyword">Cuisine, Specific Dish or Place Type (Optional)</label>
                    <input type="text" id="cuisine-keyword" name="cuisine-keyword" placeholder="e.g., Italian, Pizza, Cafe, Hawker, Food Court">
                 </div>
                 <div class="form-group" style="display: flex; align-items: center;">
                    <input type="checkbox" id="high-rating-filter" name="high-rating-filter" style="width: auto; height: auto; margin-right: 10px;">
                    <label for="high-rating-filter" style="display: inline; margin: 0;">Show only highly-rated places (4.5+ stars)</label>
                 </div>
                 <div class="form-group" style="display: flex; align-items: center;">
                    <input type="checkbox" id="popular-places-filter" name="popular-places-filter" style="width: auto; height: auto; margin-right: 10px;">
                    <label for="popular-places-filter" style="display: inline; margin: 0;">Show only popular places (4.2+ stars with 100+ reviews)</label>
                 </div>
                <button type="submit" class="button" id="search-button">Find Food Places</button>
            </form>
        </div>

        <!-- Loading View -->
        <div id="loading-view" class="view transition-hidden"> <div class="loading"><div class="spinner"></div><p id="loading-text">Finding food places...</p></div> </div>

        <!-- Swipe View -->
        <div id="swipe-view" class="view transition-hidden"> <div class="header"> <h1>Find Your Match</h1> <p>Food Place <span id="current-index">1</span> of <span id="total-restaurants">?</span></p> </div> <div class="card"> <div class="photo-container"> <img class="card-img" id="restaurant-image" src="..." alt="Restaurant"> <div class="photo-nav"> <button id="prev-photo" class="photo-nav-btn">❮</button> <div id="photo-indicators"></div> <button id="next-photo" class="photo-nav-btn">❯</button> </div> </div> <div class="card-content"> <h2 class="card-title" id="restaurant-name">...</h2> <p class="card-info" id="restaurant-cuisine">...</p> <p class="card-info" id="restaurant-rating">...</p> <p class="card-info" id="restaurant-price">...</p> <p class="card-info" id="restaurant-address">...</p> <div id="google-maps-link-placeholder"></div> </div> <div class="card-actions"> <div class="action-button dislike-button" id="dislike-button">❌</div> <div class="action-button like-button" id="like-button">❤️</div> </div> </div> </div>

        <!-- Results View -->
        <div id="results-view" class="view transition-hidden">
            <div class="header"> <h1>Your Results</h1> <p>You liked <span id="liked-count">0</span> food place(s)</p> </div>
            <div class="search-form">
                 <!-- Session Code -->
                 <p style="text-align:center; margin-bottom:5px;">Share this code for matching:</p>
                 <p style="text-align:center; margin-bottom:20px;"> <strong id="session-id" style="font-size:1.5em; background-color:#eee; padding:5px 10px; border-radius:4px; user-select:all; cursor:pointer;">CODE</strong> <button id="copy-code-button" title="Copy Code" class="button copy-button">📋</button> </p>

                 <!-- Find Matches -->
                 <div class="form-group"> <label for="friend-code">Enter Friend's Code</label> <input id="friend-code" type="text" placeholder="Paste friend's code"/> </div>
                 <button class="button" id="find-matches-button">Find Matches</button>

                 <!-- Share Link Section -->
                 <div id="share-link-section" class="form-group" style="margin-top: 20px; border-top: 1px solid #eee; padding-top: 15px;">
                     <label for="share-link-input">Share your liked list with a link:</label>
                     <div style="display: flex; align-items: center;">
                         <input type="text" id="share-link-input" readonly placeholder="Generating share link...">
                         <button id="copy-link-button" title="Copy Link" class="button copy-button" style="margin-left: 5px;">📋</button>
                    </div>
                 </div>

                 <!-- View Liked / Start Over -->
                 <button type="button" class="button secondary" id="view-liked-button" style="margin-top: 15px;">View My Liked Food Places</button>
                 <button class="button tertiary" id="start-over-button" style="margin-top:15px;">Start Over</button>
             </div>

             <div id="liked-restaurants-list" class="restaurant-list hidden">
                 <!-- Liked restaurants populated here -->
             </div>
        </div>

        <!-- Matches View -->
        <div id="matches-view" class="view transition-hidden">
            <div class="header"> <h1>Your Matches!</h1> <p>Food places you both liked</p> </div>
            <div id="matches-list" class="restaurant-list"> <!-- Content will be generated --> </div>
            <button class="button" id="matches-start-over-button" style="margin-top:20px;">Start Over</button>
        </div>

        <!-- Shared View -->
        <div id="shared-view" class="view transition-hidden">
             <div class="header"> <h1>Shared Food Places</h1> <p id="shared-list-source">List from a friend</p> </div>
             <div id="shared-restaurants-list" class="restaurant-list">
                 <p style="text-align:center; padding: 20px;">Loading shared list...</p>
                 <!-- Shared restaurants will be populated here -->
             </div>
             <button class="button" id="shared-start-over-button" style="margin-top:20px;">Start Your Own Search</button>
        </div>

    </div>

    <script>
        // --- JS Code ---
        const views = { search: document.getElementById('search-view'), loading: document.getElementById('loading-view'), swipe: document.getElementById('swipe-view'), results: document.getElementById('results-view'), matches: document.getElementById('matches-view'),
                      shared: document.getElementById('shared-view') };
        const searchForm = document.getElementById('search-form');
        const locationInput = document.getElementById('location');
        const useLocationButton = document.getElementById('use-location-button');
        const radiusSelect = document.getElementById('radius');
        const priceLevelSelect = document.getElementById('price-level');
        const cuisineKeywordInput = document.getElementById('cuisine-keyword');
        const highRatingFilter = document.getElementById('high-rating-filter');
        const popularPlacesFilter = document.getElementById('popular-places-filter');
        const searchButton = document.getElementById('search-button');
        const loadingText = document.getElementById('loading-text');
        const swipeUI = { currentIndex: document.getElementById('current-index'), totalRestaurants: document.getElementById('total-restaurants'), image: document.getElementById('restaurant-image'), name: document.getElementById('restaurant-name'), cuisine: document.getElementById('restaurant-cuisine'), rating: document.getElementById('restaurant-rating'), price: document.getElementById('restaurant-price'), address: document.getElementById('restaurant-address'), prevPhotoBtn: document.getElementById('prev-photo'), nextPhotoBtn: document.getElementById('next-photo'), photoIndicators: document.getElementById('photo-indicators'), dislikeButton: document.getElementById('dislike-button'), likeButton: document.getElementById('like-button'), mapsLinkPlaceholder: document.getElementById('google-maps-link-placeholder') };
        const resultsUI = { likedCount: document.getElementById('liked-count'), sessionId: document.getElementById('session-id'), friendCodeInput: document.getElementById('friend-code'), findMatchesButton: document.getElementById('find-matches-button'), startOverButton: document.getElementById('start-over-button'), copyCodeButton: document.getElementById('copy-code-button'),
                         viewLikedButton: document.getElementById('view-liked-button'), likedListContainer: document.getElementById('liked-restaurants-list'),
                         shareLinkSection: document.getElementById('share-link-section'),
                         shareLinkInput: document.getElementById('share-link-input'),
                         copyLinkButton: document.getElementById('copy-link-button') };
        const matchesUI = { list: document.getElementById('matches-list'), startOverButton: document.getElementById('matches-start-over-button') };
        const sharedUI = { list: document.getElementById('shared-restaurants-list'), startOverButton: document.getElementById('shared-start-over-button'), sourceText: document.getElementById('shared-list-source') };
        const errorContainer = document.getElementById('error-container');

        let restaurants = [];
        let currentIndex = 0;
        let likedRestaurants = {};
        let sessionId = '';
        let userCoordinates = null;
        let autocomplete = null;
        let currentVisibleView = views.search;

        // --- Helper Functions ---
        function showView(viewToShow) { Object.values(views).forEach(view => { if (view !== viewToShow) view.classList.add('transition-hidden'); }); viewToShow.classList.remove('transition-hidden'); currentVisibleView = viewToShow; window.scrollTo(0, 0); }
        function showError(message) { errorContainer.textContent = message; errorContainer.classList.remove('hidden'); }
        function hideError() { errorContainer.classList.add('hidden'); errorContainer.textContent = ''; }
        function setLoadingText(text) { loadingText.textContent = text; }

        // --- Google Maps & Places API Functions ---
        function loadGoogleMapsScript() {
            if (document.getElementById('google-maps-script')) return;
            const script = document.createElement('script'); script.id = 'google-maps-script';
            const apiKey = "AIzaSyCHBWV_-CcYHftllY2aZ22SfSySw9PjqFo"; // Your key
            if (!apiKey || apiKey === "YOUR_GOOGLE_MAPS_API_KEY" || apiKey.length < 20) { console.error("Google Maps API Key missing/invalid!"); showError("Map services not configured."); locationInput.disabled = true; useLocationButton.disabled = true; searchButton.disabled = true; return; }
            script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places,geometry&callback=initMapServices`;
            script.async = true; script.defer = true;
            script.onerror = () => { console.error("Failed to load Google Maps script."); showError("Failed to load location services."); };
            document.head.appendChild(script);
        }
        window.initMapServices = function() { console.log("Google Maps API loaded."); initAutocomplete(); };
        function initAutocomplete() {
            if (typeof google === 'undefined' || !google.maps?.places?.Autocomplete) { console.error("Autocomplete library not ready."); showError("Location search failed."); return; }
            try {
                autocomplete = new google.maps.places.Autocomplete(locationInput, { types: ['geocode', 'establishment'], fields: ['geometry', 'name', 'formatted_address', 'place_id'], componentRestrictions: { country: [] } });
                autocomplete.addListener('place_changed', () => {
                    const place = autocomplete.getPlace(); hideError();
                    if (!place.geometry?.location) { userCoordinates = null; return; }
                    userCoordinates = { lat: place.geometry.location.lat(), lng: place.geometry.location.lng() };
                    console.log("Place selected:", place.name); locationInput.value = place.formatted_address || place.name;
                }); console.log("Autocomplete initialized.");
            } catch (error) { console.error("Error initializing Autocomplete:", error); showError("Failed to init location search."); }
        }
        function getUserLocation() {
             if (!navigator.geolocation) { showError("Geolocation not supported."); return; }
             const btn = useLocationButton; btn.textContent = "Finding..."; btn.disabled = true; hideError();
             navigator.geolocation.getCurrentPosition( (pos) => {
                 userCoordinates = { lat: pos.coords.latitude, lng: pos.coords.longitude };
                 console.log("Geolocation:", userCoordinates); locationInput.value = `Current Location (${userCoordinates.lat.toFixed(4)}, ${userCoordinates.lng.toFixed(4)})`;
                 btn.textContent = "📍 My Location"; btn.disabled = false;
             }, (err) => {
                 console.error("Geolocation error:", err); let msg = "Could not get location."; switch(err.code){case 1:msg="Permission denied.";break; case 2:msg="Position unavailable.";break; case 3:msg="Timeout.";break;} showError(msg); userCoordinates = null; locationInput.value = ''; btn.textContent = "📍 My Location"; btn.disabled = false;
             }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
         }
        function fetchRestaurants() {
            let loadingMessage = "Finding food places...";
            if (highRatingFilter.checked && popularPlacesFilter.checked) {
                loadingMessage = "Finding highly-rated popular food places...";
            } else if (highRatingFilter.checked) {
                loadingMessage = "Finding highly-rated food places...";
            } else if (popularPlacesFilter.checked) {
                loadingMessage = "Finding popular food places...";
            }
            setLoadingText(loadingMessage);
            showView(views.loading); hideError();
            const locationText = locationInput.value.trim(), radius = parseInt(radiusSelect.value), priceLevel = priceLevelSelect.value, keyword = cuisineKeywordInput.value.trim();
            if (typeof google === 'undefined' || !google.maps?.places) { showError("Location services not ready."); showView(views.search); return; }
            if (userCoordinates) { performNearbySearch(userCoordinates, radius, keyword, priceLevel); }
            else if (locationText && !locationText.startsWith("Current Location")) {
                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ address: locationText }, (results, status) => {
                    if (status === 'OK' && results?.[0]?.geometry?.location) {
                        userCoordinates = { lat: results[0].geometry.location.lat(), lng: results[0].geometry.location.lng() };
                        performNearbySearch(userCoordinates, radius, keyword, priceLevel);
                    } else { showError(`Could not find "${locationText}".`); showView(views.search); }
                });
            } else { showError("Please provide a location."); showView(views.search); }
        }
        function performNearbySearch(coords, radius, keyword, priceLevel) {
            const placesService = new google.maps.places.PlacesService(document.createElement('div'));
            
            // Create an array of types to search for - restaurant, cafe, food, etc.
            const establishmentTypes = ['restaurant', 'cafe', 'meal_takeaway', 'meal_delivery', 'bakery', 'food'];
            
            // Create an array of promises to hold all the different search requests
            const searchPromises = establishmentTypes.map(type => {
                return new Promise(resolve => {
                    let request = {
                        location: new google.maps.LatLng(coords.lat, coords.lng),
                        radius: radius,
                        type: type
                    };
            if (keyword) request.keyword = keyword;
                    if (priceLevel) {
                        const price = parseInt(priceLevel);
                        request.minPriceLevel = price;
                        request.maxPriceLevel = price;
                    }
                    
                    console.log(`Places Request for ${type}:`, request);
                    
            placesService.nearbySearch(request, (results, status) => {
                        console.log(`Places Status for ${type}:`, status);
                        if (status === google.maps.places.PlacesServiceStatus.OK && results?.length > 0) {
                            resolve(results);
                        } else {
                            resolve([]); // Return empty array if no results or error
                        }
                    });
                });
            });
            
            // Additional keyword search for hawker centers, food courts, etc.
            const keywordPromise = new Promise(resolve => {
                if (!keyword || keyword.toLowerCase().includes('hawker') || keyword.toLowerCase().includes('food court')) {
                    // Only add this search if no specific keyword is provided or if looking for hawkers
                    const hawkerRequest = {
                        location: new google.maps.LatLng(coords.lat, coords.lng),
                        radius: radius,
                        keyword: keyword || 'hawker center food court'
                    };
                    
                    if (priceLevel) {
                        const price = parseInt(priceLevel);
                        hawkerRequest.minPriceLevel = price;
                        hawkerRequest.maxPriceLevel = price;
                    }
                    
                    console.log("Hawker Center Request:", hawkerRequest);
                    
                    placesService.nearbySearch(hawkerRequest, (results, status) => {
                        console.log("Hawker Center Status:", status);
                if (status === google.maps.places.PlacesServiceStatus.OK && results?.length > 0) {
                            resolve(results);
                        } else {
                            resolve([]);
                        }
                    });
                } else {
                    resolve([]); // Skip this search if specific keyword provided
                }
            });
            
            // Combine all search promises
            const allPromises = [...searchPromises, keywordPromise];
            
            // Wait for all searches to complete, then combine and deduplicate results
            Promise.all(allPromises).then(resultsArrays => {
                // Flatten array of arrays and remove duplicates based on place_id
                const allPlaces = [];
                const placeIds = new Set();
                
                resultsArrays.flat().forEach(place => {
                    if (!placeIds.has(place.place_id)) {
                        placeIds.add(place.place_id);
                        allPlaces.push(place);
                    }
                });
                
                console.log("Total unique places found:", allPlaces.length);
                
                if (allPlaces.length > 0) {
                    const operational = allPlaces.filter(p => p.business_status === 'OPERATIONAL').slice(0, 20);
                    if (operational.length === 0) {
                        showError(`No operational food establishments found.`);
                        showView(views.search);
                        return;
                    }
                    console.log("Found", operational.length, "operational food establishments.");
                    processRestaurantResults(operational, keyword);
                } else {
                    showError(`No food establishments found${keyword ? ` for "${keyword}"` : ''}.`);
                    showView(views.search);
                }
            }).catch(error => {
                console.error("Error in searches:", error);
                showError("Error searching for food establishments.");
                showView(views.search);
            });
        }
        function getPlaceDetails(placeIds) {
            const placesService = new google.maps.places.PlacesService(document.createElement('div'));
            const promises = placeIds.map(id => new Promise(res => placesService.getDetails({ 
                placeId: id, 
                fields: [
                    'photos', 'name', 'reviews', 'opening_hours', 
                    'utc_offset_minutes', 'business_status', 
                    'user_ratings_total', 'website', 'formatted_phone_number'
                ],
                reviews_sort: 'relevance' // Request reviews sorted by relevance first
            }, (d, s) => {
                // Process reviews if available
                let reviews = [];
                if (s === google.maps.places.PlacesServiceStatus.OK && d?.reviews && d.reviews.length > 0) {
                    // First review is already most relevant (by Google's ranking)
                    const mostRelevant = d.reviews[0];
                    
                    // Sort the rest by date (most recent first)
                    const otherReviews = d.reviews.slice(1).sort((a, b) => 
                        new Date(b.time * 1000) - new Date(a.time * 1000)
                    );
                    
                    // Combine: most relevant first, then two most recent
                    reviews = [mostRelevant, ...otherReviews.slice(0, 2)];
                }
                
                // Check if the place is new (3 months or less)
                // We need to analyze all reviews and additional signals to determine if the place is truly new
                let isNew = false;
                
                if (s === google.maps.places.PlacesServiceStatus.OK) {
                    // Multiple signals to check if a restaurant is new
                    
                    // 1. Review count - new places typically have few reviews
                    const fewReviews = d.user_ratings_total && d.user_ratings_total < 15;
                    
                    // 2. Review dates - check if all reviews are recent
                    let allReviewsRecent = false;
                    let hasReviews = false;
                    
                    if (d.reviews && d.reviews.length > 0) {
                        hasReviews = true;
                        // Sort all reviews by date (oldest first)
                        const sortedReviews = [...d.reviews].sort((a, b) => 
                            new Date(a.time * 1000) - new Date(b.time * 1000)
                        );
                        
                        // Get the oldest review date
                        const oldestReviewDate = new Date(sortedReviews[0].time * 1000);
                        const threeMonthsAgo = new Date();
                        threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
                        
                        // Check if oldest review is less than 3 months old
                        allReviewsRecent = oldestReviewDate > threeMonthsAgo;
                        
                        // 3. Review text analysis - look for clues
                        const reviewText = d.reviews.map(r => r.text || '').join(' ').toLowerCase();
                        
                        // Phrases that suggest the place is NOT new
                        const notNewPhrases = [
                            'been here for years', 'been open for years', 'old favorite', 
                            'long time', 'year ago', 'years ago', 'was here last year', 
                            'returned after', 'used to be', 'always been', 'regular',
                            'again', 'back to', 'still good', 'still great', 'still the best',
                            'as usual', 'as always', 'reopened', 're-opened'
                        ];
                        
                        // Phrases that suggest the place IS new
                        const newPhrases = [
                            'just opened', 'newly opened', 'new place', 'new restaurant', 
                            'new opening', 'recent opening', 'grand opening', 'soft opening',
                            'opening week', 'first week', 'first day', 'first customers',
                            'recent addition', 'recently opened', 'brand new', 'newly established',
                            'only been open', 'month since opening', 'weeks since opening'
                        ];
                        
                        const hasNotNewPhrase = notNewPhrases.some(phrase => reviewText.includes(phrase));
                        const hasNewPhrase = newPhrases.some(phrase => reviewText.includes(phrase));
                        
                        // If we have strong signals in the review text, override other factors
                        if (hasNotNewPhrase) {
                            isNew = false;
                        } else if (hasNewPhrase) {
                            isNew = true;
                        } else {
                            // 4. Combine signals - only mark as new if both conditions are met
                            isNew = fewReviews && allReviewsRecent;
                        }
                    } else {
                        // No reviews might mean it's very new, but allow other signals to override
                        isNew = true;
                    }
                    
                    // Additional signal: Very low review count is a strong indicator of newness
                    // Override previous determination if review count is extremely low (3 or fewer)
                    if (d.user_ratings_total !== undefined && d.user_ratings_total <= 3) {
                        isNew = true;
                    } else if (d.user_ratings_total > 30) {
                        // Many reviews usually means established business
                        isNew = false;
                    }
                    
                    // Business status check - OPERATIONAL doesn't tell us much about age
                    // Most places don't have their opening date in the API
                }
                
                res({ 
                    placeId: id, 
                    photos: (s === google.maps.places.PlacesServiceStatus.OK && d?.photos) ? d.photos : [],
                    reviews: reviews,
                    isNew: isNew
                });
            })));
            return Promise.all(promises);
        }
        async function processRestaurantResults(results, searchKeyword) {
             try {
                 const placeIds = results.map(r => r.place_id); const details = await getPlaceDetails(placeIds);
                 const detailsMap = details.reduce((map, d) => { 
                     map[d.placeId] = {
                         photos: d.photos || [],
                         reviews: d.reviews || [],
                         isNew: d.isNew
                     }; 
                     return map; 
                 }, {});
                 restaurants = results.map(place => {
                     const placeDetails = detailsMap[place.place_id] || { photos: [], reviews: [], isNew: false };
                     const placePhotos = placeDetails.photos;
                     const photoUrls = placePhotos.slice(0, 5).map(p => p.getUrl ? p.getUrl({ maxWidth: 800, maxHeight: 600 }) : null).filter(url => url);
                     if (photoUrls.length === 0) { photoUrls.push("https://placehold.co/800x600/FF5864/white?text=No+Image"); }
                     let displayCuisine = searchKeyword ? searchKeyword.trim().toLowerCase().replace(/\b\w/g, l => l.toUpperCase()) : getCuisineFromTypes(place.types || []);
                     return { 
                         id: place.place_id, 
                         name: place.name || "Unnamed", 
                         address: place.vicinity || "Address unavailable", 
                         cuisine: displayCuisine, 
                         rating: place.rating ? `${place.rating}★ (${place.user_ratings_total || 0})` : "Not rated", 
                         ratingValue: place.rating || 0, // Add actual numeric rating for filtering
                         user_ratings_total: place.user_ratings_total || 0, // Store total rating count for filtering
                         priceLevel: place.price_level ?? 0, 
                         photoUrls, 
                         currentPhotoIndex: 0,
                         reviews: placeDetails.reviews || [],
                         isNew: placeDetails.isNew || false,
                         // Store coordinates for travel time calculation
                         coordinates: place.geometry && place.geometry.location ? {
                             lat: place.geometry.location.lat(),
                             lng: place.geometry.location.lng()
                         } : null
                     };
                 });
                 
                 // Apply filters
                 // Filter by high rating if the option is checked
                 if (highRatingFilter.checked) {
                     restaurants = restaurants.filter(place => place.ratingValue >= 4.5);
                 }
                 
                 // Filter by popular places if the option is checked
                 if (popularPlacesFilter.checked) {
                     restaurants = restaurants.filter(place => place.ratingValue >= 4.2 && place.user_ratings_total >= 100);
                 }
                 
                 if (restaurants.length === 0) { showError('No food places found matching your criteria.'); showView(views.search); return; }
                 sessionId = generateSessionId(); saveSessionToFirebase();
                 currentIndex = 0; likedRestaurants = {};
                 updateRestaurantDisplay(); showView(views.swipe);
             } catch (error) { console.error("Error processing results:", error); showError("Error loading details."); showView(views.search); }
         }
        function getCuisineFromTypes(types) { 
            const typeMap = {
                'cafe': 'Cafe',
                'bar': 'Bar',
                'bakery': 'Bakery',
                'food': 'Food Stall',
                'meal_takeaway': 'Takeaway',
                'meal_delivery': 'Delivery'
            }; 
            const knownCuisines = ["Italian", "Chinese", "Japanese", "Mexican", "Indian", "Thai", "American", "French", "Vietnamese", "Korean", "Mediterranean", "Pizza", "Sushi", "Seafood", "Steakhouse"]; 
            for(const type of types){ 
                const fmt = type.replace(/_/g,' ').replace(/\b\w/g,l=>l.toUpperCase()); 
                if(knownCuisines.includes(fmt)) return fmt; 
                if(typeMap[type]) return typeMap[type]; 
            } 
            return types.includes('restaurant') ? 'Restaurant' : (types.includes('cafe') ? 'Cafe' : 'Food Place'); 
        }
        function createGoogleMapsLink(restaurant) { if (!restaurant) return null; let url; if (restaurant.id) { url = `https://www.google.com/maps/search/?api=1&query=Google&query_place_id=${restaurant.id}`; } else if (restaurant.name && restaurant.address) { const query = encodeURIComponent(`${restaurant.name}, ${restaurant.address}`); url = `https://www.google.com/maps/search/?api=1&query=${query}`; } else { return null; } const link = document.createElement('a'); link.href = url; link.textContent = "View on Google Maps ↗"; link.className = "google-maps-link"; link.target = "_blank"; link.rel = "noopener noreferrer"; return link; }

        // --- Travel Time Functions ---
        async function getTravelTimes(origin, destination) {
            if (!origin || !destination || typeof google === 'undefined' || !google.maps?.DistanceMatrixService) {
                return { driving: null, transit: null };
            }
            
            const service = new google.maps.DistanceMatrixService();
            
            try {
                // First get driving time
                const drivingResult = await new Promise((resolve, reject) => {
                    service.getDistanceMatrix({
                        origins: [origin],
                        destinations: [destination],
                        travelMode: google.maps.TravelMode.DRIVING,
                        unitSystem: google.maps.UnitSystem.METRIC
                    }, (response, status) => {
                        if (status === 'OK') {
                            resolve(response);
                        } else {
                            console.error("Driving time calculation failed:", status);
                            resolve(null);
                        }
                    });
                });
                
                // Then get transit time
                const transitResult = await new Promise((resolve, reject) => {
                    service.getDistanceMatrix({
                        origins: [origin],
                        destinations: [destination],
                        travelMode: google.maps.TravelMode.TRANSIT,
                        unitSystem: google.maps.UnitSystem.METRIC
                    }, (response, status) => {
                        if (status === 'OK') {
                            resolve(response);
                        } else {
                            console.error("Transit time calculation failed:", status);
                            resolve(null);
                        }
                    });
                });
                
                // Process results
                const drivingTime = drivingResult && 
                                    drivingResult.rows[0]?.elements[0]?.status === "OK" ? 
                                    drivingResult.rows[0].elements[0].duration.text : null;
                                    
                const transitTime = transitResult && 
                                    transitResult.rows[0]?.elements[0]?.status === "OK" ? 
                                    transitResult.rows[0].elements[0].duration.text : null;
                
                return { driving: drivingTime, transit: transitTime };
            } catch (error) {
                console.error("Error calculating travel times:", error);
                return { driving: null, transit: null };
            }
        }
        
        // Creates travel time elements for a restaurant
        function createTravelTimeElements(restaurant) {
            const container = document.createElement('div');
            container.className = 'travel-times';
            
            if (!userCoordinates || !restaurant.coordinates) {
                return container; // Return empty container if no coordinates
            }
            
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'travel-time-loading';
            loadingDiv.textContent = 'Calculating travel times...';
            container.appendChild(loadingDiv);
            
            // Start async calculation of travel times
            const origin = new google.maps.LatLng(userCoordinates.lat, userCoordinates.lng);
            const destination = new google.maps.LatLng(
                restaurant.coordinates.lat, 
                restaurant.coordinates.lng
            );
            
            getTravelTimes(origin, destination).then(times => {
                // Remove loading message
                container.removeChild(loadingDiv);
                
                // Add driving time if available
                if (times.driving) {
                    const drivingItem = document.createElement('div');
                    drivingItem.className = 'travel-time-item';
                    drivingItem.innerHTML = `<span class="travel-time-icon">🚗</span> ${times.driving} by car`;
                    container.appendChild(drivingItem);
                }
                
                // Add transit time if available
                if (times.transit) {
                    const transitItem = document.createElement('div');
                    transitItem.className = 'travel-time-item';
                    transitItem.innerHTML = `<span class="travel-time-icon">🚇</span> ${times.transit} by public transport`;
                    container.appendChild(transitItem);
                }
                
                // If no times available, show message
                if (!times.driving && !times.transit) {
                    const noDataDiv = document.createElement('div');
                    noDataDiv.className = 'travel-time-item';
                    noDataDiv.textContent = 'Travel time information unavailable';
                    container.appendChild(noDataDiv);
                }
            }).catch(error => {
                console.error("Travel time display error:", error);
                loadingDiv.textContent = 'Unable to calculate travel times';
            });
            
            return container;
        }

        // --- Swipe UI Functions ---
        function updateRestaurantDisplay() {
            if (currentIndex >= restaurants.length) { showResultsView(); return; }
            const restaurant = restaurants[currentIndex];
            swipeUI.currentIndex.textContent = currentIndex + 1; swipeUI.totalRestaurants.textContent = restaurants.length;
            restaurant.currentPhotoIndex = restaurant.currentPhotoIndex || 0; swipeUI.image.src = restaurant.photoUrls[restaurant.currentPhotoIndex]; swipeUI.image.alt = restaurant.name;
            swipeUI.photoIndicators.innerHTML = ''; restaurant.photoUrls.forEach((_, index) => { const dot = document.createElement('span'); dot.className = 'photo-dot' + (index === restaurant.currentPhotoIndex ? ' active' : ''); swipeUI.photoIndicators.appendChild(dot); });
            const showNav = restaurant.photoUrls.length > 1; swipeUI.prevPhotoBtn.style.display = showNav ? 'flex' : 'none'; swipeUI.nextPhotoBtn.style.display = showNav ? 'flex' : 'none'; swipeUI.photoIndicators.style.display = showNav ? 'flex' : 'none';
            swipeUI.name.textContent = restaurant.name; swipeUI.cuisine.textContent = `Cuisine: ${restaurant.cuisine}`; swipeUI.rating.textContent = `Rating: ${restaurant.rating}`; swipeUI.price.textContent = `Price: ${restaurant.priceLevel > 0 ? '$'.repeat(restaurant.priceLevel) : 'N/A'}`; swipeUI.address.textContent = `Address: ${restaurant.address}`;
            swipeUI.mapsLinkPlaceholder.innerHTML = ''; const mapsLink = createGoogleMapsLink(restaurant); if (mapsLink) swipeUI.mapsLinkPlaceholder.appendChild(mapsLink);
            
            // Add travel time information if coordinates are available
            if (userCoordinates && restaurant.coordinates) {
                const travelTimeElement = createTravelTimeElements(restaurant);
                swipeUI.mapsLinkPlaceholder.appendChild(travelTimeElement);
            }
            
            // Add NEW sticker if restaurant is new
            const photoContainer = document.querySelector('.photo-container');
            const existingSticker = photoContainer.querySelector('.new-sticker');
            if (existingSticker) {
                photoContainer.removeChild(existingSticker);
            }
            
            if (restaurant.isNew) {
                const newSticker = document.createElement('div');
                newSticker.className = 'new-sticker';
                newSticker.textContent = 'NEWLY OPENED';
                photoContainer.appendChild(newSticker);
            }
            
            // Add reviews - directly after travel times without extra spacing
            if (restaurant.reviews && restaurant.reviews.length > 0) {
                const reviewsContainer = document.createElement('div');
                reviewsContainer.className = 'restaurant-reviews';
                
                const reviewsTitle = document.createElement('h3');
                reviewsTitle.className = 'reviews-title';
                reviewsTitle.textContent = 'Reviews';
                reviewsContainer.appendChild(reviewsTitle);
                
                restaurant.reviews.forEach((review, index) => {
                    const reviewElement = document.createElement('div');
                    reviewElement.className = 'review-item';
                    
                    // Format the date
                    let dateText = 'Unknown date';
                    if (review.time) {
                        const reviewDate = new Date(review.time * 1000);
                        dateText = reviewDate.toLocaleDateString();
                    }
                    
                    const authorDiv = document.createElement('div');
                    authorDiv.className = 'review-author';
                    
                    // Add a label for the first review to indicate it's most relevant
                    const reviewType = index === 0 ? 
                        '<span class="review-type">Most Relevant</span>' : 
                        '<span class="review-type">Recent</span>';
                    
                    authorDiv.innerHTML = `<div><strong>${review.author_name || 'Anonymous'}</strong> ${reviewType}</div><div><span>${review.rating}★</span> <span class="review-date">${dateText}</span></div>`;
                    
                    const textDiv = document.createElement('div');
                    textDiv.className = 'review-text';
                    
                    // Handle long reviews with truncation and expansion
                    const fullText = review.text || 'No review text';
                    const isTruncated = fullText.length > 100;
                    
                    if (isTruncated) {
                        // Add truncated class and store full text as data attribute
                        textDiv.className = 'review-text truncated';
                        textDiv.setAttribute('data-full-text', fullText);
                        textDiv.textContent = fullText.substring(0, 100);
                        
                        // Add click handler to expand
                        textDiv.addEventListener('click', function() {
                            if (this.classList.contains('truncated')) {
                                this.textContent = this.getAttribute('data-full-text');
                                this.classList.remove('truncated');
                                this.classList.add('expanded');
                            } else {
                                this.textContent = this.getAttribute('data-full-text').substring(0, 100);
                                this.classList.remove('expanded');
                                this.classList.add('truncated');
                            }
                        });
                    } else {
                        textDiv.textContent = fullText;
                    }
                    
                    reviewElement.appendChild(authorDiv);
                    reviewElement.appendChild(textDiv);
                    
                    // Add a separator except for the last review
                    if (index < restaurant.reviews.length - 1) {
                        reviewElement.style.borderBottom = '1px solid #eee';
                    }
                    
                    reviewsContainer.appendChild(reviewElement);
                });
                
                swipeUI.mapsLinkPlaceholder.appendChild(reviewsContainer);
            }
        }
        function changePhoto(direction) { if (currentIndex >= restaurants.length) return; const r=restaurants[currentIndex]; const num=r.photoUrls.length; if(num<=1)return; r.currentPhotoIndex=(r.currentPhotoIndex+direction+num)%num; updateRestaurantDisplay(); }
        function handleSwipe(liked) {
            if (currentIndex >= restaurants.length) return;
            const restaurantId = restaurants[currentIndex].id;
            if (liked) { likedRestaurants[restaurantId] = true; console.log("Liked:", restaurants[currentIndex].name); }
             else { console.log("Disliked:", restaurants[currentIndex].name); }
            saveLikesToFirebase();
            currentIndex++;
            if (currentIndex < restaurants.length) { updateRestaurantDisplay(); }
             else { showResultsView(); }
        }

        // --- Results & Matching Functions ---
        function showResultsView() {
            const likedCount = Object.keys(likedRestaurants).length;
            resultsUI.likedCount.textContent = likedCount;
            resultsUI.sessionId.textContent = sessionId;
            resultsUI.friendCodeInput.value = '';
            populateLikedRestaurantsList();
            resultsUI.likedListContainer.classList.add('hidden');
            resultsUI.viewLikedButton.textContent = 'View My Liked Food Places';
            resultsUI.viewLikedButton.style.display = likedCount > 0 ? 'block' : 'none';
            generateShareLink();
            resultsUI.shareLinkSection.style.display = likedCount > 0 ? 'block' : 'none';
            showView(views.results);
        }
        function populateLikedRestaurantsList() {
            const likedListContainer = resultsUI.likedListContainer;
            likedListContainer.innerHTML = '';
            const myLikedIds = Object.keys(likedRestaurants);
            const likedRestaurantDetails = restaurants.filter(r => myLikedIds.includes(r.id));
            if (likedRestaurantDetails.length > 0) {
                 const listTitle = document.createElement('h3'); listTitle.style.padding = '15px 15px 0 15px'; listTitle.style.marginBottom = '10px'; listTitle.textContent = "Your Liked Food Places:"; listTitle.style.textAlign = 'center'; likedListContainer.appendChild(listTitle);
                likedRestaurantDetails.forEach(r => { createRestaurantItemElement(r, likedListContainer); });
            } else { likedListContainer.innerHTML = '<p style="text-align:center; padding:20px;">You haven\'t liked any food places yet.</p>'; }
        }
        function findMatches() {
            const friendCode = resultsUI.friendCodeInput.value.trim().toUpperCase();
            if (!friendCode) { showError('Please enter your friend\'s code.'); return; }
            if (friendCode === sessionId) { showError('You cannot match with your own code!'); return; }
            setLoadingText("Finding matches..."); // Update loading text
            showView(views.loading); hideError();
            if (typeof firebase === 'undefined' || !firebase.apps.length) { console.warn("Firebase not init."); showError("Matching unavailable."); setTimeout(() => { displayMatches([]); showView(views.matches); }, 1500); return; }
            firebase.database().ref('sessions/' + friendCode).once('value').then(snap => {
                const friendData = snap.val();
                if (!friendData) { showError(`Friend code "${friendCode}" not found.`); showView(views.results); return; }
                const friendLikes=friendData.likes||{}; const friendLikedIds=Object.keys(friendLikes); const myLikedIds=Object.keys(likedRestaurants);
                const matchedIds=myLikedIds.filter(id=>friendLikedIds.includes(id));
                const friendRestaurantsData=friendData.restaurants||[]; const friendMap=friendRestaurantsData.reduce((map,r)=>{map[r.id]=r;return map;},{});
                const myMap=restaurants.reduce((map,r)=>{map[r.id]=r;return map;},{}); // Use current session data as fallback
                const matchedRestaurants=matchedIds.map(id=>friendMap[id]||myMap[id]).filter(r=>r); // Get details, ensuring photos are available from friendMap
                console.log("Matches found:", matchedRestaurants); displayMatches(matchedRestaurants);
            }).catch(err => { console.error("Match error:", err); showError('Could not get friend data.'); showView(views.results); });
        }
        function displayMatches(matchedRestaurants) {
            const matchesListContainer = matchesUI.list;
            matchesListContainer.innerHTML = '';
            if (matchedRestaurants.length > 0) {
                matchedRestaurants.forEach(r => { createRestaurantItemElement(r, matchesListContainer); });
            } else { matchesListContainer.innerHTML = '<p style="text-align:center; padding:20px;">No common matches found!</p>'; }
            showView(views.matches);
        }
        function createRestaurantItemElement(r, container) {
            const item = document.createElement('div'); item.className = 'restaurant-item';
            const imageUrl = (r.photoUrls && r.photoUrls.length > 0) ? r.photoUrls[0] : "https://placehold.co/300x150/cccccc/ffffff?text=No+Image";
            const priceDisplay = r.priceLevel > 0 ? '$'.repeat(r.priceLevel) : 'N/A';
            
            // Create the basic structure with image container for position reference
            item.innerHTML = `<div style="position: relative;"><img src="${imageUrl}" alt="${r.name}" class="liked-item-image">${r.isNew ? '<div class="new-sticker">NEWLY OPENED</div>' : ''}</div><div class="restaurant-item-content"><h3>${r.name}</h3><p>Cuisine: ${r.cuisine}</p><p>Rating: ${r.rating}</p><p class="price-level">Price: ${priceDisplay}</p><p>Address: ${r.address}</p></div>`;
            
            const contentDiv = item.querySelector('.restaurant-item-content');
            if(contentDiv){ 
                const mapsLink = createGoogleMapsLink(r); 
                if (mapsLink) { contentDiv.appendChild(mapsLink); }
                
                // Add travel time information if coordinates are available
                if (userCoordinates && r.coordinates) {
                    contentDiv.appendChild(createTravelTimeElements(r));
                }
                
                // Add a single review if available - make it compact
                if (r.reviews && r.reviews.length > 0) {
                    const review = r.reviews[0]; // Use most relevant review (first one)
                    
                    const reviewDiv = document.createElement('div');
                    reviewDiv.className = 'review-item';
                    reviewDiv.style.marginTop = '5px'; // Reduced margin
                    
                    // Format the date
                    let dateText = 'Unknown date';
                    if (review.time) {
                        const reviewDate = new Date(review.time * 1000);
                        dateText = reviewDate.toLocaleDateString();
                    }
                    
                    const reviewHeader = document.createElement('div');
                    reviewHeader.className = 'review-author';
                    reviewHeader.innerHTML = `<div><strong>Top Review</strong></div><div><span>${review.rating}★</span> <span class="review-date">${dateText}</span></div>`;
                    
                    const reviewText = document.createElement('div');
                    reviewText.className = 'review-text';
                    
                    // Handle long reviews with truncation and expansion
                    const fullText = review.text || 'No review text';
                    const isTruncated = fullText.length > 100;
                    
                    if (isTruncated) {
                        // Add truncated class and store full text as data attribute
                        reviewText.className = 'review-text truncated';
                        reviewText.setAttribute('data-full-text', fullText);
                        reviewText.textContent = fullText.substring(0, 100);
                        
                        // Add click handler to expand
                        reviewText.addEventListener('click', function() {
                            if (this.classList.contains('truncated')) {
                                this.textContent = this.getAttribute('data-full-text');
                                this.classList.remove('truncated');
                                this.classList.add('expanded');
                            } else {
                                this.textContent = this.getAttribute('data-full-text').substring(0, 100);
                                this.classList.remove('expanded');
                                this.classList.add('truncated');
                            }
                        });
                    } else {
                        reviewText.textContent = fullText;
                    }
                    
                    reviewDiv.appendChild(reviewHeader);
                    reviewDiv.appendChild(reviewText);
                    contentDiv.appendChild(reviewDiv);
                }
            }
            container.appendChild(item);
        }

        // --- Sharing Functions ---
        function generateShareLink() {
            if (!sessionId) { resultsUI.shareLinkInput.value = 'Error: No session ID.'; resultsUI.copyLinkButton.disabled = true; return; }
            const baseUrl = window.location.origin + window.location.pathname; const shareUrl = `${baseUrl}?share=${sessionId}`;
            resultsUI.shareLinkInput.value = shareUrl; resultsUI.copyLinkButton.disabled = false;
        }
        function copyShareLink() {
            const link = resultsUI.shareLinkInput.value; if (!link || !navigator.clipboard) { showError("Cannot copy link. Try selecting manually."); return; }
            navigator.clipboard.writeText(link).then(() => { const originalText = resultsUI.copyLinkButton.textContent; resultsUI.copyLinkButton.textContent = '✅'; setTimeout(() => { resultsUI.copyLinkButton.textContent = '📋'; }, 1500); }).catch(err => { console.error('Failed to copy share link:', err); showError("Failed to copy link automatically."); });
        }
        async function handleSharedLink(sharedSessionId) {
             console.log("Handling shared link for session:", sharedSessionId); setLoadingText("Loading shared list..."); showView(views.loading); hideError();
             if (typeof firebase === 'undefined' || !firebase.apps.length) { showError("Cannot load shared list: Connection error."); sharedUI.list.innerHTML = '<p class="error-message">Cannot load shared list: Connection error.</p>'; showView(views.shared); return; }
             try {
                 const sessionData = await fetchSharedSessionData(sharedSessionId);
                 if (!sessionData) { showError(`Shared list "${sharedSessionId}" not found or has expired.`); sharedUI.list.innerHTML = `<p class="error-message">Shared list "${sharedSessionId}" not found or has expired.</p>`; showView(views.shared); return; }
                 const sharedLikes = sessionData.likes || {}; const sharedLikedIds = Object.keys(sharedLikes); const sharedRestaurants = sessionData.restaurants || [];
                 if (sharedLikedIds.length === 0 || sharedRestaurants.length === 0) { sharedUI.list.innerHTML = '<p style="text-align:center; padding:20px;">This shared list is empty.</p>'; showView(views.shared); return; }
                 const likedRestaurantDetails = sharedRestaurants.filter(r => sharedLikedIds.includes(r.id));
                 displaySharedRestaurants(likedRestaurantDetails);
             } catch (error) { console.error("Error fetching shared session:", error); showError("Could not load the shared list."); sharedUI.list.innerHTML = `<p class="error-message">Could not load the shared list.</p>`; showView(views.shared); }
         }
         function fetchSharedSessionData(sessionIdToFetch) { if (!sessionIdToFetch) return Promise.resolve(null); return firebase.database().ref('sessions/' + sessionIdToFetch).once('value').then(snapshot => snapshot.val()); }
         function displaySharedRestaurants(sharedRestaurantList) {
            const container = sharedUI.list; container.innerHTML = '';
            if (sharedRestaurantList.length > 0) { sharedRestaurantList.forEach(r => { createRestaurantItemElement(r, container); }); }
            else { container.innerHTML = '<p style="text-align:center; padding:20px;">This shared list is empty or could not be loaded.</p>'; }
            sharedUI.sourceText.textContent = `Viewing a shared list`; showView(views.shared);
         }

        // --- Firebase Integration ---
        function generateSessionId() { return Math.random().toString(36).substring(2, 10).toUpperCase(); }
        function saveSessionToFirebase() {
            if(typeof firebase==='undefined'||!firebase.apps.length||!sessionId)return;
            const restaurantsToSave = restaurants.map(r => ({ 
                id: r.id, 
                name: r.name, 
                address: r.address, 
                cuisine: r.cuisine, 
                rating: r.rating, 
                priceLevel: r.priceLevel, 
                photoUrls: (r.photoUrls && r.photoUrls.length > 0) ? [r.photoUrls[0]] : [],
                reviews: r.reviews || [],
                isNew: r.isNew || false,
                coordinates: r.coordinates || null
            }));
            const sessionData = { restaurants: restaurantsToSave, timestamp: firebase.database.ServerValue.TIMESTAMP, likes: {} };
            firebase.database().ref('sessions/'+sessionId).set(sessionData).then(() => console.log("Session saved:", sessionId)).catch(e=>console.error("Session save error:",e));
        }
        function saveLikesToFirebase() {
            if(typeof firebase==='undefined'||!firebase.apps.length||!sessionId)return;
            firebase.database().ref('sessions/'+sessionId+'/likes').set(likedRestaurants).then(() => console.log("Likes updated for:", sessionId)).catch(e=>console.error("Likes update error:",e));
        }
        function initializeFirebase() {
            if(typeof firebase==='undefined'||typeof firebase.initializeApp==='undefined'){console.warn("Firebase SDK not ready.");return;}
            try{
                 const cfg={apiKey:"AIzaSyDauSN6vXVeflYHYdx54hIsXWeTxp-CarM",authDomain:"restaurant-finder-36e61.firebaseapp.com",databaseURL:"https://restaurant-finder-36e61-default-rtdb.asia-southeast1.firebasedatabase.app",projectId:"restaurant-finder-36e61",storageBucket:"restaurant-finder-36e61.appspot.com",messagingSenderId:"266887715200",appId:"1:266887715200:web:6c68d924d7596cdfb44965",measurementId:"G-TD5GNXZZMN"};
                 if (!firebase.apps.length) {firebase.initializeApp(cfg);console.log("Firebase initialized.");}
                 else {console.log("Firebase already initialized.");}
            }catch(e){console.error("Firebase init error:",e);showError("Sharing unavailable."); resultsUI.findMatchesButton.disabled = true; resultsUI.copyCodeButton.disabled = true; resultsUI.copyLinkButton.disabled = true;}
        }

        // --- Utility & Event Listeners ---
        function resetApp() {
            locationInput.value=''; radiusSelect.value='2000'; priceLevelSelect.value=''; cuisineKeywordInput.value=''; resultsUI.friendCodeInput.value='';
            highRatingFilter.checked = false; // Reset the high-rating filter
            popularPlacesFilter.checked = false; // Reset the popular places filter
            restaurants=[]; currentIndex=0; likedRestaurants={}; sessionId=''; userCoordinates=null;
            resultsUI.likedListContainer.innerHTML = ''; resultsUI.likedListContainer.classList.add('hidden');
            resultsUI.viewLikedButton.textContent = 'View My Liked Food Places';
            resultsUI.shareLinkInput.value = ''; resultsUI.copyLinkButton.disabled = true;
            matchesUI.list.innerHTML = ''; sharedUI.list.innerHTML = '';
            hideError();
            // Ensure URL is cleaned up if resetting from a shared link view
            if (window.location.search.includes('share=')) {
                window.history.replaceState({}, document.title, window.location.pathname); // Remove query param
            }
            showView(views.search); console.log("App reset.");
        }
        function copySessionId() {
             const code=resultsUI.sessionId.textContent; if(!code||code==='CODE'||!navigator.clipboard){showError("Copy failed.");return;}
             navigator.clipboard.writeText(code).then(()=>{const t=resultsUI.copyCodeButton.textContent;resultsUI.copyCodeButton.textContent='✅';setTimeout(()=>{resultsUI.copyCodeButton.textContent='📋';},1500);}).catch(err=>{console.error('Copy failed:',err);showError("Copy failed.");});
        }

        window.swipeUI = swipeUI; window.resultsUI = resultsUI; window.matchesUI = matchesUI; window.sharedUI = sharedUI;

        // --- Event Listeners ---
        searchForm.addEventListener('submit', (e) => { e.preventDefault(); fetchRestaurants(); });
        useLocationButton.addEventListener('click', getUserLocation);
        swipeUI.prevPhotoBtn.addEventListener('click', () => changePhoto(-1));
        swipeUI.nextPhotoBtn.addEventListener('click', () => changePhoto(1));
        swipeUI.dislikeButton.addEventListener('click', () => handleSwipe(false));
        swipeUI.likeButton.addEventListener('click', () => handleSwipe(true));
        resultsUI.findMatchesButton.addEventListener('click', findMatches);
        resultsUI.startOverButton.addEventListener('click', resetApp);
        resultsUI.copyCodeButton.addEventListener('click', copySessionId);
        resultsUI.sessionId.addEventListener('click', () => { if (resultsUI.sessionId.textContent !== 'CODE') { window.getSelection().selectAllChildren(resultsUI.sessionId); }});
        resultsUI.viewLikedButton.addEventListener('click', () => { const isHidden = resultsUI.likedListContainer.classList.toggle('hidden'); resultsUI.viewLikedButton.textContent = isHidden ? 'View My Liked Food Places' : 'Hide My Liked Food Places'; });
        resultsUI.copyLinkButton.addEventListener('click', copyShareLink);
        matchesUI.startOverButton.addEventListener('click', resetApp);
        sharedUI.startOverButton.addEventListener('click', resetApp);

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM loaded.");

            // *** ALWAYS load Maps and initialize Firebase ***
            loadGoogleMapsScript();
            // Initialize Firebase slightly deferred to ensure SDKs load, but always run it
            setTimeout(initializeFirebase, 500);

            // *** Check for share parameter AFTER starting initializations ***
            const urlParams = new URLSearchParams(window.location.search);
            const shareId = urlParams.get('share');

            if (shareId) {
                // If share ID exists, prepare to handle it after Firebase is ready.
                // Show loading view immediately while waiting for Firebase.
                setLoadingText("Loading shared list...");
                showView(views.loading); // Show loading early

                const firebaseInitInterval = setInterval(() => {
                    // Check if Firebase is initialized
                    if (typeof firebase !== 'undefined' && firebase.apps.length > 0 && firebase.database()) {
                        clearInterval(firebaseInitInterval);
                        console.log("Firebase ready, handling shared link...");
                        handleSharedLink(shareId); // Handle the link AFTER Firebase is ready
                    }
                 }, 150); // Check slightly less frequently

                 // Timeout safeguard in case Firebase never loads/initializes
                 setTimeout(() => {
                      // Check if we are still stuck on loading or haven't transitioned to shared view
                      if(currentVisibleView === views.loading || currentVisibleView !== views.shared){
                         clearInterval(firebaseInitInterval);
                         console.error("Timeout waiting for Firebase initialization for shared link.");
                         showError("Failed to initialize services to load shared list in time.");
                         // Decide on a fallback view - Resetting is usually safest
                         resetApp(); // Reset state and show search view
                      }
                 }, 10000); // 10 second timeout

            } else {
                // Normal startup sequence: Just show the search view
                // Maps and Firebase are already being initialized above.
                showView(views.search);
            }
        });
    </script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js" defer></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js" defer></script>

</body>
</html>
