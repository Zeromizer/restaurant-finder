<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Restaurant Matcher</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }

        body {
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 500px;
            margin: 20px auto; /* Add margin top/bottom */
            padding: 20px;
            overflow: hidden; /* Prevent content shifts during fade */
        }

        /* View transition styles */
        .view {
            width: 100%;
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
        }
        .view.hidden {
            opacity: 0;
            height: 0; /* Collapse hidden views */
            overflow: hidden; /* Hide content during transition */
            display: block; /* Keep in layout for transition */
            pointer-events: none; /* Prevent interaction */
        }
        /* Override display:none for hidden class specifically for views */
        #search-view, #loading-view, #swipe-view, #results-view, #matches-view {
             display: block; /* Ensure elements are always block for transition */
        }
        /* Truly hide when transition is done (can be done via JS if needed, but opacity=0 usually sufficient) */
        .view.hidden {
            /* display: none; -- Replaced by opacity/height trick */
        }


        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            color: #FF5864;
            margin-bottom: 5px;
        }

        .search-form {
            background-color: white;
            border-radius: 8px;
            padding: 20px; /* Increased padding */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #555; /* Slightly softer label color */
        }

        input, select {
            width: 100%;
            padding: 12px; /* Increased padding */
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            background-color: #fff; /* Ensure background */
        }
        input:focus, select:focus {
            border-color: #FF5864; /* Highlight on focus */
            outline: none;
            box-shadow: 0 0 0 2px rgba(255, 88, 100, 0.2);
        }

        .button {
            background-color: #FF5864;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            display: inline-block;
            text-align: center;
            width: 100%;
            transition: background-color 0.2s ease, transform 0.1s ease; /* Added transform */
        }

        .button:hover {
            background-color: #e1404d;
            transform: scale(1.02); /* Slight grow on hover */
        }
        .button:active {
             transform: scale(0.98); /* Slight shrink on click */
        }

        .button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none; /* Disable hover/active transforms */
        }

        /* Card Layout Fix */
        .card {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            margin-bottom: 20px;
            height: 580px; /* Increased height slightly */
            position: relative; /* Needed for absolute positioning of actions */
            display: flex;
            flex-direction: column;
        }

        .photo-container {
            position: relative;
            width: 100%;
            height: 55%; /* Adjust photo area height */
            overflow: hidden;
            flex-shrink: 0; /* Prevent shrinking */
            background-color: #eee; /* Placeholder bg */
        }

        .card-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block; /* Remove extra space below image */
        }

        /* Photo Navigation */
         .photo-nav {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1; /* Ensure it's above image */
        }

        .photo-nav-btn {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 5px;
            transition: background-color 0.2s;
        }
        .photo-nav-btn:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }


        #photo-indicators {
            display: flex;
            justify-content: center;
            margin: 0 10px;
        }
         .photo-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
            margin: 0 4px;
            display: inline-block;
            transition: background-color 0.3s;
        }
        .photo-dot.active {
            background-color: #fff;
        }


        /* Card Content Area */
         .card-content {
            padding: 15px;
            flex-grow: 1; /* Allow content to take remaining space */
            overflow-y: auto; /* Add scroll if content overflows */
             padding-bottom: 75px; /* Add padding to prevent overlap with absolute actions */
        }

        .card-title {
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 8px; /* Increased margin */
            color: #333;
        }

        .card-info {
            color: #555; /* Slightly darker info text */
            margin-bottom: 8px; /* Spacing between info lines */
            font-size: 15px; /* Slightly smaller info font */
        }
        .card-info#restaurant-address {
             line-height: 1.4; /* Improve address readability */
        }

        /* Card Actions Area - Positioned Absolutely */
        .card-actions {
            position: absolute; /* Position relative to card */
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            padding: 15px; /* Padding around buttons */
            background: linear-gradient(to top, rgba(255,255,255,1) 50%, rgba(255,255,255,0)); /* Fade background */
            /* background-color: white; /* Solid background if gradient is not preferred */
            border-top: 1px solid #eee; /* Subtle separator */
             z-index: 2; /* Ensure above scrolling content */
        }

        .action-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15); /* Slightly softer shadow */
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease; /* Smooth transition */
            font-size: 24px;
        }
        .action-button:hover {
            transform: scale(1.1); /* Scale up on hover */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
         .action-button:active {
             transform: scale(1.05); /* Slightly smaller scale on active */
             box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
         }

        .like-button { color: #00d174; }
        .dislike-button { color: #fd5068; }
        .info-button { color: #2980b9; }

        /* Removed .hidden - using .view.hidden now */

        .loading {
            display: flex;
            flex-direction: column; /* Stack spinner and text */
            justify-content: center;
            align-items: center;
            min-height: 300px; /* Ensure minimum height */
            padding: 20px;
            text-align: center;
            color: #555;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #FF5864;
            animation: spin 1s linear infinite;
            margin-bottom: 15px; /* Space between spinner and text */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            color: #c0392b; /* Darker red */
            text-align: center;
            padding: 15px;
            background-color: #fbecea; /* Lighter red background */
            border: 1px solid #e74c3c; /* Red border */
            border-radius: 8px;
            margin: 20px 0;
            font-size: 15px;
        }

        .restaurant-list {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-top: 15px; /* Space above list */
        }

        .restaurant-item {
            padding: 15px 10px; /* More padding */
            border-bottom: 1px solid #eee;
        }
        .restaurant-item:last-child {
            border-bottom: none;
        }
         .restaurant-item h3 {
             margin-bottom: 5px;
             color: #333;
         }
         .restaurant-item p {
             font-size: 14px;
             color: #666;
             margin-bottom: 3px;
         }

        .price-level {
            color: #27ae60; /* Slightly different green */
            font-weight: 500;
        }

        .location-input-container {
            display: flex;
            gap: 10px;
            align-items: center; /* Align items vertically */
        }

        .location-input {
            flex-grow: 1;
        }

        .location-button {
            width: auto;
            padding: 10px 15px; /* Adjust padding */
            white-space: nowrap;
            flex-shrink: 0; /* Prevent shrinking */
            font-size: 15px; /* Match input font size */
            height: 42px; /* Match input height */
            line-height: 1.4; /* Adjust line height */
        }

        /* Google Places Autocomplete styles */
        .pac-container {
            font-family: Arial, sans-serif;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000 !important; /* Ensure it's above other elements */
        }

        .pac-item {
            padding: 10px; /* More padding */
            cursor: pointer;
            font-size: 15px;
        }

        .pac-item:hover {
            background-color: #f5f5f5;
        }
        .pac-item-query {
            font-weight: 500; /* Bolder main text */
        }

    </style>
    <!-- Google Maps script is loaded dynamically in JS now -->
</head>
<body>
    <div class="container">
         <div id="error-container" class="error-message hidden"></div> <!-- Moved error display to top -->

        <!-- Search View -->
        <div id="search-view" class="view">
            <div class="header">
                <h1>Restaurant Matcher</h1>
                <p>Find restaurants to enjoy with friends</p>
            </div>

            <form id="search-form" class="search-form">
                <div class="form-group">
                    <label for="location">Location</label>
                    <div class="location-input-container">
                        <input
                            id="location"
                            type="text"
                            placeholder="Enter city, neighborhood, or address"
                            class="location-input"
                            required
                        />
                        <button type="button" id="use-location-button" class="button location-button">
                            📍 My Location
                        </button>
                    </div>
                </div>

                <div class="form-group">
                    <label for="radius">Distance (km)</label>
                    <select id="radius">
                        <option value="1000">1 km</option>
                        <option value="2000" selected>2 km</option>
                        <option value="5000">5 km</option>
                        <option value="10000">10 km</option>
                        <option value="20000">20 km</option> <!-- Added wider option -->
                    </select>
                </div>

                <div class="form-group">
                    <label for="price-level">Price Level</label>
                    <select id="price-level">
                        <option value="">Any</option>
                        <option value="1">$ (Inexpensive)</option>
                        <option value="2">$$ (Moderate)</option>
                        <option value="3">$$$ (Expensive)</option>
                        <option value="4">$$$$ (Very Expensive)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="cuisine">Cuisine Type (Optional)</label>
                    <select id="cuisine">
                        <option value="">Any</option>
                        <option value="Italian">Italian</option>
                        <option value="Chinese">Chinese</option>
                        <option value="Japanese">Japanese</option>
                        <option value="Mexican">Mexican</option>
                        <option value="Indian">Indian</option>
                        <option value="Thai">Thai</option>
                        <option value="American">American</option>
                        <option value="French">French</option>
                        <option value="Vietnamese">Vietnamese</option>
                        <option value="Korean">Korean</option>
                        <option value="Mediterranean">Mediterranean</option>
                        <option value="Pizza">Pizza</option>
                        <option value="Sushi">Sushi</option>
                        <option value="Cafe">Cafe</option>
                        <option value="Bar">Bar</option>
                        <!-- Add more cuisines as desired -->
                    </select>
                </div>

                <button type="submit" class="button" id="search-button">
                    Find Restaurants
                </button>
            </form>
        </div>

        <!-- Loading View -->
        <div id="loading-view" class="view hidden">
             <div class="loading">
                <div class="spinner"></div>
                <p>Finding restaurants...</p> <!-- Added text -->
            </div>
        </div>

        <!-- Swipe View -->
        <div id="swipe-view" class="view hidden">
            <div class="header">
                <h1>Find Your Match</h1>
                <p>Restaurant <span id="current-index">1</span> of <span id="total-restaurants">20</span></p>
            </div>

            <div class="card">
                <div class="photo-container">
                    <img class="card-img" id="restaurant-image" src="https://placehold.co/600x400?text=Loading..." alt="Restaurant">
                    <div class="photo-nav">
                        <button id="prev-photo" class="photo-nav-btn">❮</button>
                        <div id="photo-indicators"></div>
                        <button id="next-photo" class="photo-nav-btn">❯</button>
                    </div>
                </div>
                <div class="card-content">
                    <h2 class="card-title" id="restaurant-name">Loading...</h2>
                    <p class="card-info" id="restaurant-cuisine">Cuisine: ...</p>
                    <p class="card-info" id="restaurant-rating">Rating: ...</p>
                    <p class="card-info" id="restaurant-price">Price: ...</p>
                    <p class="card-info" id="restaurant-address">Address: ...</p>
                </div>
                 <!-- Actions are absolutely positioned now -->
                 <div class="card-actions">
                    <div class="action-button dislike-button" id="dislike-button">❌</div>
                    <div class="action-button info-button" id="info-button">ℹ️</div>
                    <div class="action-button like-button" id="like-button">❤️</div>
                </div>
            </div>
        </div>

        <!-- Results View -->
        <div id="results-view" class="view hidden">
            <div class="header">
                <h1>Your Results</h1>
                <p>You liked <span id="liked-count">0</span> restaurant(s)</p>
            </div>

            <div class="search-form"> <!-- Re-use form styling for consistency -->
                <p style="text-align: center; margin-bottom: 15px;">Share this code with your friend:</p>
                <p style="text-align: center; margin-bottom: 20px;">
                    <strong id="session-id" style="font-size: 1.5em; background-color: #eee; padding: 5px 10px; border-radius: 4px; user-select: all; cursor: pointer;"></strong>
                    <button id="copy-code-button" style="margin-left: 10px; background: none; border: none; font-size: 1.2em; cursor: pointer;">📋</button>
                </p>


                <div class="form-group">
                    <label for="friend-code">Enter Friend's Code</label>
                    <input
                        id="friend-code"
                        type="text"
                        placeholder="Paste friend's code here"
                    />
                </div>

                <button class="button" id="find-matches-button">
                    Find Matches
                </button>

                <button class="button" id="start-over-button" style="margin-top: 15px; background-color: #6c757d; border-color: #6c757d;">
                    Start Over
                </button>
            </div>
        </div>

        <!-- Matches View -->
        <div id="matches-view" class="view hidden">
            <div class="header">
                <h1>Your Matches!</h1>
                <p>Restaurants both you and your friend liked</p>
            </div>

            <div id="matches-list" class="restaurant-list">
                <!-- Matches will be inserted here -->
                <p>Loading matches...</p>
            </div>

            <button class="button" id="matches-start-over-button" style="margin-top: 20px;">
                Start Over
            </button>
        </div>
    </div>

    <script>
        // DOM Elements (Grouped for clarity)
        const views = {
            search: document.getElementById('search-view'),
            loading: document.getElementById('loading-view'),
            swipe: document.getElementById('swipe-view'),
            results: document.getElementById('results-view'),
            matches: document.getElementById('matches-view')
        };

        const searchForm = document.getElementById('search-form');
        const locationInput = document.getElementById('location');
        const useLocationButton = document.getElementById('use-location-button');
        const radiusSelect = document.getElementById('radius');
        const priceLevelSelect = document.getElementById('price-level');
        const cuisineSelect = document.getElementById('cuisine');
        const searchButton = document.getElementById('search-button');

        const swipeUI = {
            currentIndex: document.getElementById('current-index'),
            totalRestaurants: document.getElementById('total-restaurants'),
            image: document.getElementById('restaurant-image'),
            name: document.getElementById('restaurant-name'),
            cuisine: document.getElementById('restaurant-cuisine'),
            rating: document.getElementById('restaurant-rating'),
            price: document.getElementById('restaurant-price'),
            address: document.getElementById('restaurant-address'),
            prevPhotoBtn: document.getElementById('prev-photo'),
            nextPhotoBtn: document.getElementById('next-photo'),
            photoIndicators: document.getElementById('photo-indicators'),
            dislikeButton: document.getElementById('dislike-button'),
            infoButton: document.getElementById('info-button'),
            likeButton: document.getElementById('like-button')
        };

        const resultsUI = {
             likedCount: document.getElementById('liked-count'),
             sessionId: document.getElementById('session-id'),
             friendCodeInput: document.getElementById('friend-code'),
             findMatchesButton: document.getElementById('find-matches-button'),
             startOverButton: document.getElementById('start-over-button'),
             copyCodeButton: document.getElementById('copy-code-button')
        };

         const matchesUI = {
            list: document.getElementById('matches-list'),
            startOverButton: document.getElementById('matches-start-over-button')
         };

        const errorContainer = document.getElementById('error-container');

        // App State
        let restaurants = [];
        let currentIndex = 0;
        let likedRestaurants = {}; // Store liked status by restaurant ID { 'place_id1': true, ... }
        let sessionId = '';
        let userCoordinates = null; // { lat: number, lng: number }
        let autocomplete = null;
        let currentView = views.search; // Track the current visible view

        // --- Core Functions ---

        // Show a specific view with transition
        function showView(viewElement) {
            if (currentView) {
                currentView.classList.add('hidden');
            }
            viewElement.classList.remove('hidden');
            currentView = viewElement;
            window.scrollTo(0, 0); // Scroll to top on view change
        }

        // Show error message
        function showError(message) {
            errorContainer.textContent = message;
            errorContainer.classList.remove('hidden');
            // Optionally hide after a delay
            // setTimeout(hideError, 5000);
        }

        // Hide error message
        function hideError() {
            errorContainer.classList.add('hidden');
            errorContainer.textContent = ''; // Clear text
        }

         // --- Google Maps / Geolocation ---

         function loadGoogleMapsScript() {
             if (document.getElementById('google-maps-script')) return; // Already loaded or loading

             const script = document.createElement('script');
             script.id = 'google-maps-script';
             // !! IMPORTANT: Replace YOUR_API_KEY below !!
             const apiKey = "AIzaSyCHBWV_-CcYHftllY2aZ22SfSySw9PjqFo"; // Use your actual key
             if (!apiKey || apiKey === "YOUR_API_KEY") {
                 console.error("API Key for Google Maps is missing or invalid!");
                 showError("Map services are not configured correctly. Please contact support.");
                 return; // Don't load script without key
             }
             script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places,geometry&callback=initMapServices`;
             script.async = true;
             script.defer = true; // Defer execution
             script.onerror = () => {
                 console.error("Failed to load Google Maps script.");
                 showError("Failed to load location services. Please check your internet connection and refresh.");
             };
             document.head.appendChild(script);
        }

        // Callback function called by Google Maps script
        window.initMapServices = function() {
             console.log("Google Maps API loaded and ready.");
             initAutocomplete();
             // You could potentially enable search button here if it was disabled
        };

        // Initialize Google Places Autocomplete
        function initAutocomplete() {
            console.log("Initializing Places Autocomplete");
            if (typeof google === 'undefined' || !google.maps || !google.maps.places) {
                console.error("Google Maps Places library not loaded when trying to init Autocomplete.");
                 // It might load shortly, but maybe show a temporary warning?
                return; // Exit if maps not ready
            }

            autocomplete = new google.maps.places.Autocomplete(
                locationInput,
                {
                    types: ['geocode', 'establishment'], // Broader search
                    fields: ['geometry', 'name', 'formatted_address', 'place_id'], // Get place_id too
                    componentRestrictions: { country: [] } // Bias towards user's location, but allow global
                }
            );

            autocomplete.addListener('place_changed', function() {
                const place = autocomplete.getPlace();
                hideError(); // Hide error on new selection

                if (!place.geometry || !place.geometry.location) {
                    console.log("Autocomplete selection has no geometry:", place.name);
                    userCoordinates = null; // Clear coords if selection is invalid
                    // Optional: Show a message asking user to select a valid place
                    // showError("Please select a valid location from the suggestions.");
                    return;
                }

                userCoordinates = {
                    lat: place.geometry.location.lat(),
                    lng: place.geometry.location.lng()
                };
                console.log("Place selected:", place.name, "Coords:", userCoordinates);
                locationInput.value = place.formatted_address || place.name; // Update input field
            });
        }

        // Get user's current location via Geolocation API
        function getUserLocation() {
            if (!navigator.geolocation) {
                showError("Geolocation is not supported by your browser.");
                return;
            }

            useLocationButton.textContent = "Finding...";
            useLocationButton.disabled = true;
            hideError();

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    userCoordinates = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude
                    };
                    console.log("Geolocation successful:", userCoordinates);
                    locationInput.value = `Current Location (${userCoordinates.lat.toFixed(4)}, ${userCoordinates.lng.toFixed(4)})`;
                    useLocationButton.textContent = "📍 My Location";
                    useLocationButton.disabled = false;
                },
                (error) => {
                    console.error("Geolocation error:", error);
                    let message = "Could not get your location.";
                    switch(error.code) {
                        case error.PERMISSION_DENIED: message = "Location permission denied."; break;
                        case error.POSITION_UNAVAILABLE: message = "Location information unavailable."; break;
                        case error.TIMEOUT: message = "Location request timed out."; break;
                    }
                    showError(message);
                    userCoordinates = null; // Clear coordinates on error
                    locationInput.value = ''; // Clear input field
                    useLocationButton.textContent = "📍 My Location";
                    useLocationButton.disabled = false;
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }

        // --- Restaurant Search & Display ---

        // Fetch restaurants based on form input
        function fetchRestaurants() {
            showView(views.loading);
            hideError();

            const locationText = locationInput.value;
            const radius = parseInt(radiusSelect.value);
            const priceLevel = priceLevelSelect.value;
            const cuisine = cuisineSelect.value;

            if (typeof google === 'undefined' || !google.maps || !google.maps.places) {
                showError("Location services are not ready. Please wait or refresh.");
                showView(views.search);
                return;
            }

            // Prioritize stored coordinates, then try geocoding text input
            if (userCoordinates) {
                performNearbySearch(userCoordinates, radius, cuisine, priceLevel);
            } else if (locationText && !locationText.startsWith("Current Location")) { // Avoid geocoding placeholder text
                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ address: locationText }, (results, status) => {
                    if (status === 'OK' && results && results[0] && results[0].geometry && results[0].geometry.location) {
                         userCoordinates = { lat: results[0].geometry.location.lat(), lng: results[0].geometry.location.lng() };
                         console.log("Geocoded location:", locationText, "to:", userCoordinates);
                         performNearbySearch(userCoordinates, radius, cuisine, priceLevel);
                    } else {
                         console.error("Geocoding failed:", status);
                         showError(`Could not find coordinates for "${locationText}". Try a different location or use "My Location".`);
                         showView(views.search);
                    }
                });
            } else {
                 showError("Please provide a location (type or use 'My Location').");
                 showView(views.search);
            }
        }

        // Perform the actual search using Google Places API
        function performNearbySearch(coords, radius, cuisine, priceLevel) {
            const placesService = new google.maps.places.PlacesService(document.createElement('div')); // Dummy div

            let request = {
                location: new google.maps.LatLng(coords.lat, coords.lng),
                radius: radius,
                type: 'restaurant',
                // rankBy: google.maps.places.RankBy.PROMINENCE // Prominence often better than DISTANCE
            };

            if (cuisine) request.keyword = cuisine;
            if (priceLevel) {
                request.minPriceLevel = parseInt(priceLevel);
                request.maxPriceLevel = parseInt(priceLevel);
            }

            console.log("Places API Request:", request);

            placesService.nearbySearch(request, (results, status, pagination) => {
                console.log("Places API Response Status:", status);
                 if (status === google.maps.places.PlacesServiceStatus.OK && results && results.length > 0) {
                     const operationalResults = results
                         .filter(place => place.business_status === 'OPERATIONAL')
                         .slice(0, 20); // Limit to 20 operational results

                    if (operationalResults.length === 0) {
                         showError(`No operational restaurants found matching criteria. Try broadening your search.`);
                         showView(views.search);
                         return;
                    }

                    console.log("Found", operationalResults.length, "operational restaurants. Fetching details...");
                    processRestaurantResults(operationalResults, cuisine);

                 } else if (status === google.maps.places.PlacesServiceStatus.ZERO_RESULTS) {
                     showError("No restaurants found matching your criteria. Try different options.");
                     showView(views.search);
                 } else {
                     console.error("Places API Error:", status);
                     showError(`Could not fetch restaurants (Error: ${status}). Please try again.`);
                     showView(views.search);
                 }
            });
        }

        // Get details (like photos) for multiple places
        function getPlaceDetails(placeIds) {
            const placesService = new google.maps.places.PlacesService(document.createElement('div'));
            const promises = placeIds.map(placeId => {
                return new Promise((resolve, reject) => {
                    placesService.getDetails({
                        placeId: placeId,
                        fields: ['photos', 'name'] // Only need photos here
                    }, (details, status) => {
                        if (status === google.maps.places.PlacesServiceStatus.OK && details) {
                            resolve({ placeId, photos: details.photos || [] });
                        } else {
                            console.warn(`Failed to get details for ${placeId}: ${status}`);
                            resolve({ placeId, photos: [] }); // Resolve successfully but with empty photos
                        }
                    });
                });
            });
            return Promise.all(promises);
        }

        // Process results and fetch additional details (photos)
        async function processRestaurantResults(results, searchCuisine) {
            try {
                const placeIds = results.map(r => r.place_id);
                const details = await getPlaceDetails(placeIds);
                const detailsMap = details.reduce((map, detail) => {
                    map[detail.placeId] = detail.photos;
                    return map;
                }, {});

                restaurants = results.map(place => {
                    const placePhotos = detailsMap[place.place_id] || place.photos || []; // Use detailed photos preferentially
                    const photoUrls = placePhotos
                         .slice(0, 5) // Limit to 5 photos
                         .map(photo => photo.getUrl ? photo.getUrl({ maxWidth: 600 }) : null) // Get URL
                         .filter(url => url); // Filter out nulls

                    if (photoUrls.length === 0) {
                        photoUrls.push("https://placehold.co/600x400/FF5864/white?text=No+Image"); // Placeholder
                    }

                    return {
                        id: place.place_id,
                        name: place.name || "Unnamed Restaurant",
                        address: place.vicinity || "Address unavailable",
                        // Use specified cuisine if provided, otherwise try to infer
                        cuisine: searchCuisine || getCuisineFromTypes(place.types || []),
                        rating: place.rating ? `${place.rating}★ (${place.user_ratings_total || 0})` : "Not rated",
                        priceLevel: place.price_level === undefined ? 0 : place.price_level, // Default to 0 (N/A)
                        photoUrls: photoUrls,
                        currentPhotoIndex: 0
                    };
                });

                if (restaurants.length === 0) {
                     showError('No restaurants found after processing. Try different criteria.');
                     showView(views.search);
                     return;
                }

                sessionId = generateSessionId();
                saveSessionToFirebase(); // Save to Firebase async

                currentIndex = 0;
                likedRestaurants = {};
                updateRestaurantDisplay();
                showView(views.swipe);

            } catch (error) {
                console.error("Error processing restaurant results:", error);
                showError("Error loading restaurant details. Please try again.");
                showView(views.search);
            }
        }


        // Helper to infer cuisine from place types
        function getCuisineFromTypes(types) {
             // Add more mappings as needed
            const typeMap = { 'cafe': 'Cafe', 'bar': 'Bar', 'bakery': 'Bakery' };
            const knownCuisines = ["Italian", "Chinese", "Japanese", "Mexican", "Indian", "Thai", "American", "French", "Vietnamese", "Korean", "Mediterranean", "Pizza", "Sushi", "Seafood", "Steakhouse"];

            for (const type of types) {
                const formattedType = type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()); // Format e.g. "meal_takeaway" -> "Meal Takeaway"
                if (knownCuisines.includes(formattedType)) return formattedType;
                if (typeMap[type]) return typeMap[type];
            }
            return types.includes('restaurant') ? 'Restaurant' : 'Food'; // Default
        }


        // Update the swipe card display
        function updateRestaurantDisplay() {
            if (currentIndex >= restaurants.length) {
                console.warn("Attempted to display past the end of restaurants array");
                // This case should ideally be handled by handleSwipe moving to results view
                showResultsView();
                return;
            }
            const restaurant = restaurants[currentIndex];

            swipeUI.currentIndex.textContent = currentIndex + 1;
            swipeUI.totalRestaurants.textContent = restaurants.length;

            // Reset photo index when displaying a new restaurant
            restaurant.currentPhotoIndex = restaurant.currentPhotoIndex || 0;

            // Update image source and alt text
            swipeUI.image.src = restaurant.photoUrls[restaurant.currentPhotoIndex];
            swipeUI.image.alt = restaurant.name;

            // Update photo indicators
            swipeUI.photoIndicators.innerHTML = ''; // Clear existing dots
            restaurant.photoUrls.forEach((url, index) => {
                const dot = document.createElement('span');
                dot.className = 'photo-dot' + (index === restaurant.currentPhotoIndex ? ' active' : '');
                swipeUI.photoIndicators.appendChild(dot);
            });

             // Show/hide photo navigation
            const showNav = restaurant.photoUrls.length > 1;
            swipeUI.prevPhotoBtn.style.display = showNav ? 'flex' : 'none';
            swipeUI.nextPhotoBtn.style.display = showNav ? 'flex' : 'none';
            swipeUI.photoIndicators.style.display = showNav ? 'flex' : 'none';


            // Update text info
            swipeUI.name.textContent = restaurant.name;
            swipeUI.cuisine.textContent = `Cuisine: ${restaurant.cuisine}`;
            swipeUI.rating.textContent = `Rating: ${restaurant.rating}`;
            swipeUI.price.textContent = `Price: ${restaurant.priceLevel > 0 ? '$'.repeat(restaurant.priceLevel) : 'N/A'}`;
            swipeUI.address.textContent = `Address: ${restaurant.address}`;

            // Ensure content scroll position is reset if needed
             views.swipe.querySelector('.card-content').scrollTop = 0;
        }

        // Navigate photos
        function changePhoto(direction) {
             if (currentIndex >= restaurants.length) return;
             const restaurant = restaurants[currentIndex];
             const numPhotos = restaurant.photoUrls.length;
             if (numPhotos <= 1) return; // No navigation needed

             restaurant.currentPhotoIndex = (restaurant.currentPhotoIndex + direction + numPhotos) % numPhotos;
             updateRestaurantDisplay(); // Re-render card with new photo index
        }

        // --- Swiping and Matching Logic ---

        // Handle like/dislike action
        function handleSwipe(liked) {
             if (currentIndex >= restaurants.length) return; // Already done

            const restaurantId = restaurants[currentIndex].id;
            if (liked) {
                likedRestaurants[restaurantId] = true;
                // Optional: Add animation for like
            } else {
                 // Optional: Track dislikes or just move on
                 // Optional: Add animation for dislike
            }

             // Update Firebase async (don't wait)
             saveLikesToFirebase();

            // Move to next card or results
            currentIndex++;
            if (currentIndex < restaurants.length) {
                updateRestaurantDisplay();
            } else {
                showResultsView();
            }
        }

        function showResultsView() {
             const likedCount = Object.keys(likedRestaurants).length;
             resultsUI.likedCount.textContent = likedCount;
             resultsUI.sessionId.textContent = sessionId;
             resultsUI.friendCodeInput.value = ''; // Clear friend code input
             showView(views.results);
        }


        // Find matches with friend
        function findMatches() {
            const friendCode = resultsUI.friendCodeInput.value.trim();
            if (!friendCode) {
                showError('Please enter your friend\'s code.');
                return;
            }
            if (friendCode === sessionId) {
                showError('You entered your own code. Enter your friend\'s code.');
                return;
            }

            showView(views.loading); // Show loading while fetching friend data
            hideError();

            if (typeof firebase === 'undefined' || !firebase.apps.length) {
                 console.warn("Firebase not ready, simulating match.");
                 // Simulate finding matches if Firebase is not available
                 setTimeout(() => {
                     const myLikedIds = Object.keys(likedRestaurants);
                     const simulatedFriendLikes = restaurants
                         .slice(0, Math.ceil(restaurants.length / 2)) // Simulate friend liking first half
                         .map(r => r.id)
                         .filter(id => myLikedIds.includes(id)); // Only those we also liked

                     const matchedRestaurants = restaurants.filter(r => simulatedFriendLikes.includes(r.id));
                     displayMatches(matchedRestaurants);
                 }, 1500);
                 return;
             }

            // Fetch friend's session data from Firebase
            firebase.database().ref('sessions/' + friendCode).once('value')
                .then(snapshot => {
                    const friendSessionData = snapshot.val();
                    if (!friendSessionData || !friendSessionData.likes) {
                        showError('Friend\'s code not found or they haven\'t finished swiping yet.');
                        showView(views.results); // Go back to results view
                        return;
                    }

                    const friendLikes = friendSessionData.likes || {}; // Friend's liked IDs { 'place_id': true, ... }
                    const friendLikedIds = Object.keys(friendLikes);
                    const myLikedIds = Object.keys(likedRestaurants);

                    // Find common liked IDs
                    const matchedIds = myLikedIds.filter(id => friendLikedIds.includes(id));

                    // Get restaurant details for matched IDs (prefer friend's data for consistency if needed)
                    const friendRestaurantsData = friendSessionData.restaurants || [];
                     const friendRestaurantsMap = friendRestaurantsData.reduce((map, r) => {
                         map[r.id] = r; return map;
                     }, {});
                     const myRestaurantsMap = restaurants.reduce((map, r) => {
                         map[r.id] = r; return map;
                     }, {});


                    const matchedRestaurants = matchedIds.map(id => {
                         // Use data from friend's list if available, else use ours
                         return friendRestaurantsMap[id] || myRestaurantsMap[id];
                    }).filter(r => r); // Ensure we have restaurant objects

                    displayMatches(matchedRestaurants);
                })
                .catch(error => {
                    console.error("Error fetching friend's data:", error);
                    showError('Could not retrieve friend\'s data. Check the code or try again.');
                    showView(views.results);
                });
        }

        // Display the final list of matched restaurants
        function displayMatches(matchedRestaurants) {
            matchesUI.list.innerHTML = ''; // Clear previous content

            if (matchedRestaurants.length > 0) {
                matchedRestaurants.forEach(restaurant => {
                    const item = document.createElement('div');
                    item.className = 'restaurant-item';
                     const priceText = restaurant.priceLevel > 0 ? '$'.repeat(restaurant.priceLevel) : 'N/A';
                    item.innerHTML = `
                        <h3>${restaurant.name}</h3>
                        <p>Cuisine: ${restaurant.cuisine}</p>
                        <p>Rating: ${restaurant.rating}</p>
                        <p class="price-level">Price: ${priceText}</p>
                        <p>Address: ${restaurant.address}</p>
                    `;
                    matchesUI.list.appendChild(item);
                });
            } else {
                matchesUI.list.innerHTML = '<p style="text-align: center; padding: 20px;">No common matches found. Maybe try another friend?</p>';
            }

            showView(views.matches);
        }

         // --- Firebase & Session ---

         function generateSessionId() {
             // Simple random string generator
             return Math.random().toString(36).substring(2, 10).toUpperCase();
         }

         // Save the initial restaurant list to Firebase
         function saveSessionToFirebase() {
             if (typeof firebase === 'undefined' || !firebase.apps.length || !sessionId) return;

              // Save a leaner version of restaurant data
             const restaurantsToSave = restaurants.map(r => ({
                 id: r.id, name: r.name, address: r.address, cuisine: r.cuisine,
                 rating: r.rating, priceLevel: r.priceLevel
                 // Not saving photos here to keep session data smaller
             }));


             firebase.database().ref('sessions/' + sessionId).set({
                 restaurants: restaurantsToSave,
                 timestamp: firebase.database.ServerValue.TIMESTAMP,
                 likes: {} // Initialize likes object
             })
             .then(() => console.log("Session created in Firebase:", sessionId))
             .catch(error => console.error("Firebase session save error:", error));
         }

         // Update likes in Firebase (can be called after each swipe)
         function saveLikesToFirebase() {
             if (typeof firebase === 'undefined' || !firebase.apps.length || !sessionId) return;

             firebase.database().ref('sessions/' + sessionId + '/likes').set(likedRestaurants)
                 .catch(error => console.error("Firebase likes update error:", error));
         }

         // Initialize Firebase App
         function initializeFirebase() {
              // Check if Firebase SDKs are loaded
              if (typeof firebase === 'undefined' || typeof firebase.initializeApp === 'undefined') {
                  console.warn("Firebase SDK not ready yet for initialization.");
                   // Optionally retry after a short delay
                   // setTimeout(initializeFirebase, 500);
                  return;
              }

             try {
                 // !! IMPORTANT: Replace with your actual Firebase config !!
                 const firebaseConfig = {
                    apiKey: "AIzaSyDauSN6vYVefIYHYdx54hIsXWeTxp-CgrM", // Replace if needed
                    authDomain: "restaurant-finder-36e61.firebaseapp.com",
                    databaseURL: "https://restaurant-finder-36e61-default-rtdb.asia-southeast1.firebasedatabase.app",
                    projectId: "restaurant-finder-36e61",
                    storageBucket: "restaurant-finder-36e61.appspot.com", // Check bucket name
                    messagingSenderId: "266887715200",
                    appId: "1:266887715200:web:6c68d924d7596cdfb44965",
                    measurementId: "G-TD5GNXZZMN" // Optional
                 };

                 // Initialize Firebase only if it hasn't been initialized yet
                 if (!firebase.apps.length) {
                      firebase.initializeApp(firebaseConfig);
                      console.log("Firebase initialized successfully.");
                 } else {
                      console.log("Firebase already initialized.");
                 }
                 // Enable offline persistence (optional, useful for spotty connections)
                 // firebase.database().setPersistenceEnabled(true);

             } catch (e) {
                 console.error("Error initializing Firebase:", e);
                 showError("Could not connect to sharing service. Matching may use simulated data.");
             }
         }


        // --- Utility & Reset ---

        // Reset the application state to the initial search view
        function resetApp() {
            locationInput.value = '';
            radiusSelect.value = '2000';
            priceLevelSelect.value = '';
            cuisineSelect.value = '';
            resultsUI.friendCodeInput.value = '';

            restaurants = [];
            currentIndex = 0;
            likedRestaurants = {};
            sessionId = '';
            userCoordinates = null;

             // Clear Autocomplete selection if needed
             // No direct API, but clearing input value helps user
             // locationInput.value = '';


            hideError();
            showView(views.search);
        }

        // Copy session ID to clipboard
        function copySessionId() {
            const code = resultsUI.sessionId.textContent;
            if (!code || !navigator.clipboard) {
                showError("Could not copy code (clipboard API unavailable). Please copy manually.");
                return;
            }
            navigator.clipboard.writeText(code).then(() => {
                // Visual feedback
                const originalText = resultsUI.copyCodeButton.textContent;
                resultsUI.copyCodeButton.textContent = '✅';
                setTimeout(() => { resultsUI.copyCodeButton.textContent = originalText; }, 1500);
            }).catch(err => {
                console.error('Failed to copy session ID: ', err);
                showError("Failed to copy code automatically. Please copy manually.");
            });
        }


        // --- Event Listeners ---
        searchForm.addEventListener('submit', (e) => {
            e.preventDefault();
            fetchRestaurants();
        });

        useLocationButton.addEventListener('click', getUserLocation);

        // Swipe view listeners
        swipeUI.prevPhotoBtn.addEventListener('click', () => changePhoto(-1));
        swipeUI.nextPhotoBtn.addEventListener('click', () => changePhoto(1));
        swipeUI.dislikeButton.addEventListener('click', () => handleSwipe(false));
        swipeUI.likeButton.addEventListener('click', () => handleSwipe(true));
        swipeUI.infoButton.addEventListener('click', () => {
             if (currentIndex >= restaurants.length) return;
             const r = restaurants[currentIndex];
             alert(`Details for: ${r.name}\n\nCuisine: ${r.cuisine}\nRating: ${r.rating}\nPrice: ${r.priceLevel > 0 ? '$'.repeat(r.priceLevel) : 'N/A'}\nAddress: ${r.address}`);
             // Add link to Google Maps?
             // const query = encodeURIComponent(`${r.name}, ${r.address}`);
             // window.open(`https://www.google.com/maps/search/?api=1&query=${query}`, '_blank');
        });

        // Results view listeners
        resultsUI.findMatchesButton.addEventListener('click', findMatches);
        resultsUI.startOverButton.addEventListener('click', resetApp);
        resultsUI.copyCodeButton.addEventListener('click', copySessionId);
        // Add click-to-select for session ID
         resultsUI.sessionId.addEventListener('click', () => {
             window.getSelection().selectAllChildren(resultsUI.sessionId);
         });

        // Matches view listener
        matchesUI.startOverButton.addEventListener('click', resetApp);


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded.");
            showView(views.search); // Start on search view
            loadGoogleMapsScript(); // Start loading Maps API
            initializeFirebase(); // Initialize Firebase
        });


    </script>

    <!-- Firebase SDK (defer ensures they load after HTML parse, before DOMContentLoaded potentially) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js" defer></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js" defer></script>

</body>
</html>
